
./Output/boot.out:     file format elf32-tradbigmips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00010000  80000000  80000000  00010000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .reginfo      00000018  80010000  80010000  00020000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA, LINK_ONCE_SAME_SIZE
  2 .rodata.str1.4 000026e8  80010018  80010018  00020018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00000a90  80012700  80012700  00022700  2**4
                  CONTENTS, ALLOC, LOAD, DATA
  4 .sbss         00000058  80013190  80013190  00023190  2**2
                  ALLOC
  5 .bss          000140c0  800131e8  800131e8  00023190  2**4
                  ALLOC
  6 .pdr          00001ec0  00000000  00000000  00023190  2**2
                  CONTENTS, READONLY
  7 .comment      0000002b  00000000  00000000  00025050  2**0
                  CONTENTS, READONLY
  8 .gnu.attributes 00000010  00000000  00000000  0002507b  2**0
                  CONTENTS, READONLY
  9 .debug_line   000027db  00000000  00000000  0002508b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0000b2e5  00000000  00000000  00027866  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00002e38  00000000  00000000  00032b4b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_aranges 00000360  00000000  00000000  00035988  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  00001c7c  00000000  00000000  00035ce8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00006b14  00000000  00000000  00037964  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_pubnames 000015fd  00000000  00000000  0003e478  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    000035b4  00000000  00000000  0003fa75  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00000148  00000000  00000000  00043029  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

80000000 <start>:
	 * FIXME: Use the initcode feature to get rid of unused handler
	 * variants.
	 */

#if 1
	b check_self_exist
80000000:	10000102 	b	8000040c <check_self_exist>
	nop
80000004:	00000000 	nop
	...

8000040c <check_self_exist>:


reset:

	/* Clear watch registers */
	mtc0	zero, CP0_WATCHLO
8000040c:	40809000 	mtc0	zero,c0_watchlo
	mtc0	zero, CP0_WATCHHI
80000410:	40809800 	mtc0	zero,c0_watchhi

	/* WP(Watch Pending), SW0/1 should be cleared */
	mtc0	zero, CP0_CAUSE
80000414:	40806800 	mtc0	zero,c0_cause
	

	mfc0	t0, CP0_STATUS
80000418:	40086000 	mfc0	t0,c0_status
	or	t0, ST0_CU0 | 0x1f  
8000041c:	3c011000 	lui	at,0x1000
80000420:	3421001f 	ori	at,at,0x1f
80000424:	01014025 	or	t0,t0,at
	xor	t0, 0x1f 
80000428:	3908001f 	xori	t0,t0,0x1f
	mtc0	t0, CP0_STATUS
8000042c:	40886000 	mtc0	t0,c0_status
	.set	noreorder
	sll	zero, 3				# ehb
80000430:	000000c0 	ehb


	/* Init Timer */
	mtc0	zero, CP0_COUNT
80000434:	40804800 	mtc0	zero,c0_count
	mtc0	zero, CP0_COMPARE
80000438:	40805800 	mtc0	zero,c0_compare



#if 1 //wei add for 1074k core 1
        mfc0    v1, CP0_PRID, 1
8000043c:	40037801 	mfc0	v1,c0_ebase
        andi    v1, 0x3ff
80000440:	306303ff 	andi	v1,v1,0x3ff
        beqz    v1, 1f   //ID=0 go out
80000444:	10600014 	beqz	v1,80000498 <loop+0x10>
 //       bnez    v1, 1f        //ID!=0 go out
        nop
80000448:	00000000 	nop


		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
8000044c:	3c0e3200 	lui	t6,0x3200
80000450:	3c0fb800 	lui	t7,0xb800
80000454:	35ef2000 	ori	t7,t7,0x2000
80000458:	adee0000 	sw	t6,0(t7)
8000045c:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
80000460:	3c0e3200 	lui	t6,0x3200
80000464:	3c0fb800 	lui	t7,0xb800
80000468:	35ef2000 	ori	t7,t7,0x2000
8000046c:	adee0000 	sw	t6,0(t7)
80000470:	00000000 	nop
		REG32_W(0xb8002000, '2'<<24);	  //Secondary CPU			
80000474:	3c0e3200 	lui	t6,0x3200
80000478:	3c0fb800 	lui	t7,0xb800
8000047c:	35ef2000 	ori	t7,t7,0x2000
80000480:	adee0000 	sw	t6,0(t7)
80000484:	00000000 	nop

80000488 <loop>:
	...
loop:
		
        nop
        nop
        b loop
80000490:	1000fffd 	b	80000488 <loop>
        nop
80000494:	00000000 	nop
		//li sp,0x80700000
		//li sp,0x80500000
		li sp,0xa0500000
		nop
#else
		li sp,0x80700000
80000498:	3c1d8070 	lui	sp,0x8070
	...
	nop
#endif
	nop
	nop

	jal	init_arch  	                                          
800004a8:	0c001827 	jal	8000609c <init_arch>
	nop  
800004ac:	00000000 	nop
	nop
800004b0:	00000000 	nop

800004b4 <romReserved>:
	
//==========================================================
#if 1
romReserved:
        b       romReserved
800004b4:	1000ffff 	b	800004b4 <romReserved>
        nop
800004b8:	00000000 	nop

800004bc <romExcHandle>:

romExcHandle:
        b       romExcHandle
800004bc:	1000ffff 	b	800004bc <romExcHandle>
		nop
800004c0:	00000000 	nop

800004c4 <ramExcHandle>:

ramExcHandle:
		b	ramExcHandle
800004c4:	1000ffff 	b	800004c4 <ramExcHandle>
		nop
800004c8:	00000000 	nop

800004cc <flush_cache_r>:
800004cc:	4080e802 	mtc0	zero,c0_taghi1
		sll zero,zero,1
		
	//----------------------------------------
//init_L1_dcahe:

	MTC0_SEL_OPCODE( 0, 29, 2 )   //R_C0_DTagHi
800004d0:	00000040 	ssnop
800004d4:	00000040 	ssnop
800004d8:	00000040 	ssnop
800004dc:	00000040 	ssnop
800004e0:	4080e002 	mtc0	zero,c0_taglo1
	MTC0_SEL_OPCODE( 0, 28, 2 )
800004e4:	00000040 	ssnop
800004e8:	00000040 	ssnop
800004ec:	00000040 	ssnop
800004f0:	00000040 	ssnop

0:	
	li	a2, START_ADDR
800004f4:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
800004f8:	24050020 	li	a1,32
	li  a3,START_ADDR+_DCACHE_SIZE-_CACHELINE_SIZE
800004fc:	3c078000 	lui	a3,0x8000
80000500:	34e77fe0 	ori	a3,a3,0x7fe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	DCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
80000504:	bcc90000 	cache	0x9,0(a2)


	bne	a2, a3, 1b
80000508:	14c7fffe 	bne	a2,a3,80000504 <flush_cache_r+0x38>
	addu	a2, a1
8000050c:	00c53021 	addu	a2,a2,a1
80000510:	4080e800 	mtc0	zero,c0_taghi


	//--------------------------------------------
//init_L1_icahe:	
	MTC0_SEL_OPCODE( 0, 29, 0 )   //R_C0_ITagHi
80000514:	00000040 	ssnop
80000518:	00000040 	ssnop
8000051c:	00000040 	ssnop
80000520:	00000040 	ssnop
80000524:	4080e000 	mtc0	zero,c0_taglo
	MTC0_SEL_OPCODE( 0, 28, 0 )
80000528:	00000040 	ssnop
8000052c:	00000040 	ssnop
80000530:	00000040 	ssnop
80000534:	00000040 	ssnop

0:	
	li	a2, START_ADDR
80000538:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
8000053c:	24050020 	li	a1,32
	li  a3,START_ADDR+_ICACHE_SIZE-_CACHELINE_SIZE
80000540:	3c078000 	lui	a3,0x8000
80000544:	34e7ffe0 	ori	a3,a3,0xffe0


	/* Loop through all lines, invalidating each of them */
1:	

	cache	ICACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
80000548:	bcc80000 	cache	0x8,0(a2)


	bne	a2, a3, 1b
8000054c:	14c7fffe 	bne	a2,a3,80000548 <flush_cache_r+0x7c>
	addu	a2, a1
80000550:	00c53021 	addu	a2,a2,a1

80000554 <init_L2_cache>:
	//disable L2 cache
	li t0,(1<<12)
	MTC0_SEL_OPCODE( 8,16,  2);
#else	
#define RTL98_V0 0x8198C000
	nop
80000554:	00000000 	nop
        REG32_R(0xb8000000,t8);
80000558:	3c0fb800 	lui	t7,0xb800
8000055c:	8df80000 	lw	t8,0(t7)
	...
        nop
	nop
//	IF_EQ(t8, RTL98_V0, lab_disSC); //jason
        nop
	nop
	li t0,(0<<12)
80000574:	24080000 	li	t0,0
80000578:	4080e004 	mtc0	zero,c0_taglo2
	MTC0_SEL_OPCODE( 0, 28, 4 )  //R_C0_SelL23TagLo
8000057c:	00000040 	ssnop
80000580:	00000040 	ssnop
80000584:	00000040 	ssnop
80000588:	00000040 	ssnop
	...
	nop
	nop
0:
	li	a2, START_ADDR
80000594:	3c068000 	lui	a2,0x8000
	li  a1,_CACHELINE_SIZE
80000598:	24050020 	li	a1,32
	li  a3,START_ADDR+_SCACHE_SIZE-_CACHELINE_SIZE
8000059c:	3c078007 	lui	a3,0x8007
800005a0:	34e7ffe0 	ori	a3,a3,0xffe0
	

	/* Loop through all lines, invalidating each of them */
1:	

	cache	SCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
800005a4:	bccb0000 	cache	0xb,0(a2)

	bne	a2, a3, 1b
800005a8:	14c7fffe 	bne	a2,a3,800005a4 <init_L2_cache+0x50>
	addu	a2, a1
800005ac:	00c53021 	addu	a2,a2,a1
	...
	nop
	nop
	j SC_EXIT
800005b8:	08000177 	j	800005dc <SC_EXIT>

800005bc <lab_disSC>:
lab_disSC:
	//disable L2 cache
	li t0,(1<<12)
800005bc:	24081000 	li	t0,4096
800005c0:	40888002 	mtc0	t0,c0_config2
	MTC0_SEL_OPCODE( 8,16,  2);
800005c4:	00000040 	ssnop
800005c8:	00000040 	ssnop
800005cc:	00000040 	ssnop
800005d0:	00000040 	ssnop
	...

800005dc <SC_EXIT>:
	nop
	nop
	
#endif
SC_EXIT:
	nop
800005dc:	00000000 	nop
	
	j ra
800005e0:	03e00008 	jr	ra
	nop
800005e4:	00000000 	nop
	...

80000600 <exception_matrix>:
	
	//copy this body to 0x80000180
		NESTED(exception_matrix, 0, sp)
#if 1

		mfc0	k1, CP0_CAUSE	
80000600:	401b6800 	mfc0	k1,c0_cause
	...
		nop
		nop
		la	k0, (exception_handlers)
8000060c:	3c1a8001 	lui	k0,0x8001
80000610:	275a4170 	addiu	k0,k0,16752
	...
		nop
		nop		
		andi	k1, k1, 0x7c
8000061c:	337b007c 	andi	k1,k1,0x7c
		addu	k0, k0, k1
80000620:	035bd021 	addu	k0,k0,k1
		lw	k0, (k0)
80000624:	8f5a0000 	lw	k0,0(k0)
		jr	k0
80000628:	03400008 	jr	k0
8000062c:	00000000 	nop
	...

80000640 <IRQ_finder>:
	.text
	.set	noreorder
	.set	noat
	.align	5
	NESTED(IRQ_finder, PT_SIZE, sp)
	SAVE_ALL
80000640:	401a6000 	mfc0	k0,c0_status
80000644:	001ad0c0 	sll	k0,k0,0x3
80000648:	07400003 	bltz	k0,80000658 <IRQ_finder+0x18>
8000064c:	03a0d821 	move	k1,sp
80000650:	3c1b8001 	lui	k1,0x8001
80000654:	8f7b31c0 	lw	k1,12736(k1)
80000658:	03a0d021 	move	k0,sp
8000065c:	277dff50 	addiu	sp,k1,-176
80000660:	afba008c 	sw	k0,140(sp)
80000664:	afa30024 	sw	v1,36(sp)
80000668:	afa00018 	sw	zero,24(sp)
8000066c:	40036000 	mfc0	v1,c0_status
80000670:	afa20020 	sw	v0,32(sp)
80000674:	afa300a8 	sw	v1,168(sp)
80000678:	afa40028 	sw	a0,40(sp)
8000067c:	40036800 	mfc0	v1,c0_cause
80000680:	afa5002c 	sw	a1,44(sp)
80000684:	afa300ac 	sw	v1,172(sp)
80000688:	afa60030 	sw	a2,48(sp)
8000068c:	40037000 	mfc0	v1,c0_epc
80000690:	afa70034 	sw	a3,52(sp)
80000694:	afa300a0 	sw	v1,160(sp)
80000698:	afb9007c 	sw	t9,124(sp)
8000069c:	afbc0088 	sw	gp,136(sp)
800006a0:	afbf0094 	sw	ra,148(sp)
800006a4:	37bc1fff 	ori	gp,sp,0x1fff
800006a8:	3b9c1fff 	xori	gp,gp,0x1fff
800006ac:	afa1001c 	sw	at,28(sp)
800006b0:	00001810 	mfhi	v1
800006b4:	afa80038 	sw	t0,56(sp)
800006b8:	afa9003c 	sw	t1,60(sp)
800006bc:	afa3009c 	sw	v1,156(sp)
800006c0:	00001812 	mflo	v1
800006c4:	afaa0040 	sw	t2,64(sp)
800006c8:	afab0044 	sw	t3,68(sp)
800006cc:	afa30098 	sw	v1,152(sp)
800006d0:	afac0048 	sw	t4,72(sp)
800006d4:	afad004c 	sw	t5,76(sp)
800006d8:	afae0050 	sw	t6,80(sp)
800006dc:	afaf0054 	sw	t7,84(sp)
800006e0:	afb80078 	sw	t8,120(sp)
800006e4:	afb00058 	sw	s0,88(sp)
800006e8:	afb1005c 	sw	s1,92(sp)
800006ec:	afb20060 	sw	s2,96(sp)
800006f0:	afb30064 	sw	s3,100(sp)
800006f4:	afb40068 	sw	s4,104(sp)
800006f8:	afb5006c 	sw	s5,108(sp)
800006fc:	afb60070 	sw	s6,112(sp)
80000700:	afb70074 	sw	s7,116(sp)
80000704:	afbe0090 	sw	s8,144(sp)
	CLI
80000708:	40086000 	mfc0	t0,c0_status
8000070c:	3c091000 	lui	t1,0x1000
80000710:	3529001f 	ori	t1,t1,0x1f
80000714:	01094025 	or	t0,t0,t1
80000718:	3908001f 	xori	t0,t0,0x1f
8000071c:	40886000 	mtc0	t0,c0_status
80000720:	000000c0 	ehb
	.set	at
	
		mfc0    t0, CP0_CAUSE       #get pending interrupts
80000724:	40086800 	mfc0	t0,c0_cause
	...
        nop
        nop
        
        mfc0    t2, CP0_STATUS
80000730:	400a6000 	mfc0	t2,c0_status
	...
        nop
        nop
        
        and     t0, t2              #isolate allowed ones
8000073c:	010a4024 	and	t0,t0,t2
        nop
80000740:	00000000 	nop
        and    t2, t0, 0xfc00      #CT: just look at the Hardware INT bit 10-15
80000744:	310afc00 	andi	t2,t0,0xfc00
        nop
80000748:	00000000 	nop
        
        bne     t2, zero, handle_it #it shows there are pending interrupt, jump to Handler.
8000074c:	1540000c 	bnez	t2,80000780 <handle_it>
        nop
80000750:	00000000 	nop
        nop
80000754:	00000000 	nop
1:        
        li      t0,( UART_THR + 0xb8000000)
80000758:	3c08b800 	lui	t0,0xb800
8000075c:	35082000 	ori	t0,t0,0x2000
        li      t1,'m'		    #it shows m, that is not reasonable to come here.
80000760:	2409006d 	li	t1,109
        nop
80000764:	00000000 	nop
        sb      t1, 0(t0)
80000768:	a1090000 	sb	t1,0(t0)
	...
     	nop
     	nop
	 		            #just hang here.
      	b	1b 
80000774:	1000fff8 	b	80000758 <IRQ_finder+0x118>
        nop
80000778:	00000000 	nop
        nop
8000077c:	00000000 	nop

80000780 <handle_it>:

handle_it:  
//see GIC
        la      t0, (GIC_BASE_ADDR+0x480)
80000780:	3c08bbdc 	lui	t0,0xbbdc
80000784:	35080480 	ori	t0,t0,0x480
        la      t1, (GIC_BASE_ADDR+0x400)
80000788:	3c09bbdc 	lui	t1,0xbbdc
8000078c:	35290400 	ori	t1,t1,0x400
	
        lw      a0, 0(t0)  	    
80000790:	8d040000 	lw	a0,0(t0)
        lw      a1, 0(t1)	    
80000794:	8d250000 	lw	a1,0(t1)
        nop
80000798:	00000000 	nop
        and     a0, a1		   
8000079c:	00852024 	and	a0,a0,a1
        

        la      t0, (GIC_BASE_ADDR+0x484)
800007a0:	3c08bbdc 	lui	t0,0xbbdc
800007a4:	35080484 	ori	t0,t0,0x484
        la      t1, (GIC_BASE_ADDR+0x404)	
800007a8:	3c09bbdc 	lui	t1,0xbbdc
800007ac:	35290404 	ori	t1,t1,0x404
        lw      a2, 0(t0)  	    
800007b0:	8d060000 	lw	a2,0(t0)
        lw      a1, 0(t1)	    
800007b4:	8d250000 	lw	a1,0(t1)
        nop        
800007b8:	00000000 	nop
        and     a1, a2		    
800007bc:	00a62824 	and	a1,a1,a2
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        
	jal irq_dispatch        #this will lead to real ISR 
800007c0:	0c000328 	jal	80000ca0 <irq_dispatch>
	nop
800007c4:	00000000 	nop
	nop
800007c8:	00000000 	nop
        li      t1,'o'		   
        nop
        sb      t1, 0(t0)
	//----------------------------------------------------------
#endif
        move   a1,sp
800007cc:	03a02821 	move	a1,sp
	RESTORE_ALL_AND_RET
800007d0:	40086000 	mfc0	t0,c0_status
800007d4:	3508001f 	ori	t0,t0,0x1f
800007d8:	3908001f 	xori	t0,t0,0x1f
800007dc:	40886000 	mtc0	t0,c0_status
800007e0:	3403ff00 	li	v1,0xff00
800007e4:	01034024 	and	t0,t0,v1
800007e8:	8fa200a8 	lw	v0,168(sp)
800007ec:	00031827 	nor	v1,zero,v1
800007f0:	00431024 	and	v0,v0,v1
800007f4:	00481025 	or	v0,v0,t0
800007f8:	40826000 	mtc0	v0,c0_status
800007fc:	8fbf0094 	lw	ra,148(sp)
80000800:	8fbc0088 	lw	gp,136(sp)
80000804:	8fb9007c 	lw	t9,124(sp)
80000808:	8fa70034 	lw	a3,52(sp)
8000080c:	8fa60030 	lw	a2,48(sp)
80000810:	8fa5002c 	lw	a1,44(sp)
80000814:	8fa40028 	lw	a0,40(sp)
80000818:	8fa30024 	lw	v1,36(sp)
8000081c:	8fa20020 	lw	v0,32(sp)
80000820:	8fa1001c 	lw	at,28(sp)
80000824:	8fb80098 	lw	t8,152(sp)
80000828:	8fa80038 	lw	t0,56(sp)
8000082c:	8fa9003c 	lw	t1,60(sp)
80000830:	03000013 	mtlo	t8
80000834:	8fb8009c 	lw	t8,156(sp)
80000838:	8faa0040 	lw	t2,64(sp)
8000083c:	8fab0044 	lw	t3,68(sp)
80000840:	03000011 	mthi	t8
80000844:	8fac0048 	lw	t4,72(sp)
80000848:	8fad004c 	lw	t5,76(sp)
8000084c:	8fae0050 	lw	t6,80(sp)
80000850:	8faf0054 	lw	t7,84(sp)
80000854:	8fb80078 	lw	t8,120(sp)
80000858:	8fb00058 	lw	s0,88(sp)
8000085c:	8fb1005c 	lw	s1,92(sp)
80000860:	8fb20060 	lw	s2,96(sp)
80000864:	8fb30064 	lw	s3,100(sp)
80000868:	8fb40068 	lw	s4,104(sp)
8000086c:	8fb5006c 	lw	s5,108(sp)
80000870:	8fb60070 	lw	s6,112(sp)
80000874:	8fb70074 	lw	s7,116(sp)
80000878:	8fbe0090 	lw	s8,144(sp)
8000087c:	8fba00a0 	lw	k0,160(sp)
80000880:	8fbd008c 	lw	sp,140(sp)
80000884:	409a7000 	mtc0	k0,c0_epc
80000888:	42000018 	eret
	...

800008a0 <clear_cp0_status>:
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
800008a0:	40026000 	mfc0	v0,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
800008a4:	00042027 	nor	a0,zero,a0
800008a8:	00442024 	and	a0,v0,a0
800008ac:	40846000 	mtc0	a0,c0_status
800008b0:	00000040 	ssnop
800008b4:	00000040 	ssnop
800008b8:	00000040 	ssnop
800008bc:	00000040 	ssnop
800008c0:	000000c0 	ehb
	SPECIAL_EHB();	
}								
800008c4:	03e00008 	jr	ra
800008c8:	00000000 	nop

800008cc <change_cp0_status>:
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
800008cc:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
800008d0:	00041027 	nor	v0,zero,a0
800008d4:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
800008d8:	00a42024 	and	a0,a1,a0
800008dc:	00441025 	or	v0,v0,a0
	write_32bit_cp0_register(CP0_STATUS, res);		
800008e0:	40826000 	mtc0	v0,c0_status
800008e4:	00000040 	ssnop
800008e8:	00000040 	ssnop
800008ec:	00000040 	ssnop
800008f0:	00000040 	ssnop
800008f4:	000000c0 	ehb
	SPECIAL_EHB();							
	return res;						
}
800008f8:	03e00008 	jr	ra
800008fc:	00000000 	nop

80000900 <GIC_GIMR_enable>:
//------------------------------------------------------------------------------
//============================================================================
GIC_GIMR_enable(int irq)
{
	
	if(irq<32)
80000900:	28820020 	slti	v0,a0,32
80000904:	10400007 	beqz	v0,80000924 <GIC_GIMR_enable+0x24>
80000908:	24030001 	li	v1,1
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
8000090c:	00831804 	sllv	v1,v1,a0
80000910:	3c02bbdc 	lui	v0,0xbbdc
80000914:	34420380 	ori	v0,v0,0x380
80000918:	ac430000 	sw	v1,0(v0)
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
8000091c:	0800024e 	j	80000938 <GIC_GIMR_enable+0x38>
80000920:	3c022ef7 	lui	v0,0x2ef7
	{
		REG32(GIC_BASE_ADDR+0x380)=(1<<irq);
	}
	else
	{		
		REG32(GIC_BASE_ADDR+0x384)=(1<<(irq-32));		
80000924:	00831804 	sllv	v1,v1,a0
80000928:	3c02bbdc 	lui	v0,0xbbdc
8000092c:	34420384 	ori	v0,v0,0x384
80000930:	ac430000 	sw	v1,0(v0)
	}

	//map2pin
	REG32(GIC_BASE_ADDR+0x500+irq*4)=0x80000000;	
80000934:	3c022ef7 	lui	v0,0x2ef7
80000938:	34420140 	ori	v0,v0,0x140
8000093c:	00821021 	addu	v0,a0,v0
80000940:	00021080 	sll	v0,v0,0x2
80000944:	3c038000 	lui	v1,0x8000
80000948:	ac430000 	sw	v1,0(v0)

	//map2vpe
	REG32(GIC_BASE_ADDR+0x2000+irq*0x20)=0x1;		
8000094c:	3c0205de 	lui	v0,0x5de
80000950:	3442e100 	ori	v0,v0,0xe100
80000954:	00822021 	addu	a0,a0,v0
80000958:	00042140 	sll	a0,a0,0x5
8000095c:	24020001 	li	v0,1
80000960:	ac820000 	sw	v0,0(a0)
}
80000964:	03e00008 	jr	ra
80000968:	00000000 	nop

8000096c <setup_IRQ>:
    struct irqaction *old, **p;
    unsigned long flags;

    p = irq_action + irq;
//    prom_printf("IRQ action=%x,%x\n",irq_action,irq);
    save_and_cli(flags);
8000096c:	40026000 	mfc0	v0,c0_status
80000970:	34410001 	ori	at,v0,0x1
80000974:	38210001 	xori	at,at,0x1
80000978:	40816000 	mtc0	at,c0_status
8000097c:	000000c0 	ehb
	...
    *p = new;
8000098c:	00042080 	sll	a0,a0,0x2
80000990:	3c038001 	lui	v1,0x8001
80000994:	246331f4 	addiu	v1,v1,12788
80000998:	00642021 	addu	a0,v1,a0
8000099c:	ac850000 	sw	a1,0(a0)
    
    restore_flags(flags);
800009a0:	40016000 	mfc0	at,c0_status
800009a4:	30420001 	andi	v0,v0,0x1
800009a8:	34210001 	ori	at,at,0x1
800009ac:	38210001 	xori	at,at,0x1
800009b0:	00411025 	or	v0,v0,at
800009b4:	40826000 	mtc0	v0,c0_status
800009b8:	000000c0 	ehb
	...
    
    return 0;
}
800009c8:	03e00008 	jr	ra
800009cc:	00001021 	move	v0,zero

800009d0 <request_IRQ>:

#endif


int request_IRQ(unsigned long irq, struct irqaction *action, void* dev_id)
{
800009d0:	27bdffe0 	addiu	sp,sp,-32
800009d4:	afbf001c 	sw	ra,28(sp)
800009d8:	afb10018 	sw	s1,24(sp)
800009dc:	afb00014 	sw	s0,20(sp)
800009e0:	00808821 	move	s1,a0

    int retval;
      
 //   prom_printf("IRQ No=%x,%x\n",irq,NR_IRQS);
    if (irq >= NR_IRQS)
800009e4:	2c820040 	sltiu	v0,a0,64
800009e8:	10400008 	beqz	v0,80000a0c <request_IRQ+0x3c>
800009ec:	2410ffea 	li	s0,-22
		return -EINVAL;

	action->dev_id = dev_id;
	
    retval = setup_IRQ(irq, action);
800009f0:	0c00025b 	jal	8000096c <setup_IRQ>
800009f4:	aca60010 	sw	a2,16(a1)
800009f8:	00408021 	move	s0,v0
 //   prom_printf("devid & retval =%x,%x\n",dev_id,retval);
 	
	//GIMR_enable_irq(irq);
	GIC_GIMR_enable(irq);
800009fc:	0c000240 	jal	80000900 <GIC_GIMR_enable>
80000a00:	02202021 	move	a0,s1
	
    if (retval)
80000a04:	12000003 	beqz	s0,80000a14 <request_IRQ+0x44>
80000a08:	8fbf001c 	lw	ra,28(sp)

	    return retval;
}
80000a0c:	02001021 	move	v0,s0
80000a10:	8fbf001c 	lw	ra,28(sp)
80000a14:	8fb10018 	lw	s1,24(sp)
80000a18:	8fb00014 	lw	s0,20(sp)
80000a1c:	03e00008 	jr	ra
80000a20:	27bd0020 	addiu	sp,sp,32

80000a24 <free_IRQ>:
//------------------------------------------------------------------------------

static void  GIMR_disable_irq(unsigned int irq)
{

	REG32(GIMR_REG) &= ~(1<<irq);	
80000a24:	3c02b800 	lui	v0,0xb800
80000a28:	34423000 	ori	v0,v0,0x3000
80000a2c:	8c430000 	lw	v1,0(v0)
80000a30:	24050001 	li	a1,1
80000a34:	00852804 	sllv	a1,a1,a0
80000a38:	00052827 	nor	a1,zero,a1
80000a3c:	00a31824 	and	v1,a1,v1
80000a40:	ac430000 	sw	v1,0(v0)

int	free_IRQ(unsigned long irq)
{
	GIMR_disable_irq(irq);	
	
}
80000a44:	03e00008 	jr	ra
80000a48:	00000000 	nop

80000a4c <set_except_vector>:

//------------------------------------------------------------------------------
void set_except_vector(int n, void *addr)
{
	unsigned handler = (unsigned long) addr;
	exception_handlers[n] = handler;
80000a4c:	00042080 	sll	a0,a0,0x2
80000a50:	3c028001 	lui	v0,0x8001
80000a54:	24424170 	addiu	v0,v0,16752
80000a58:	00822021 	addu	a0,a0,v0
}
80000a5c:	03e00008 	jr	ra
80000a60:	ac850000 	sw	a1,0(a0)

80000a64 <init_IRQ>:
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------


void  init_IRQ(void)
{
80000a64:	27bdffe8 	addiu	sp,sp,-24
80000a68:	afbf0014 	sw	ra,20(sp)
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000a6c:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
80000a70:	3c02ffff 	lui	v0,0xffff
80000a74:	344200ff 	ori	v0,v0,0xff
80000a78:	00621024 	and	v0,v1,v0
80000a7c:	40826000 	mtc0	v0,c0_status
80000a80:	00000040 	ssnop
80000a84:	00000040 	ssnop
80000a88:	00000040 	ssnop
80000a8c:	00000040 	ssnop
80000a90:	000000c0 	ehb
	change_cp0_status(ST0_IM, 0x00);
	

	/* Set up the external interrupt exception vector */
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);
80000a94:	00002021 	move	a0,zero
80000a98:	3c058000 	lui	a1,0x8000
80000a9c:	0c000293 	jal	80000a4c <set_except_vector>
80000aa0:	24a50640 	addiu	a1,a1,1600
inline unsigned int					
change_cp0_status(unsigned int change, unsigned int newvalue)	
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000aa4:	40036000 	mfc0	v1,c0_status
	res &= ~change;						
80000aa8:	3c02ffff 	lui	v0,0xffff
80000aac:	344200ff 	ori	v0,v0,0xff
80000ab0:	00621024 	and	v0,v1,v0
	res |= (newvalue & change);					
	write_32bit_cp0_register(CP0_STATUS, res);		
80000ab4:	34427c00 	ori	v0,v0,0x7c00
80000ab8:	40826000 	mtc0	v0,c0_status
80000abc:	00000040 	ssnop
80000ac0:	00000040 	ssnop
80000ac4:	00000040 	ssnop
80000ac8:	00000040 	ssnop
80000acc:	000000c0 	ehb
	/* First exception is Interrupt*/
	set_except_vector(0, IRQ_finder);

	/* Enable all interrupts */
	change_cp0_status(ST0_IM, ALLINTS);
}
80000ad0:	8fbf0014 	lw	ra,20(sp)
80000ad4:	03e00008 	jr	ra
80000ad8:	27bd0018 	addiu	sp,sp,24

80000adc <init_exception>:
}

unsigned long ebase_reg = 0;
//------------------------------------------------------------------------------
void  init_exception(void)
{
80000adc:	27bdffe0 	addiu	sp,sp,-32
80000ae0:	afbf001c 	sw	ra,28(sp)
80000ae4:	afb20018 	sw	s2,24(sp)
80000ae8:	afb10014 	sw	s1,20(sp)
80000aec:	afb00010 	sw	s0,16(sp)
inline unsigned int					
clear_cp0_status(unsigned int clear)				
{								
	unsigned int res;					
								
	res = read_32bit_cp0_register(CP0_STATUS);		
80000af0:	40036000 	mfc0	v1,c0_status
	res &= ~clear;						
	write_32bit_cp0_register(CP0_STATUS, res);		
80000af4:	3c02ffbf 	lui	v0,0xffbf
80000af8:	3442ffff 	ori	v0,v0,0xffff
80000afc:	00621024 	and	v0,v1,v0
80000b00:	40826000 	mtc0	v0,c0_status
80000b04:	00000040 	ssnop
80000b08:	00000040 	ssnop
80000b0c:	00000040 	ssnop
80000b10:	00000040 	ssnop
80000b14:	000000c0 	ehb
	SPECIAL_EHB();	
80000b18:	00008021 	move	s0,zero

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
		set_except_vector(i, do_reserved);
80000b1c:	3c118000 	lui	s1,0x8000
80000b20:	26310c30 	addiu	s1,s1,3120
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
80000b24:	24120020 	li	s2,32
		set_except_vector(i, do_reserved);
80000b28:	02002021 	move	a0,s0
80000b2c:	0c000293 	jal	80000a4c <set_except_vector>
80000b30:	02202821 	move	a1,s1
	extern char exception_matrix;

	unsigned long i;
	clear_cp0_status(ST0_BEV);

	for (i = 0; i <= 31; i++)
80000b34:	26100001 	addiu	s0,s0,1
80000b38:	1612fffc 	bne	s0,s2,80000b2c <init_exception+0x50>
80000b3c:	02002021 	move	a0,s0
#ifdef CONFIG_NAND_FLASH_BOOTING
	ebase_reg = 0xa0000000;
	write_c0_ebase(ebase_reg);
    memcpy((void *)(KSEG1 + 0x180), &exception_matrix, 0x80);
#else
    memcpy((void *)(KSEG0 + 0x180), &exception_matrix, 0x80);
80000b40:	3c038000 	lui	v1,0x8000
80000b44:	24630600 	addiu	v1,v1,1536
80000b48:	3c028000 	lui	v0,0x8000
80000b4c:	34420180 	ori	v0,v0,0x180
80000b50:	24680080 	addiu	t0,v1,128
80000b54:	88670000 	lwl	a3,0(v1)
80000b58:	98670003 	lwr	a3,3(v1)
80000b5c:	88660004 	lwl	a2,4(v1)
80000b60:	98660007 	lwr	a2,7(v1)
80000b64:	88650008 	lwl	a1,8(v1)
80000b68:	9865000b 	lwr	a1,11(v1)
80000b6c:	8864000c 	lwl	a0,12(v1)
80000b70:	9864000f 	lwr	a0,15(v1)
80000b74:	a8470000 	swl	a3,0(v0)
80000b78:	b8470003 	swr	a3,3(v0)
80000b7c:	a8460004 	swl	a2,4(v0)
80000b80:	b8460007 	swr	a2,7(v0)
80000b84:	a8450008 	swl	a1,8(v0)
80000b88:	b845000b 	swr	a1,11(v0)
80000b8c:	a844000c 	swl	a0,12(v0)
80000b90:	b844000f 	swr	a0,15(v0)
80000b94:	24630010 	addiu	v1,v1,16
80000b98:	1468ffee 	bne	v1,t0,80000b54 <init_exception+0x78>
80000b9c:	24420010 	addiu	v0,v0,16
#endif
    flush_cache();
80000ba0:	0c00187c 	jal	800061f0 <flush_cache>
80000ba4:	00000000 	nop
}
80000ba8:	8fbf001c 	lw	ra,28(sp)
80000bac:	8fb20018 	lw	s2,24(sp)
80000bb0:	8fb10014 	lw	s1,20(sp)
80000bb4:	8fb00010 	lw	s0,16(sp)
80000bb8:	03e00008 	jr	ra
80000bbc:	27bd0020 	addiu	sp,sp,32

80000bc0 <initInterrupt>:

//============================================================================

// init interrupt 
void initInterrupt(void)
{
80000bc0:	27bdffe8 	addiu	sp,sp,-24
80000bc4:	afbf0014 	sw	ra,20(sp)
	//printf("=>init interrupt...\n");
	REG32(GIMR_REG)=0x00;/*mask all interrupt*/
80000bc8:	3c02b800 	lui	v0,0xb800
80000bcc:	34433000 	ori	v1,v0,0x3000
80000bd0:	ac600000 	sw	zero,0(v1)
	
		REG32(0xb8003114)=0;  //disable timer interrupt
80000bd4:	34433114 	ori	v1,v0,0x3114
80000bd8:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
80000bdc:	34420010 	ori	v0,v0,0x10
80000be0:	8c440000 	lw	a0,0(v0)
80000be4:	2403f7ff 	li	v1,-2049
80000be8:	00831824 	and	v1,a0,v1
80000bec:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
80000bf0:	3c03bbdc 	lui	v1,0xbbdc
80000bf4:	34640300 	ori	a0,v1,0x300
80000bf8:	2402ffff 	li	v0,-1
80000bfc:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
80000c00:	34630304 	ori	v1,v1,0x304
	
   /*setup the BEV0,and IRQ */
	init_exception();/*Copy handler to 0x80000080*/
80000c04:	0c0002b7 	jal	80000adc <init_exception>
80000c08:	ac620000 	sw	v0,0(v1)
	init_IRQ();      /*Allocate IRQfinder to Exception 0*/
80000c0c:	0c000299 	jal	80000a64 <init_IRQ>
80000c10:	00000000 	nop


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
80000c14:	40016000 	mfc0	at,c0_status
80000c18:	34210001 	ori	at,at,0x1
80000c1c:	40816000 	mtc0	at,c0_status
80000c20:	000000c0 	ehb
	sti();
}
80000c24:	8fbf0014 	lw	ra,20(sp)
80000c28:	03e00008 	jr	ra
80000c2c:	27bd0018 	addiu	sp,sp,24

80000c30 <do_reserved>:
	exception_handlers[n] = handler;
}
//------------------------------------------------------------------------------

void do_reserved(struct pt_regs *regs)
{
80000c30:	27bdffe8 	addiu	sp,sp,-24
80000c34:	afbf0014 	sw	ra,20(sp)
	/*fatal hard/software error*/
	int i;
	prom_printf("Undefined Exception happen.");	
80000c38:	3c048001 	lui	a0,0x8001
80000c3c:	0c001d43 	jal	8000750c <prom_printf>
80000c40:	24840018 	addiu	a0,a0,24
80000c44:	08000311 	j	80000c44 <do_reserved+0x14>
80000c48:	00000000 	nop

80000c4c <do_IRQ>:
}

//------------------------------------------------------------------------------

void do_IRQ(int irqnr)
{
80000c4c:	27bdffe8 	addiu	sp,sp,-24
80000c50:	afbf0014 	sw	ra,20(sp)
    struct irqaction *action;
	unsigned long i;

	//printf("Got irq %d\n", irqnr);
	
    action = *(irqnr + irq_action);
80000c54:	00041880 	sll	v1,a0,0x2
80000c58:	3c028001 	lui	v0,0x8001
80000c5c:	244231f4 	addiu	v0,v0,12788
80000c60:	00431021 	addu	v0,v0,v1
80000c64:	8c430000 	lw	v1,0(v0)
        	
	if (action) 
80000c68:	10600008 	beqz	v1,80000c8c <do_IRQ+0x40>
80000c6c:	00802821 	move	a1,a0
    {
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
80000c70:	8c620000 	lw	v0,0(v1)
80000c74:	8c650010 	lw	a1,16(v1)
80000c78:	0040f809 	jalr	v0
80000c7c:	00003021 	move	a2,zero
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
		for(;;);
	}			
}	
80000c80:	8fbf0014 	lw	ra,20(sp)
80000c84:	03e00008 	jr	ra
80000c88:	27bd0018 	addiu	sp,sp,24
    	//printf("Do ISR=%x\n", action->handler);
	    action->handler(irqnr, action->dev_id, NULL);
    }
	else
	{    
		prom_printf("Fail, you got irq=%X, but not have ISR\n", irqnr);
80000c8c:	3c048001 	lui	a0,0x8001
80000c90:	0c001d43 	jal	8000750c <prom_printf>
80000c94:	24840034 	addiu	a0,a0,52
80000c98:	08000326 	j	80000c98 <do_IRQ+0x4c>
80000c9c:	00000000 	nop

80000ca0 <irq_dispatch>:

extern  void do_IRQ(int irq);
//------------------------------------------------------------------------------

void irq_dispatch(int irq_nr, int irq_nr2)
{
80000ca0:	27bdffd0 	addiu	sp,sp,-48
80000ca4:	afbf002c 	sw	ra,44(sp)
80000ca8:	afb50028 	sw	s5,40(sp)
80000cac:	afb40024 	sw	s4,36(sp)
80000cb0:	afb30020 	sw	s3,32(sp)
80000cb4:	afb2001c 	sw	s2,28(sp)
80000cb8:	afb10018 	sw	s1,24(sp)
80000cbc:	afb00014 	sw	s0,20(sp)
80000cc0:	00808821 	move	s1,a0
80000cc4:	00a09021 	move	s2,a1
80000cc8:	00008021 	move	s0,zero
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
80000ccc:	24130020 	li	s3,32
    {
        if (irq_nr & 0x01)
80000cd0:	32220001 	andi	v0,s1,0x1
80000cd4:	10400003 	beqz	v0,80000ce4 <irq_dispatch+0x44>
80000cd8:	00000000 	nop
		{
			//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
80000cdc:	0c000313 	jal	80000c4c <do_IRQ>
80000ce0:	02002021 	move	a0,s0

		}  
        irq++;
80000ce4:	26100001 	addiu	s0,s0,1
{
	int i,irq=0;
	//prom_printf("irq.c : irq_nr=%x  irq_nr2=%x  \n",irq_nr, irq_nr2);
	
	//Low 32bit
    for (i=0; i<=31; i++)
80000ce8:	1613fff9 	bne	s0,s3,80000cd0 <irq_dispatch+0x30>
80000cec:	00118843 	sra	s1,s1,0x1
	//High 32bit
    for (i=0; i<=31; i++)
    {
        if (irq_nr2 & 0x01)
		{
			if(irq==43)
80000cf0:	2413002b 	li	s3,43
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
80000cf4:	3c14bbdc 	lui	s4,0xbbdc
80000cf8:	36942560 	ori	s4,s4,0x2560
80000cfc:	24150002 	li	s5,2
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
80000d00:	2411003f 	li	s1,63
    {
        if (irq_nr2 & 0x01)
80000d04:	32420001 	andi	v0,s2,0x1
80000d08:	10400008 	beqz	v0,80000d2c <irq_dispatch+0x8c>
80000d0c:	00000000 	nop
		{
			if(irq==43)
80000d10:	16130004 	bne	s0,s3,80000d24 <irq_dispatch+0x84>
80000d14:	00000000 	nop
   			{
    				if(REG32(0xbbdc2560)==2)   //for core 1, not process.
80000d18:	8e820000 	lw	v0,0(s4)
80000d1c:	10550008 	beq	v0,s5,80000d40 <irq_dispatch+0xa0>
80000d20:	8fbf002c 	lw	ra,44(sp)
     				return;
   			}		
	
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);
80000d24:	0c000313 	jal	80000c4c <do_IRQ>
80000d28:	02002021 	move	a0,s0
        irq++;
        irq_nr = irq_nr >> 1;
    }

	//High 32bit
    for (i=0; i<=31; i++)
80000d2c:	12110003 	beq	s0,s1,80000d3c <irq_dispatch+0x9c>
80000d30:	26100001 	addiu	s0,s0,1
					//prom_printf("do irq=%x\n",irq);
			do_IRQ(irq);

		}  
        irq++;
        irq_nr2 = irq_nr2 >> 1;
80000d34:	08000341 	j	80000d04 <irq_dispatch+0x64>
80000d38:	00129043 	sra	s2,s2,0x1
    }
}
80000d3c:	8fbf002c 	lw	ra,44(sp)
80000d40:	8fb50028 	lw	s5,40(sp)
80000d44:	8fb40024 	lw	s4,36(sp)
80000d48:	8fb30020 	lw	s3,32(sp)
80000d4c:	8fb2001c 	lw	s2,28(sp)
80000d50:	8fb10018 	lw	s1,24(sp)
80000d54:	8fb00014 	lw	s0,20(sp)
80000d58:	03e00008 	jr	ra
80000d5c:	27bd0030 	addiu	sp,sp,48

80000d60 <errorTFTP>:
/*error in boot state machine*/	
}
//----------------------------------------------------------------------------------------
static void errorTFTP(void)
{
    if (!tftpd_is_ready)
80000d60:	3c028001 	lui	v0,0x8001
80000d64:	8c423304 	lw	v0,13060(v0)
80000d68:	10400002 	beqz	v0,80000d74 <errorTFTP+0x14>
80000d6c:	3c028001 	lui	v0,0x8001
		dprintf("[errcode from TFTP server:] %d\n",errcode);
		dprintf("[errmsg from TFTP server:] %s\n",errmsg);
		tftp_client_recvdone = 1;
	}
#endif
bootState=BOOT_STATE0_INIT_ARP;
80000d70:	ac4031a4 	sw	zero,12708(v0)
80000d74:	03e00008 	jr	ra
80000d78:	00000000 	nop

80000d7c <updateARPTable>:
			//dprintf("--send rrq to TFTP server--, [filename:] %s, image_address = 0x%x\n",TEST_FILENAME,image_address);
		}
	 }
 }
#endif 
}
80000d7c:	03e00008 	jr	ra
80000d80:	00000000 	nop

80000d84 <Patch_TFTP_SDR_2M>:
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
80000d84:	3c02b800 	lui	v0,0xb800
80000d88:	34420008 	ori	v0,v0,0x8
80000d8c:	8c420000 	lw	v0,0(v0)

	unsigned char boot_sel=GET_BITVAL(v, 0, RANG3);
	unsigned char dramtype_sel=GET_BITVAL(v, 4, RANG1);

	
	if( (boot_sel==0x7) && (dramtype_sel==0) )   //ROM4, SDR type =2M
80000d90:	30440007 	andi	a0,v0,0x7
80000d94:	24030007 	li	v1,7
80000d98:	14830005 	bne	a0,v1,80000db0 <Patch_TFTP_SDR_2M+0x2c>
80000d9c:	7c420100 	ext	v0,v0,0x4,0x1
80000da0:	14400003 	bnez	v0,80000db0 <Patch_TFTP_SDR_2M+0x2c>
80000da4:	3c038018 	lui	v1,0x8018
		image_address=0x80180000;
80000da8:	3c028001 	lui	v0,0x8001
80000dac:	ac432708 	sw	v1,9992(v0)
80000db0:	03e00008 	jr	ra
80000db4:	00000000 	nop

80000db8 <tftpd_entry>:
#ifdef SUPPORT_TFTP_CLIENT
void tftpd_entry(int is_client_mode)
#else
void tftpd_entry(void)
#endif
{
80000db8:	27bdffe8 	addiu	sp,sp,-24
80000dbc:	afbf0014 	sw	ra,20(sp)
 int i,j;
 
#if 1 //ROM code need
		Patch_TFTP_SDR_2M();
80000dc0:	0c000361 	jal	80000d84 <Patch_TFTP_SDR_2M>
80000dc4:	00000000 	nop
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = *ptr2;	
else
	arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,97);

#else
arptable_tftp[TFTP_SERVER].ipaddr.s_addr = IPTOUL(192,168,1,6);
80000dc8:	3c028001 	lui	v0,0x8001
80000dcc:	3c03c0a8 	lui	v1,0xc0a8
80000dd0:	34630106 	ori	v1,v1,0x106
80000dd4:	ac4343f0 	sw	v1,17392(v0)
#endif

arptable_tftp[TFTP_CLIENT].ipaddr.s_addr = IPTOUL(192,162,1,116);
80000dd8:	244243f0 	addiu	v0,v0,17392
80000ddc:	3c03c0a2 	lui	v1,0xc0a2
80000de0:	34630174 	ori	v1,v1,0x174
80000de4:	ac43000c 	sw	v1,12(v0)
 /*This is ETH0. we treat ETH0 as the TFTP server*/
 /*char eth0_mac[6]={0x56, 0xaa, 0xa5, 0x5a, 0x7d, 0xe8};*/
arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
80000de8:	3c048001 	lui	a0,0x8001
80000dec:	248329e0 	addiu	v1,a0,10720
80000df0:	90650005 	lbu	a1,5(v1)
80000df4:	a0450009 	sb	a1,9(v0)
arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
80000df8:	90650004 	lbu	a1,4(v1)
80000dfc:	a0450008 	sb	a1,8(v0)
arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
80000e00:	90650003 	lbu	a1,3(v1)
80000e04:	a0450007 	sb	a1,7(v0)
arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
80000e08:	90650002 	lbu	a1,2(v1)
80000e0c:	a0450006 	sb	a1,6(v0)
arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
80000e10:	90630001 	lbu	v1,1(v1)
80000e14:	a0430005 	sb	v1,5(v0)
arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
80000e18:	908329e0 	lbu	v1,10720(a0)
80000e1c:	a0430004 	sb	v1,4(v0)
//arptable_tftp[TFTP_SERVER].node[1]=0xaa;
//arptable_tftp[TFTP_SERVER].node[0]=0x56;


 /*intialize boot state*/	
 bootState=BOOT_STATE0_INIT_ARP;
80000e20:	3c028001 	lui	v0,0x8001
80000e24:	ac4031a4 	sw	zero,12708(v0)
 /*this nic is the expected data structure to be processed.*/
 nic.packet=eth_packet;
80000e28:	3c028001 	lui	v0,0x8001
80000e2c:	3c038001 	lui	v1,0x8001
80000e30:	24634414 	addiu	v1,v1,17428
80000e34:	ac433198 	sw	v1,12696(v0)
 nic.packetlen=0;
80000e38:	24423198 	addiu	v0,v0,12696
80000e3c:	ac400004 	sw	zero,4(v0)

 block_expected=0;
80000e40:	3c028001 	lui	v0,0x8001
80000e44:	a4403194 	sh	zero,12692(v0)
 one_tftp_lock=0;
80000e48:	3c028001 	lui	v0,0x8001
80000e4c:	a040330c 	sb	zero,13068(v0)
 it_is_EOF=0;
80000e50:	3c028001 	lui	v0,0x8001
80000e54:	ac403310 	sw	zero,13072(v0)

//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug

 
 //image_address=FILESTART; //sc_yang
 address_to_store=image_address;
80000e58:	3c028001 	lui	v0,0x8001
80000e5c:	8c432708 	lw	v1,9992(v0)
80000e60:	3c028001 	lui	v0,0x8001
80000e64:	ac433190 	sw	v1,12688(v0)
 
 file_length_to_server=0;
80000e68:	3c028001 	lui	v0,0x8001
80000e6c:	ac4031b0 	sw	zero,12720(v0)
 file_length_to_client=0;
80000e70:	3c028001 	lui	v0,0x8001
80000e74:	ac4031a8 	sw	zero,12712(v0)
#ifdef SUPPORT_TFTP_CLIENT
 if (is_client_mode)
	 SERVER_port=69; 	
 else
#endif 	
 SERVER_port=2098;
80000e78:	24030832 	li	v1,2098
80000e7c:	3c028001 	lui	v0,0x8001
80000e80:	a44331a0 	sh	v1,12704(v0)

#ifndef CONFIG_FPGA_PLATFORM
    tftpd_is_ready = 1;
80000e84:	24030001 	li	v1,1
80000e88:	3c028001 	lui	v0,0x8001
80000e8c:	ac433304 	sw	v1,13060(v0)
	tftp_client_enabled = 1;	
 }
 else	
	tftp_client_enabled = 0;
#endif
}
80000e90:	8fbf0014 	lw	ra,20(sp)
80000e94:	03e00008 	jr	ra
80000e98:	27bd0018 	addiu	sp,sp,24

80000e9c <ipheader_chksum>:
            break;/*ptype=IP*/ 
    }
}
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
80000e9c:	00052843 	sra	a1,a1,0x1
80000ea0:	00001021 	move	v0,zero
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
  if (sum > 0xFFFF)
80000ea4:	3c080001 	lui	t0,0x1
  sum -= 0xFFFF;
80000ea8:	3c07ffff 	lui	a3,0xffff
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
80000eac:	080003b4 	j	80000ed0 <ipheader_chksum+0x34>
80000eb0:	34e70001 	ori	a3,a3,0x1
 {
  sum += *(ip++);
80000eb4:	94830000 	lhu	v1,0(a0)
80000eb8:	00431021 	addu	v0,v0,v1
  if (sum > 0xFFFF)
80000ebc:	0048302b 	sltu	a2,v0,t0
  sum -= 0xFFFF;
80000ec0:	00471821 	addu	v1,v0,a3
80000ec4:	0066100a 	movz	v0,v1,a2
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
 {
  sum += *(ip++);
80000ec8:	24840002 	addiu	a0,a0,2
80000ecc:	24a5ffff 	addiu	a1,a1,-1
//----------------------------------------------------------------------------------------
Int16 ipheader_chksum(Int16*ip,int len)
{
 Int32 sum = 0;
 len >>= 1;
 while (len--)
80000ed0:	14a0fff8 	bnez	a1,80000eb4 <ipheader_chksum+0x18>
80000ed4:	00000000 	nop
80000ed8:	00021027 	nor	v0,zero,v0
  sum += *(ip++);
  if (sum > 0xFFFF)
  sum -= 0xFFFF;
 }                           /*Correct return 0*/
 return((~sum) & 0x0000FFFF);/*only 2 bytes*/
}
80000edc:	03e00008 	jr	ra
80000ee0:	3042ffff 	andi	v0,v0,0xffff

80000ee4 <kick_tftpd>:
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
}
               
//----------------------------------------------------------------------------------------
void kick_tftpd(void)
{
80000ee4:	27bdffe8 	addiu	sp,sp,-24
80000ee8:	afbf0014 	sw	ra,20(sp)
80000eec:	afb00010 	sw	s0,16(sp)
    BootEvent_t  kick_event=NUM_OF_BOOT_EVENTS;
      
    Int32 UDPIPETHheader = ETH_HLEN + sizeof(struct iphdr)  + sizeof(struct udphdr);		 
    
    
    if (nic.packetlen >= ETH_HLEN+sizeof(struct arprequest)) {
80000ef0:	3c028001 	lui	v0,0x8001
80000ef4:	8c42319c 	lw	v0,12700(v0)
80000ef8:	2c43002a 	sltiu	v1,v0,42
80000efc:	1460008d 	bnez	v1,80001134 <kick_tftpd+0x250>
80000f00:	3c038001 	lui	v1,0x8001
    	 pkttype =( (Int16)(nic.packet[12]<< 8)  |(Int16)(nic.packet[13])   );   /*This BIG byte shifts right 8*/             
80000f04:	8c703198 	lw	s0,12696(v1)
    } 

    switch (pkttype) {
80000f08:	8203000c 	lb	v1,12(s0)
80000f0c:	8204000d 	lb	a0,13(s0)
80000f10:	00031a00 	sll	v1,v1,0x8
80000f14:	00641825 	or	v1,v1,a0
80000f18:	3063ffff 	andi	v1,v1,0xffff
80000f1c:	24040800 	li	a0,2048
80000f20:	10640015 	beq	v1,a0,80000f78 <kick_tftpd+0x94>
80000f24:	2c42002b 	sltiu	v0,v0,43
80000f28:	24020806 	li	v0,2054
80000f2c:	14620081 	bne	v1,v0,80001134 <kick_tftpd+0x250>
80000f30:	2610000e 	addiu	s0,s0,14
			/*keep parsing, check the opcode is request or reply*/
			arppacket = (struct arprequest *)&nic.packet[ETH_HLEN];
			/*Parse the opcode, 01->req, 02 ->reply*/ 	
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
80000f34:	96020006 	lhu	v0,6(s0)
80000f38:	24030001 	li	v1,1
80000f3c:	10430005 	beq	v0,v1,80000f54 <kick_tftpd+0x70>
80000f40:	24030002 	li	v1,2
80000f44:	1443007b 	bne	v0,v1,80001134 <kick_tftpd+0x250>
80000f48:	24030001 	li	v1,1
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
80000f4c:	08000435 	j	800010d4 <kick_tftpd+0x1f0>
80000f50:	3c028001 	lui	v0,0x8001
			arpopcode = arppacket->opcode;
						  
            switch(arpopcode) {
                case htons(ARP_REQUEST):     														
				    // check dst ip, david+2007-12-26											
                    if (!memcmp(arppacket->tipaddr, &arptable_tftp[TFTP_SERVER].ipaddr, 4)
80000f54:	26040018 	addiu	a0,s0,24
80000f58:	3c058001 	lui	a1,0x8001
80000f5c:	24a543f0 	addiu	a1,a1,17392
80000f60:	0c0019ed 	jal	800067b4 <memcmp>
80000f64:	24060004 	li	a2,4
80000f68:	10400059 	beqz	v0,800010d0 <kick_tftpd+0x1ec>
80000f6c:	00001821 	move	v1,zero
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80000f70:	0800044e 	j	80001138 <kick_tftpd+0x254>
80000f74:	8fbf0014 	lw	ra,20(sp)
            break;/*ptype=ARP*/

        //--------------------------------------------------------------------------	
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
80000f78:	2610000e 	addiu	s0,s0,14
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
80000f7c:	92060010 	lbu	a2,16(s0)
            ip_addr.ip[1] = ipheader->dest.ip[1];
80000f80:	92050011 	lbu	a1,17(s0)
            ip_addr.ip[2] = ipheader->dest.ip[2];
80000f84:	92040012 	lbu	a0,18(s0)
            //source_ip_addr.ip[1] = ipheader->src.ip[1];
            //source_ip_addr.ip[2] = ipheader->src.ip[2];
            //source_ip_addr.ip[3] = ipheader->src.ip[3];
            //Cyrus Dick
            /*Even type is IP, but the total payload must at least UDPH+IPH*/
            if (nic.packetlen > UDPIPETHheader) {
80000f88:	1440006a 	bnez	v0,80001134 <kick_tftpd+0x250>
80000f8c:	92030013 	lbu	v1,19(s0)
                /*keep parsing, check the TCP/UDP, here is meaningful*/
                if (ipheader->verhdrlen==0x45) {
80000f90:	82070000 	lb	a3,0(s0)
80000f94:	24020045 	li	v0,69
80000f98:	14e20067 	bne	a3,v0,80001138 <kick_tftpd+0x254>
80000f9c:	8fbf0014 	lw	ra,20(sp)
        case htons(FRAME_IP):
            //dprintf("rx ip packet\n");	//wei add
            ipheader = (struct iphdr *)&nic.packet[ETH_HLEN];
            // word alignment
            //Cyrus Dick
            ip_addr.ip[0] = ipheader->dest.ip[0];
80000fa0:	00001021 	move	v0,zero
80000fa4:	7cc2fe04 	ins	v0,a2,0x18,0x8
            ip_addr.ip[1] = ipheader->dest.ip[1];
80000fa8:	7ca2bc04 	ins	v0,a1,0x10,0x8
            ip_addr.ip[2] = ipheader->dest.ip[2];
80000fac:	7c827a04 	ins	v0,a0,0x8,0x8
            ip_addr.ip[3] = ipheader->dest.ip[3];
80000fb0:	7c623804 	ins	v0,v1,0x0,0x8
                        || ip_addr.s_addr  == arptable_tftp[HTTPD_ARPENTRY].ipaddr.s_addr 
#endif
                        ) {					

#else					
                    if (ip_addr.s_addr==arptable_tftp[TFTP_SERVER].ipaddr.s_addr 
80000fb4:	3c038001 	lui	v1,0x8001
80000fb8:	8c6343f0 	lw	v1,17392(v1)
80000fbc:	1443005e 	bne	v0,v1,80001138 <kick_tftpd+0x254>
80000fc0:	02002021 	move	a0,s0
#endif
                        ) {
#endif                        
                        //if(source_ip_addr.s_addr==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)
                        //Cyrus Dick
                        if (!ipheader_chksum((Int16*)ipheader,sizeof(struct iphdr))) {
80000fc4:	0c0003a7 	jal	80000e9c <ipheader_chksum>
80000fc8:	24050014 	li	a1,20
80000fcc:	14400059 	bnez	v0,80001134 <kick_tftpd+0x250>
80000fd0:	24020011 	li	v0,17
                            if (ipheader->protocol==IP_UDP) {                                                 
80000fd4:	82030009 	lb	v1,9(s0)
80000fd8:	14620057 	bne	v1,v0,80001138 <kick_tftpd+0x254>
80000fdc:	8fbf0014 	lw	ra,20(sp)
                                }
#endif
                                /*All we care is TFTP protocol, no other  protocol*/
                                tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
                                tftpopcode  = tftppacket->opcode;      
                                switch (tftpopcode) {
80000fe0:	3c028001 	lui	v0,0x8001
80000fe4:	8c423198 	lw	v0,12696(v0)
80000fe8:	9443002a 	lhu	v1,42(v0)
80000fec:	2c630007 	sltiu	v1,v1,7
80000ff0:	10600051 	beqz	v1,80001138 <kick_tftpd+0x254>
80000ff4:	00000000 	nop
80000ff8:	9443002a 	lhu	v1,42(v0)
80000ffc:	00031880 	sll	v1,v1,0x2
80001000:	3c028001 	lui	v0,0x8001
80001004:	2442e1e0 	addiu	v0,v0,-7712
80001008:	00431021 	addu	v0,v0,v1
8000100c:	8c420000 	lw	v0,0(v0)
80001010:	00400008 	jr	v0
80001014:	00000000 	nop
80001018:	08000442 	j	80001108 <kick_tftpd+0x224>
8000101c:	24020006 	li	v0,6
                                    case htons(TFTP_RRQ):
                                        if (one_tftp_lock==0)
80001020:	3c028001 	lui	v0,0x8001
80001024:	9043330c 	lbu	v1,13068(v0)
80001028:	10600037 	beqz	v1,80001108 <kick_tftpd+0x224>
8000102c:	24020002 	li	v0,2
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80001030:	0800044e 	j	80001138 <kick_tftpd+0x254>
80001034:	8fbf0014 	lw	ra,20(sp)
                                        if (one_tftp_lock==0)
                                            kick_event= BOOT_EVENT2_TFTP_RRQ;                 
                                        break;                     
                                    case htons(TFTP_WRQ):
#if 1
                                        if (one_tftp_lock==0) {
80001038:	3c028001 	lui	v0,0x8001
8000103c:	9042330c 	lbu	v0,13068(v0)
80001040:	14400007 	bnez	v0,80001060 <kick_tftpd+0x17c>
80001044:	00000000 	nop
                                            kick_event = BOOT_EVENT3_TFTP_WRQ; 
                                            rx_kickofftime = get_timer_jiffies(); //wei add
80001048:	0c00325c 	jal	8000c970 <get_timer_jiffies>
8000104c:	00000000 	nop
80001050:	3c038001 	lui	v1,0x8001
80001054:	ac623308 	sw	v0,13064(v1)
80001058:	08000442 	j	80001108 <kick_tftpd+0x224>
8000105c:	24020003 	li	v0,3
                                        }
                                        else {
                                           // prom_printf("TFTP_WRQ: one_tftp_lock=%d block_expected=%d\n",one_tftp_lock, block_expected);
                                            //fix TFTP WRQ retransmit issue and add timout mechanism for second TFTP WRQ coming issue
                                            if ((block_expected == 1) || ((get_timer_jiffies() - rx_kickofftime) > 2000)) { //wait 20sec, unit is 10ms
80001060:	3c028001 	lui	v0,0x8001
80001064:	94433194 	lhu	v1,12692(v0)
80001068:	3063ffff 	andi	v1,v1,0xffff
8000106c:	24020001 	li	v0,1
80001070:	10620009 	beq	v1,v0,80001098 <kick_tftpd+0x1b4>
80001074:	00000000 	nop
80001078:	0c00325c 	jal	8000c970 <get_timer_jiffies>
8000107c:	00000000 	nop
80001080:	3c038001 	lui	v1,0x8001
80001084:	8c633308 	lw	v1,13064(v1)
80001088:	00431823 	subu	v1,v0,v1
8000108c:	2c6307d1 	sltiu	v1,v1,2001
80001090:	14600029 	bnez	v1,80001138 <kick_tftpd+0x254>
80001094:	8fbf0014 	lw	ra,20(sp)
                                                kick_event = BOOT_EVENT3_TFTP_WRQ;
                                                rx_kickofftime = get_timer_jiffies();
80001098:	0c00325c 	jal	8000c970 <get_timer_jiffies>
8000109c:	00000000 	nop
800010a0:	3c038001 	lui	v1,0x8001
800010a4:	ac623308 	sw	v0,13064(v1)
800010a8:	08000442 	j	80001108 <kick_tftpd+0x224>
800010ac:	24020003 	li	v0,3
#endif
                                        //setTFTP_WRQ();
                                        break;
                                    case htons(TFTP_DATA):
                                        kick_event= BOOT_EVENT4_TFTP_DATA;
                                        rx_kickofftime = get_timer_jiffies();
800010b0:	0c00325c 	jal	8000c970 <get_timer_jiffies>
800010b4:	00000000 	nop
800010b8:	3c038001 	lui	v1,0x8001
800010bc:	ac623308 	sw	v0,13064(v1)
                                        //	prepareACK();
                                        break;
800010c0:	08000442 	j	80001108 <kick_tftpd+0x224>
800010c4:	24020004 	li	v0,4
800010c8:	08000442 	j	80001108 <kick_tftpd+0x224>
800010cc:	24020007 	li	v0,7
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
800010d0:	3c028001 	lui	v0,0x8001
800010d4:	8c4231a4 	lw	v0,12708(v0)
800010d8:	000210c0 	sll	v0,v0,0x3
800010dc:	00431821 	addu	v1,v0,v1
800010e0:	00031880 	sll	v1,v1,0x2
800010e4:	3c028001 	lui	v0,0x8001
800010e8:	2442e1fc 	addiu	v0,v0,-7684
800010ec:	00621821 	addu	v1,v1,v0
800010f0:	8c620000 	lw	v0,0(v1)
800010f4:	0040f809 	jalr	v0
800010f8:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
800010fc:	0800044e 	j	80001138 <kick_tftpd+0x254>
80001100:	8fbf0014 	lw	ra,20(sp)
                    break;
            }
            //wei del
            if (kick_event!=NUM_OF_BOOT_EVENTS) {
                jump = (void *)(*BootStateEvent[bootState][kick_event]);
                jump();
80001104:	24020005 	li	v0,5
                                        break;
                                }
				
                                if (kick_event!=NUM_OF_BOOT_EVENTS) {
                                    jump = (void *)(*BootStateEvent[bootState][kick_event]);
                                    jump();
80001108:	3c038001 	lui	v1,0x8001
8000110c:	8c6331a4 	lw	v1,12708(v1)
80001110:	000318c0 	sll	v1,v1,0x3
80001114:	00621021 	addu	v0,v1,v0
80001118:	00021080 	sll	v0,v0,0x2
8000111c:	3c038001 	lui	v1,0x8001
80001120:	2463e1fc 	addiu	v1,v1,-7684
80001124:	00431021 	addu	v0,v0,v1
80001128:	8c420000 	lw	v0,0(v0)
8000112c:	0040f809 	jalr	v0
80001130:	00000000 	nop
                    }
                }
            }
            break;/*ptype=IP*/ 
    }
}
80001134:	8fbf0014 	lw	ra,20(sp)
80001138:	8fb00010 	lw	s0,16(sp)
8000113c:	03e00008 	jr	ra
80001140:	27bd0018 	addiu	sp,sp,24

80001144 <errorDrop>:
#endif // SUPPORT_TFTP_CLIENT


//----------------------------------------------------------------------------------------
static void errorDrop(void)
{
80001144:	27bdffe8 	addiu	sp,sp,-24
80001148:	afbf0014 	sw	ra,20(sp)
    if (!tftpd_is_ready)
8000114c:	3c028001 	lui	v0,0x8001
80001150:	8c423304 	lw	v0,13060(v0)
80001154:	10400009 	beqz	v0,8000117c <errorDrop+0x38>
80001158:	8fbf0014 	lw	ra,20(sp)
        return;
/*no need to change boot state*/
prom_printf("Boot state error,%d,%d\n",bootState,bootEvent);
8000115c:	3c048001 	lui	a0,0x8001
80001160:	2484005c 	addiu	a0,a0,92
80001164:	3c028001 	lui	v0,0x8001
80001168:	8c4531a4 	lw	a1,12708(v0)
8000116c:	3c028001 	lui	v0,0x8001
80001170:	0c001cc1 	jal	80007304 <dprintf>
80001174:	8c4631b4 	lw	a2,12724(v0)
//bootState=BOOT_STATE0_INIT_ARP;
/*error in boot state machine*/	
}
80001178:	8fbf0014 	lw	ra,20(sp)
8000117c:	03e00008 	jr	ra
80001180:	27bd0018 	addiu	sp,sp,24

80001184 <autoreboot>:
	return found;
}
#endif

void autoreboot()
{
80001184:	27bdffe8 	addiu	sp,sp,-24
80001188:	afbf0014 	sw	ra,20(sp)
        extern unsigned int ComSrlCmd_EX4B(unsigned char ucChip, unsigned int uiLen);
        ComSrlCmd_EX4B(0,4);

        #endif

	jumpF = (void *)(0xbfc00000);
8000118c:	3c03bfc0 	lui	v1,0xbfc0
80001190:	3c028001 	lui	v0,0x8001
80001194:	ac4331ac 	sw	v1,12716(v0)
__IN(unsigned short,h,w)
__IN(unsigned int,w,l)

__OUT(b,b)
__OUT(h,w)
__OUT(w,l)
80001198:	3c03b800 	lui	v1,0xb800
8000119c:	00001021 	move	v0,zero
800011a0:	ac623000 	sw	v0,12288(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
800011a4:	40016000 	mfc0	at,c0_status
800011a8:	34210001 	ori	at,at,0x1
800011ac:	38210001 	xori	at,at,0x1
800011b0:	40816000 	mtc0	at,c0_status
800011b4:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt	    
	cli();

	flush_cache(); 
800011c4:	0c00187c 	jal	800061f0 <flush_cache>
800011c8:	00000000 	nop
	prom_printf("\nreboot.......\n");
800011cc:	3c048001 	lui	a0,0x8001
800011d0:	0c001cc1 	jal	80007304 <dprintf>
800011d4:	24840074 	addiu	a0,a0,116
#if defined(RTL865X) || defined(RTL8198)
	/* this is to enable 865xc watch dog reset */
	*(volatile unsigned long *)(0xB800311c)=0; 
800011d8:	3c02b800 	lui	v0,0xb800
800011dc:	3442311c 	ori	v0,v0,0x311c
800011e0:	ac400000 	sw	zero,0(v0)
800011e4:	08000479 	j	800011e4 <autoreboot+0x60>
800011e8:	00000000 	nop

800011ec <doARPReply>:
	}
#endif
}
//----------------------------------------------------------------------------------------
static void doARPReply(void)
{
800011ec:	27bdffc0 	addiu	sp,sp,-64
800011f0:	afbf003c 	sw	ra,60(sp)
 Int8 checkIP[4];
 Int32 targetIP; 

//dprintf("execute ARP reply function\n");

 arppacket=(struct arprequest *) &(nic.packet[ETH_HLEN]);
800011f4:	3c028001 	lui	v0,0x8001
800011f8:	8c423198 	lw	v0,12696(v0)
800011fc:	2446000e 	addiu	a2,v0,14

//memcpy(arptable_tftp[TFTP_CLIENT].ipaddr.ip, arppacket->sipaddr, sizeof(in_addr)); 
 //prom_printf("DoARPRpy 2.:update CLIENT ip address %x\n",arptable_tftp[TFTP_CLIENT].ipaddr.s_addr);
 
 memcpy(&targetIP,arppacket->tipaddr,4);
80001200:	24420026 	addiu	v0,v0,38
80001204:	88430000 	lwl	v1,0(v0)
80001208:	98430003 	lwr	v1,3(v0)
8000120c:	00601021 	move	v0,v1
80001210:	afa30034 	sw	v1,52(sp)

#ifdef SUPPORT_TFTP_CLIENT
 if ((tftp_client_enabled && (targetIP==arptable_tftp[TFTP_CLIENT].ipaddr.s_addr)) ||  	
	  (!tftp_client_enabled && (targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)))
#else
 if(targetIP==arptable_tftp[TFTP_SERVER].ipaddr.s_addr)/*that is us*/
80001214:	3c038001 	lui	v1,0x8001
80001218:	8c6343f0 	lw	v1,17392(v1)
8000121c:	14620025 	bne	v1,v0,800012b4 <doARPReply+0xc8>
80001220:	8fbf003c 	lw	ra,60(sp)
#endif 	
 {
#if 1
    /*Fill in the arp reply payload.*/
    arpreply.hwtype = htons(1);
80001224:	24020001 	li	v0,1
80001228:	a7a20018 	sh	v0,24(sp)
    arpreply.protocol = htons(FRAME_IP);/*that is 0x0800*/
8000122c:	24020800 	li	v0,2048
80001230:	a7a2001a 	sh	v0,26(sp)
    arpreply.hwlen = ETH_ALEN;
80001234:	24020006 	li	v0,6
80001238:	a3a2001c 	sb	v0,28(sp)
    arpreply.protolen = 4;
8000123c:	24020004 	li	v0,4
80001240:	a3a2001d 	sb	v0,29(sp)
    arpreply.opcode = htons(ARP_REPLY);
80001244:	24020002 	li	v0,2
80001248:	a7a2001e 	sh	v0,30(sp)
	    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));		
	}
	else
#endif
	{
    memcpy(&(arpreply.shwaddr), &(arptable_tftp[TFTP_SERVER].node), ETH_ALEN);
8000124c:	3c028001 	lui	v0,0x8001
80001250:	244343f0 	addiu	v1,v0,17392
80001254:	8c640004 	lw	a0,4(v1)
80001258:	afa40020 	sw	a0,32(sp)
8000125c:	94630008 	lhu	v1,8(v1)
80001260:	a7a30024 	sh	v1,36(sp)
    memcpy(&(arpreply.sipaddr), &(arptable_tftp[TFTP_SERVER].ipaddr), sizeof(in_addr));
80001264:	8c4243f0 	lw	v0,17392(v0)
80001268:	aba20026 	swl	v0,38(sp)
8000126c:	bba20029 	swr	v0,41(sp)
	}		
    memcpy(&(arpreply.thwaddr), arppacket->shwaddr, ETH_ALEN);
80001270:	94c40008 	lhu	a0,8(a2)
80001274:	94c3000a 	lhu	v1,10(a2)
80001278:	94c2000c 	lhu	v0,12(a2)
8000127c:	a7a4002a 	sh	a0,42(sp)
80001280:	a7a3002c 	sh	v1,44(sp)
80001284:	a7a2002e 	sh	v0,46(sp)
    memcpy(&(arpreply.tipaddr), arppacket->sipaddr, sizeof(in_addr));
80001288:	88c2000e 	lwl	v0,14(a2)
8000128c:	98c20011 	lwr	v0,17(a2)
80001290:	afa20030 	sw	v0,48(sp)

    prepare_txpkt(0,FRAME_ARP,arppacket->shwaddr,(Int8*)&arpreply,(Int16)sizeof(arpreply));
80001294:	2402001c 	li	v0,28
80001298:	afa20010 	sw	v0,16(sp)
8000129c:	00002021 	move	a0,zero
800012a0:	24050806 	li	a1,2054
800012a4:	24c60008 	addiu	a2,a2,8
800012a8:	0c000824 	jal	80002090 <prepare_txpkt>
800012ac:	27a70018 	addiu	a3,sp,24
    memcpy(&(arpreply.tipaddr), &(arptable_tftp[TFTP_CLIENT].ipaddr), sizeof(in_addr));

    prepare_txpkt(0,FRAME_ARP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&arpreply,(Int16)sizeof(arpreply));
#endif
   } 
}
800012b0:	8fbf003c 	lw	ra,60(sp)
800012b4:	03e00008 	jr	ra
800012b8:	27bd0040 	addiu	sp,sp,64

800012bc <tftpd_send_data>:
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
}
//----------------------------------------------------------------------------------------
void tftpd_send_data(char* filename, Int16 block_number)
{
800012bc:	27bdfa20 	addiu	sp,sp,-1504
800012c0:	afbf05dc 	sw	ra,1500(sp)
800012c4:	afb205d8 	sw	s2,1496(sp)
800012c8:	afb105d4 	sw	s1,1492(sp)
800012cc:	afb005d0 	sw	s0,1488(sp)
800012d0:	30b0ffff 	andi	s0,a1,0xffff
 Int32* data; 
 int length;


 /********************************************/  
   data=(Int32 *)(image_address+ 512*(block_number-1));
800012d4:	02002821 	move	a1,s0
800012d8:	3c028001 	lui	v0,0x8001
   //prom_printf("send data start at %x\n",data);
 if (512* block_number==(file_length_to_client+512))
800012dc:	00102240 	sll	a0,s0,0x9
800012e0:	3c038001 	lui	v1,0x8001
800012e4:	8c6331a8 	lw	v1,12712(v1)
800012e8:	24660200 	addiu	a2,v1,512
800012ec:	14860006 	bne	a0,a2,80001308 <tftpd_send_data+0x4c>
800012f0:	8c422708 	lw	v0,9992(v0)
    {
    /*it is over that means a length=0 data is required*/
    length=0;
    //prom_printf("TFTP RRQ last NULL data to send\n");
    it_is_EOF=1;
800012f4:	24040001 	li	a0,1
800012f8:	3c038001 	lui	v1,0x8001
800012fc:	ac643310 	sw	a0,13072(v1)
80001300:	080004cb 	j	8000132c <tftpd_send_data+0x70>
80001304:	00008821 	move	s1,zero
    }
 else if( 512* block_number > file_length_to_client)
80001308:	0064202b 	sltu	a0,v1,a0
8000130c:	10800007 	beqz	a0,8000132c <tftpd_send_data+0x70>
80001310:	24110200 	li	s1,512
    { 
     length=file_length_to_client-512*(block_number-1);
80001314:	24040001 	li	a0,1
80001318:	00908823 	subu	s1,a0,s0
8000131c:	00118a40 	sll	s1,s1,0x9
80001320:	02238821 	addu	s1,s1,v1
     //prom_printf("TFTP RRQ last data to send\n");
     it_is_EOF=1;
80001324:	3c038001 	lui	v1,0x8001
80001328:	ac643310 	sw	a0,13072(v1)
 else
    length=512;
 
 /********************************************/
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_DATA);
8000132c:	24030003 	li	v1,3
80001330:	a7a30034 	sh	v1,52(sp)
 memcpy(tftp_tx.u.data.download,(Int8*)data,length);
80001334:	24a5ffff 	addiu	a1,a1,-1
80001338:	00052a40 	sll	a1,a1,0x9
8000133c:	27a40038 	addiu	a0,sp,56
80001340:	00a22821 	addu	a1,a1,v0
80001344:	0c0019e2 	jal	80006788 <memcpy>
80001348:	02203021 	move	a2,s1
 tftp_tx.u.data.block=htons(block_number);
8000134c:	a7b00036 	sh	s0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*generate the IP header*/
 ip->verhdrlen = 0x45;
80001350:	24020045 	li	v0,69
80001354:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
80001358:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32+length);
8000135c:	3231ffff 	andi	s1,s1,0xffff
80001360:	26300020 	addiu	s0,s1,32
80001364:	3210ffff 	andi	s0,s0,0xffff
80001368:	a7b0001a 	sh	s0,26(sp)
 ip->ident = 0;
8000136c:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
80001370:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
80001374:	2402003c 	li	v0,60
80001378:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
8000137c:	24020011 	li	v0,17
80001380:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
80001384:	a7a00022 	sh	zero,34(sp)
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
80001388:	3c028001 	lui	v0,0x8001
8000138c:	8c4343f0 	lw	v1,17392(v0)
80001390:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
80001394:	244243f0 	addiu	v0,v0,17392
80001398:	8c42000c 	lw	v0,12(v0)
8000139c:	afa20028 	sw	v0,40(sp)
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
800013a0:	27b20018 	addiu	s2,sp,24
800013a4:	02402021 	move	a0,s2
800013a8:	0c0003a7 	jal	80000e9c <ipheader_chksum>
800013ac:	24050014 	li	a1,20
800013b0:	a7a20022 	sh	v0,34(sp)
 /*generate the UDP header*/
 udp->src  = htons(SERVER_port);
800013b4:	3c028001 	lui	v0,0x8001
800013b8:	944231a0 	lhu	v0,12704(v0)
800013bc:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
800013c0:	3c028001 	lui	v0,0x8001
800013c4:	944231a2 	lhu	v0,12706(v0)
800013c8:	a7a2002e 	sh	v0,46(sp)
 udp->len  = htons(length+4+8);
800013cc:	2631000c 	addiu	s1,s1,12
800013d0:	a7b10030 	sh	s1,48(sp)
 udp->chksum = 0;
 
 /*use twiddle here*/
 twiddle();
800013d4:	0c001bf9 	jal	80006fe4 <twiddle>
800013d8:	a7a00032 	sh	zero,50(sp)
 //prom_printf(" -> ");
 
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+length+4);
800013dc:	afb00010 	sw	s0,16(sp)
800013e0:	00002021 	move	a0,zero
800013e4:	24050800 	li	a1,2048
800013e8:	3c068001 	lui	a2,0x8001
800013ec:	24c64400 	addiu	a2,a2,17408
800013f0:	0c000824 	jal	80002090 <prepare_txpkt>
800013f4:	02403821 	move	a3,s2
}
800013f8:	8fbf05dc 	lw	ra,1500(sp)
800013fc:	8fb205d8 	lw	s2,1496(sp)
80001400:	8fb105d4 	lw	s1,1492(sp)
80001404:	8fb005d0 	lw	s0,1488(sp)
80001408:	03e00008 	jr	ra
8000140c:	27bd05e0 	addiu	sp,sp,1504

80001410 <prepareDATA>:

}
//----------------------------------------------------------------------------------------
/*Why we prepare DATA, because we receive the ACK*/
static void prepareDATA(void)
{
80001410:	27bdffe8 	addiu	sp,sp,-24
80001414:	afbf0014 	sw	ra,20(sp)
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 Int16 block_received=0;

    if (!tftpd_is_ready)
80001418:	3c028001 	lui	v0,0x8001
8000141c:	8c423304 	lw	v0,13060(v0)
80001420:	10400043 	beqz	v0,80001530 <prepareDATA+0x120>
80001424:	3c028001 	lui	v0,0x8001
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
80001428:	8c423198 	lw	v0,12696(v0)
8000142c:	24430022 	addiu	v1,v0,34
 if(udpheader->dest==htons(SERVER_port))
80001430:	94650002 	lhu	a1,2(v1)
80001434:	3c048001 	lui	a0,0x8001
80001438:	948431a0 	lhu	a0,12704(a0)
8000143c:	14a4003d 	bne	a1,a0,80001534 <prepareDATA+0x124>
80001440:	8fbf0014 	lw	ra,20(sp)
   {
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
80001444:	94640000 	lhu	a0,0(v1)
80001448:	3c038001 	lui	v1,0x8001
8000144c:	a46431a2 	sh	a0,12706(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
    if(block_received != (block_expected))
80001450:	3c038001 	lui	v1,0x8001
80001454:	94633194 	lhu	v1,12692(v1)
80001458:	3063ffff 	andi	v1,v1,0xffff
    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    /*no need to check opcode, this is a ACK packet*/     
    /*parse the TFTP ACK number*/	
    block_received=tftppacket->u.ack.block;
8000145c:	9442002c 	lhu	v0,44(v0)
80001460:	1043000c 	beq	v0,v1,80001494 <prepareDATA+0x84>
80001464:	3c028001 	lui	v0,0x8001
    if(block_received != (block_expected))
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("\n**TFTP #\n");
80001468:	3c048001 	lui	a0,0x8001
8000146c:	0c001cc1 	jal	80007304 <dprintf>
80001470:	24840084 	addiu	a0,a0,132
     tftpd_send_data(filename,block_expected);
80001474:	3c028001 	lui	v0,0x8001
80001478:	94453194 	lhu	a1,12692(v0)
8000147c:	3c048001 	lui	a0,0x8001
80001480:	248441f0 	addiu	a0,a0,16880
80001484:	0c0004af 	jal	800012bc <tftpd_send_data>
80001488:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
8000148c:	0800054d 	j	80001534 <prepareDATA+0x124>
80001490:	8fbf0014 	lw	ra,20(sp)
     prom_printf("\n**TFTP #\n");
     tftpd_send_data(filename,block_expected);
    }
    else 
     {      
      block_expected=block_expected+1;      
80001494:	94433194 	lhu	v1,12692(v0)
80001498:	24630001 	addiu	v1,v1,1
8000149c:	3063ffff 	andi	v1,v1,0xffff
800014a0:	a4433194 	sh	v1,12692(v0)
      if(!(it_is_EOF))
800014a4:	3c028001 	lui	v0,0x8001
800014a8:	8c423310 	lw	v0,13072(v0)
800014ac:	14400009 	bnez	v0,800014d4 <prepareDATA+0xc4>
800014b0:	3c028001 	lui	v0,0x8001
          tftpd_send_data(filename,block_expected);     
800014b4:	3c028001 	lui	v0,0x8001
800014b8:	94453194 	lhu	a1,12692(v0)
800014bc:	3c048001 	lui	a0,0x8001
800014c0:	248441f0 	addiu	a0,a0,16880
800014c4:	0c0004af 	jal	800012bc <tftpd_send_data>
800014c8:	30a5ffff 	andi	a1,a1,0xffff
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
800014cc:	0800054d 	j	80001534 <prepareDATA+0x124>
800014d0:	8fbf0014 	lw	ra,20(sp)
      if(!(it_is_EOF))
          tftpd_send_data(filename,block_expected);     
      else 
         {
         /*After we receive the last ACK then we can go on.*/	
          bootState=BOOT_STATE0_INIT_ARP;  
800014d4:	ac4031a4 	sw	zero,12708(v0)
          one_tftp_lock=0; 
800014d8:	3c028001 	lui	v0,0x8001
800014dc:	a040330c 	sb	zero,13068(v0)
          //prom_printf("\n**TFTP Client Upload Success! File Size = %X Bytes\n",file_length_to_server);                        
          prom_printf("\n*TFTP Client Download Success! File Size = %X Bytes\n",file_length_to_client);          
800014e0:	3c048001 	lui	a0,0x8001
800014e4:	24840090 	addiu	a0,a0,144
800014e8:	3c028001 	lui	v0,0x8001
800014ec:	0c001cc1 	jal	80007304 <dprintf>
800014f0:	8c4531a8 	lw	a1,12712(v0)
          prom_printf( ".Success!\n%s", "<RealTek>" );         
800014f4:	3c048001 	lui	a0,0x8001
800014f8:	248400c8 	addiu	a0,a0,200
800014fc:	3c058001 	lui	a1,0x8001
80001500:	0c001cc1 	jal	80007304 <dprintf>
80001504:	24a500d8 	addiu	a1,a1,216
          nic.packet = eth_packet;
80001508:	3c028001 	lui	v0,0x8001
8000150c:	3c038001 	lui	v1,0x8001
80001510:	24634414 	addiu	v1,v1,17428
80001514:	ac433198 	sw	v1,12696(v0)
          nic.packetlen = 0;        
80001518:	24423198 	addiu	v0,v0,12696
8000151c:	ac400004 	sw	zero,4(v0)
          block_expected =0;       
80001520:	3c028001 	lui	v0,0x8001
80001524:	a4403194 	sh	zero,12692(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
          
          it_is_EOF=0;
80001528:	3c028001 	lui	v0,0x8001
8000152c:	ac403310 	sw	zero,13072(v0)
   }
//else 
//   prom_printf("\n**TFTP port number error\n");   
  

}                               
80001530:	8fbf0014 	lw	ra,20(sp)
80001534:	03e00008 	jr	ra
80001538:	27bd0018 	addiu	sp,sp,24

8000153c <setTFTP_RRQ>:
 }
#endif 
}
//----------------------------------------------------------------------------------------
static void setTFTP_RRQ(void)
{
8000153c:	27bdffe0 	addiu	sp,sp,-32
80001540:	afbf001c 	sw	ra,28(sp)
80001544:	afb10018 	sw	s1,24(sp)
80001548:	afb00014 	sw	s0,20(sp)
 struct tftp_t *tftppacket;
 
 Int16 tftpopcode;
 int find_zero;

    if (!tftpd_is_ready)
8000154c:	3c028001 	lui	v0,0x8001
80001550:	8c423304 	lw	v0,13060(v0)
80001554:	10400055 	beqz	v0,800016ac <setTFTP_RRQ+0x170>
80001558:	3c028001 	lui	v0,0x8001
        return;
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
8000155c:	8c503198 	lw	s0,12696(v0)
80001560:	26100022 	addiu	s0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
80001564:	96030002 	lhu	v1,2(s0)
80001568:	24020045 	li	v0,69
8000156c:	14620050 	bne	v1,v0,800016b0 <setTFTP_RRQ+0x174>
80001570:	8fbf001c 	lw	ra,28(sp)
   {
   	
    prom_printf("\nFile Start: %x,length=%x\n",image_address,file_length_to_client);
80001574:	3c048001 	lui	a0,0x8001
80001578:	248400e4 	addiu	a0,a0,228
8000157c:	3c028001 	lui	v0,0x8001
80001580:	8c452708 	lw	a1,9992(v0)
80001584:	3c028001 	lui	v0,0x8001
80001588:	0c001cc1 	jal	80007304 <dprintf>
8000158c:	8c4631a8 	lw	a2,12712(v0)
                    nic.packet[ETH_HLEN+14]&0xff, nic.packet[ETH_HLEN+15]&0xff
                    );
    }
    */
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
80001590:	3c028001 	lui	v0,0x8001
80001594:	8c453198 	lw	a1,12696(v0)
80001598:	24a2001a 	addiu	v0,a1,26
8000159c:	88430000 	lwl	v1,0(v0)
800015a0:	98430003 	lwr	v1,3(v0)
800015a4:	3c028001 	lui	v0,0x8001
800015a8:	ac4343fc 	sw	v1,17404(v0)

    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
800015ac:	3c038001 	lui	v1,0x8001
800015b0:	24a20006 	addiu	v0,a1,6
800015b4:	88440000 	lwl	a0,0(v0)
800015b8:	98440003 	lwr	a0,3(v0)
800015bc:	ac644400 	sw	a0,17408(v1)
800015c0:	24634400 	addiu	v1,v1,17408
800015c4:	90440004 	lbu	a0,4(v0)
800015c8:	a0640004 	sb	a0,4(v1)
800015cc:	90420005 	lbu	v0,5(v0)
800015d0:	a0620005 	sb	v0,5(v1)

    /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
800015d4:	96030000 	lhu	v1,0(s0)
800015d8:	3c028001 	lui	v0,0x8001
800015dc:	a44331a2 	sh	v1,12706(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
800015e0:	24a5002c 	addiu	a1,a1,44
800015e4:	90a20000 	lbu	v0,0(a1)
800015e8:	24100001 	li	s0,1
800015ec:	14400003 	bnez	v0,800015fc <setTFTP_RRQ+0xc0>
800015f0:	24030200 	li	v1,512
800015f4:	08000586 	j	80001618 <setTFTP_RRQ+0xdc>
800015f8:	00008021 	move	s0,zero
800015fc:	00b01021 	addu	v0,a1,s0
80001600:	90420000 	lbu	v0,0(v0)
80001604:	10400005 	beqz	v0,8000161c <setTFTP_RRQ+0xe0>
80001608:	3c118001 	lui	s1,0x8001
    CLIENT_port=  ntohs(udpheader->src); 
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    tftpopcode = tftppacket->opcode;      
    
    
    for(find_zero=0;find_zero<TFTP_DEFAULTSIZE_PACKET;find_zero++)
8000160c:	26100001 	addiu	s0,s0,1
80001610:	1603fffb 	bne	s0,v1,80001600 <setTFTP_RRQ+0xc4>
80001614:	00b01021 	addu	v0,a1,s0
        if( *( (Int8*)(tftppacket->u.rrq)+find_zero ) ==0 )
           break;
    
    memcpy(filename,tftppacket->u.rrq,find_zero);
80001618:	3c118001 	lui	s1,0x8001
8000161c:	263141f0 	addiu	s1,s1,16880
80001620:	02202021 	move	a0,s1
80001624:	0c0019e2 	jal	80006788 <memcpy>
80001628:	02003021 	move	a2,s0
    filename[find_zero]='\0';
8000162c:	02118021 	addu	s0,s0,s1
80001630:	a2000000 	sb	zero,0(s0)
             nic.packet[ETH_ALEN+2]&0xff, nic.packet[ETH_ALEN+3]&0xff,
             nic.packet[ETH_ALEN+4]&0xff, nic.packet[ETH_ALEN+5]&0xff
             );
    }
    */
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]), ETH_ALEN); 
80001634:	3c038001 	lui	v1,0x8001
80001638:	3c028001 	lui	v0,0x8001
8000163c:	8c423198 	lw	v0,12696(v0)
80001640:	24420006 	addiu	v0,v0,6
80001644:	88440000 	lwl	a0,0(v0)
80001648:	98440003 	lwr	a0,3(v0)
8000164c:	ac644400 	sw	a0,17408(v1)
80001650:	24634400 	addiu	v1,v1,17408
80001654:	90440004 	lbu	a0,4(v0)
80001658:	a0640004 	sb	a0,4(v1)
8000165c:	90420005 	lbu	v0,5(v0)
80001660:	a0620005 	sb	v0,5(v1)
   
    prom_printf("\n**TFTP GET File %s,Size %X Byte\n",filename,file_length_to_client);                
80001664:	3c048001 	lui	a0,0x8001
80001668:	24840100 	addiu	a0,a0,256
8000166c:	02202821 	move	a1,s1
80001670:	3c028001 	lui	v0,0x8001
80001674:	0c001cc1 	jal	80007304 <dprintf>
80001678:	8c4631a8 	lw	a2,12712(v0)
    /*Initialziation of RRQ file*/   
    //image_address=FILESTART; //sc_yang
    /*now we can use fiile_length_to_client, if we have meet WRQ*/
    one_tftp_lock=1;
8000167c:	24030001 	li	v1,1
80001680:	3c028001 	lui	v0,0x8001
80001684:	a043330c 	sb	v1,13068(v0)
    /*we should send a data block numbered 1, waiting for number 1 ACK.*/
    tftpd_send_data(filename,0x0001);
80001688:	02202021 	move	a0,s1
8000168c:	0c0004af 	jal	800012bc <tftpd_send_data>
80001690:	24050001 	li	a1,1
    block_expected=1;
80001694:	24030001 	li	v1,1
80001698:	3c028001 	lui	v0,0x8001
8000169c:	a4433194 	sh	v1,12692(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
    /*now change state to RRQ*/
    bootState=BOOT_STATE1_TFTP_CLIENT_RRQ; 
800016a0:	24030001 	li	v1,1
800016a4:	3c028001 	lui	v0,0x8001
800016a8:	ac4331a4 	sw	v1,12708(v0)
   }
#else
    prom_printf("\ntftp read request is not supported\n");              
#endif
}
800016ac:	8fbf001c 	lw	ra,28(sp)
800016b0:	8fb10018 	lw	s1,24(sp)
800016b4:	8fb00014 	lw	s0,20(sp)
800016b8:	03e00008 	jr	ra
800016bc:	27bd0020 	addiu	sp,sp,32

800016c0 <tftpd_send_ack>:
	tftp_client_enabled = 0;
#endif
}
//----------------------------------------------------------------------------------------
void tftpd_send_ack(Int16 number)
{
800016c0:	27bdfa28 	addiu	sp,sp,-1496
800016c4:	afbf05d4 	sw	ra,1492(sp)
800016c8:	afb005d0 	sw	s0,1488(sp)
 /*UDP target port: CLIENT_port*/
 struct iphdr *ip;
 struct udphdr *udp;
 struct tftp_t tftp_tx;
 /*generate the TFTP body*/
 tftp_tx.opcode=htons(TFTP_ACK);
800016cc:	24020004 	li	v0,4
800016d0:	a7a20034 	sh	v0,52(sp)
 tftp_tx.u.ack.block=htons(number);
800016d4:	a7a40036 	sh	a0,54(sp)
 
 ip = (struct iphdr *)&tftp_tx;
 udp = (struct udphdr *)((Int8*)&tftp_tx + sizeof(struct iphdr));
 
 /*IP header*/
 ip->verhdrlen = 0x45;
800016d8:	24020045 	li	v0,69
800016dc:	a3a20018 	sb	v0,24(sp)
 ip->service = 0;
800016e0:	a3a00019 	sb	zero,25(sp)
 ip->len = htons(32);
800016e4:	24020020 	li	v0,32
800016e8:	a7a2001a 	sh	v0,26(sp)
 ip->ident = 0;
800016ec:	a7a0001c 	sh	zero,28(sp)
 ip->frags = 0;
800016f0:	a7a0001e 	sh	zero,30(sp)
 ip->ttl = 60;
800016f4:	2402003c 	li	v0,60
800016f8:	a3a20020 	sb	v0,32(sp)
 ip->protocol = IP_UDP;
800016fc:	24020011 	li	v0,17
80001700:	a3a20021 	sb	v0,33(sp)
 ip->chksum = 0;
80001704:	a7a00022 	sh	zero,34(sp)
	 ip->dest.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr; 	
 }
 else
#endif
 {
 ip->src.s_addr = arptable_tftp[TFTP_SERVER].ipaddr.s_addr;
80001708:	3c028001 	lui	v0,0x8001
8000170c:	8c4343f0 	lw	v1,17392(v0)
80001710:	afa30024 	sw	v1,36(sp)
 ip->dest.s_addr = arptable_tftp[TFTP_CLIENT].ipaddr.s_addr;
80001714:	244243f0 	addiu	v0,v0,17392
80001718:	8c42000c 	lw	v0,12(v0)
8000171c:	afa20028 	sw	v0,40(sp)
 }
 ip->chksum = ipheader_chksum((Int16 *)&tftp_tx, sizeof(struct iphdr));
80001720:	27b00018 	addiu	s0,sp,24
80001724:	02002021 	move	a0,s0
80001728:	0c0003a7 	jal	80000e9c <ipheader_chksum>
8000172c:	24050014 	li	a1,20
80001730:	a7a20022 	sh	v0,34(sp)
	 udp->dest = htons(SERVER_port); 	
 }
 else
#endif  
 {
 udp->src  = htons(SERVER_port);
80001734:	3c028001 	lui	v0,0x8001
80001738:	944231a0 	lhu	v0,12704(v0)
8000173c:	a7a2002c 	sh	v0,44(sp)
 udp->dest = htons(CLIENT_port);
80001740:	3c028001 	lui	v0,0x8001
80001744:	944231a2 	lhu	v0,12706(v0)
80001748:	a7a2002e 	sh	v0,46(sp)
 }
 udp->len  = htons(32 - sizeof(struct iphdr));/*TFTP IP packet is 32 bytes.*/
8000174c:	2402000c 	li	v0,12
80001750:	a7a20030 	sh	v0,48(sp)
 udp->chksum = 0;
80001754:	a7a00032 	sh	zero,50(sp)
#ifdef SUPPORT_TFTP_CLIENT
 if (tftp_client_enabled)
	 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_SERVER].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4); 
 else
#endif  
 prepare_txpkt(0,FRAME_IP,arptable_tftp[TFTP_CLIENT].node,(Int8*)&tftp_tx,(Int16)sizeof(struct iphdr)+sizeof(struct udphdr)+4);
80001758:	24020020 	li	v0,32
8000175c:	afa20010 	sw	v0,16(sp)
80001760:	00002021 	move	a0,zero
80001764:	24050800 	li	a1,2048
80001768:	3c068001 	lui	a2,0x8001
8000176c:	24c64400 	addiu	a2,a2,17408
80001770:	0c000824 	jal	80002090 <prepare_txpkt>
80001774:	02003821 	move	a3,s0
}
80001778:	8fbf05d4 	lw	ra,1492(sp)
8000177c:	8fb005d0 	lw	s0,1488(sp)
80001780:	03e00008 	jr	ra
80001784:	27bd05d8 	addiu	sp,sp,1496

80001788 <setTFTP_WRQ>:
/*DEBUG*/
//int upload_start=0;
/*DEBUG*/
//----------------------------------------------------------------------------------------
static void setTFTP_WRQ(void)
{
80001788:	27bdffe8 	addiu	sp,sp,-24
8000178c:	afbf0014 	sw	ra,20(sp)
80001790:	afb00010 	sw	s0,16(sp)
 struct udphdr *udpheader;
 
 struct tftp_t *tftppacket;
 Int16 tftpopcode;

    if (!tftpd_is_ready)
80001794:	3c028001 	lui	v0,0x8001
80001798:	8c423304 	lw	v0,13060(v0)
8000179c:	10400045 	beqz	v0,800018b4 <setTFTP_WRQ+0x12c>
800017a0:	3c028001 	lui	v0,0x8001
        return;

//dprintf("Receive TFTP WRQ\n");
  
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
800017a4:	8c503198 	lw	s0,12696(v0)
800017a8:	26020022 	addiu	v0,s0,34
 if( udpheader->dest==htons(TFTP_PORT) )
800017ac:	94440002 	lhu	a0,2(v0)
800017b0:	24030045 	li	v1,69
800017b4:	14830040 	bne	a0,v1,800018b8 <setTFTP_WRQ+0x130>
800017b8:	8fbf0014 	lw	ra,20(sp)
   {
     /*memorize CLIENT port*/
    CLIENT_port=  ntohs(udpheader->src); 
800017bc:	94430000 	lhu	v1,0(v0)
800017c0:	3c028001 	lui	v0,0x8001
800017c4:	a44331a2 	sh	v1,12706(v0)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
    
    /*memorize CLIENT mac address*/
    memcpy(arptable_tftp[TFTP_CLIENT].node,(Int8*)&(nic.packet[ETH_ALEN]),ETH_ALEN);
800017c8:	3c038001 	lui	v1,0x8001
800017cc:	26020006 	addiu	v0,s0,6
800017d0:	88440000 	lwl	a0,0(v0)
800017d4:	98440003 	lwr	a0,3(v0)
800017d8:	ac644400 	sw	a0,17408(v1)
800017dc:	24634400 	addiu	v1,v1,17408
800017e0:	90440004 	lbu	a0,4(v0)
800017e4:	a0640004 	sb	a0,4(v1)
800017e8:	90420005 	lbu	v0,5(v0)
800017ec:	a0620005 	sb	v0,5(v1)
    /*memorize CLIENT IP address*/
    memcpy(&(arptable_tftp[TFTP_CLIENT].ipaddr.s_addr),(Int8*)&nic.packet[ETH_HLEN+12],4);
800017f0:	3c028001 	lui	v0,0x8001
800017f4:	8c423198 	lw	v0,12696(v0)
800017f8:	2442001a 	addiu	v0,v0,26
800017fc:	88430000 	lwl	v1,0(v0)
80001800:	98430003 	lwr	v1,3(v0)
80001804:	3c028001 	lui	v0,0x8001
80001808:	ac4343fc 	sw	v1,17404(v0)
    /*here we can parse the file name if required.*/
    prom_printf("\n**TFTP Client Upload, File Name: %s\n",tftppacket->u.wrq);   
8000180c:	2610002c 	addiu	s0,s0,44
80001810:	3c048001 	lui	a0,0x8001
80001814:	24840124 	addiu	a0,a0,292
80001818:	0c001cc1 	jal	80007304 <dprintf>
8000181c:	02002821 	move	a1,s0
    /*initializaiton of writing file.*/


//#if 0
//    if(!strcmp(tftppacket->u.wrq,TEST_FILENAME))
    if(strstr(tftppacket->u.wrq,TEST_FILENAME))
80001820:	02002021 	move	a0,s0
80001824:	3c058001 	lui	a1,0x8001
80001828:	0c001a03 	jal	8000680c <strstr>
8000182c:	24a5014c 	addiu	a1,a1,332
80001830:	10400004 	beqz	v0,80001844 <setTFTP_WRQ+0xbc>
80001834:	24030001 	li	v1,1
    {
       jump_to_test=1;
80001838:	3c028001 	lui	v0,0x8001
8000183c:	0800061d 	j	80001874 <setTFTP_WRQ+0xec>
80001840:	ac433300 	sw	v1,13056(v0)
       //image_address=TESTSTART;
    }
    else if(!strcmp(tftppacket->u.wrq,BOOT_FILENAME))
80001844:	02002021 	move	a0,s0
80001848:	3c058001 	lui	a1,0x8001
8000184c:	0c0019b1 	jal	800066c4 <strcmp>
80001850:	24a50154 	addiu	a1,a1,340
80001854:	14400008 	bnez	v0,80001878 <setTFTP_WRQ+0xf0>
80001858:	3c028001 	lui	v0,0x8001
    {
       jump_to_test=1;
8000185c:	24030001 	li	v1,1
80001860:	3c028001 	lui	v0,0x8001
80001864:	ac433300 	sw	v1,13056(v0)
       image_address=BOOTSTART;
80001868:	3c038000 	lui	v1,0x8000
8000186c:	3c028001 	lui	v0,0x8001
80001870:	ac432708 	sw	v1,9992(v0)
#endif
//#endif  
#if defined(CONFIG_TFTP_COMMAND)
	memset(image_address,0,MAX_CMD_LEN);
#endif
    address_to_store=image_address;
80001874:	3c028001 	lui	v0,0x8001
80001878:	8c432708 	lw	v1,9992(v0)
8000187c:	3c028001 	lui	v0,0x8001
80001880:	ac433190 	sw	v1,12688(v0)
    file_length_to_server=0;  
80001884:	3c028001 	lui	v0,0x8001
80001888:	ac4031b0 	sw	zero,12720(v0)
    /*now send one ACK out, to identify this.*/
    tftpd_send_ack(0x0000);/*Block number 0*/
8000188c:	0c0005b0 	jal	800016c0 <tftpd_send_ack>
80001890:	00002021 	move	a0,zero
    block_expected=1;/*later client will send an Data number 1*/
80001894:	24020001 	li	v0,1
80001898:	3c038001 	lui	v1,0x8001
8000189c:	a4623194 	sh	v0,12692(v1)
    //prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
		
	//now lock the tftp..till upload finished
	one_tftp_lock=1;
800018a0:	3c038001 	lui	v1,0x8001
800018a4:	a062330c 	sb	v0,13068(v1)
    /*Change state to WRQ state.*/
    bootState=BOOT_STATE2_TFTP_CLIENT_WRQ;
800018a8:	24030002 	li	v1,2
800018ac:	3c028001 	lui	v0,0x8001
800018b0:	ac4331a4 	sw	v1,12708(v0)
   }
}
800018b4:	8fbf0014 	lw	ra,20(sp)
800018b8:	8fb00010 	lw	s0,16(sp)
800018bc:	03e00008 	jr	ra
800018c0:	27bd0018 	addiu	sp,sp,24

800018c4 <checkAutoFlashing>:
}
#endif

#if ! (defined(CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
void checkAutoFlashing(unsigned long startAddr, int len)
{
800018c4:	27bdff88 	addiu	sp,sp,-120
800018c8:	afbf0074 	sw	ra,116(sp)
800018cc:	afbe0070 	sw	s8,112(sp)
800018d0:	afb7006c 	sw	s7,108(sp)
800018d4:	afb60068 	sw	s6,104(sp)
800018d8:	afb50064 	sw	s5,100(sp)
800018dc:	afb40060 	sw	s4,96(sp)
800018e0:	afb3005c 	sw	s3,92(sp)
800018e4:	afb20058 	sw	s2,88(sp)
800018e8:	afb10054 	sw	s1,84(sp)
800018ec:	afb00050 	sw	s0,80(sp)
800018f0:	afa40078 	sw	a0,120(sp)
800018f4:	afa5007c 	sw	a1,124(sp)
800018f8:	00009821 	move	s3,zero
800018fc:	afa00028 	sw	zero,40(sp)
80001900:	afa0002c 	sw	zero,44(sp)
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
		}
		prom_printf("checksum Ok !\n");
80001904:	3c028001 	lui	v0,0x8001
80001908:	244201bc 	addiu	v0,v0,444
8000190c:	afa2003c 	sw	v0,60(sp)
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
			    burnLen += 4;
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
80001910:	3c028001 	lui	v0,0x8001
80001914:	24420208 	addiu	v0,v0,520
80001918:	afa20040 	sw	v0,64(sp)
		}
#endif
int trueorfalse = 0;
#ifdef CONFIG_SPI_FLASH
		#ifdef SUPPORT_SPI_MIO_8198_8196C
			if(Header.burnAddr+burn_offset+burnLen > spi_flash_info[0].chip_size)
8000191c:	3c028001 	lui	v0,0x8001
80001920:	24425218 	addiu	v0,v0,21016
80001924:	afa20038 	sw	v0,56(sp)
}
FINISH_GO:
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
80001928:	3c028001 	lui	v0,0x8001
8000192c:	2442024c 	addiu	v0,v0,588
80001930:	afa20044 	sw	v0,68(sp)
80001934:	3c028001 	lui	v0,0x8001
80001938:	244200d8 	addiu	v0,v0,216
8000193c:	afa20048 	sw	v0,72(sp)

		 	    prom_printf("dual image burn_offset =0x%x \n", burn_offset); //mark_boot
			    //update bootinfo 
			    rtk_update_bootbank(next_bank);  //if bank is bank1 not bank0 ,then need add offset	
#endif		
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
80001940:	3c028001 	lui	v0,0x8001
80001944:	244201cc 	addiu	v0,v0,460
80001948:	afa2004c 	sw	v0,76(sp)
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
8000194c:	3c178001 	lui	s7,0x8001
80001950:	26f70188 	addiu	s7,s7,392
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
				head_offset += sizeof(IMG_HEADER_T);
				continue;		
			}		
			if(!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)){
80001954:	3c028001 	lui	v0,0x8001
80001958:	24420190 	addiu	v0,v0,400
8000195c:	afa20030 	sw	v0,48(sp)
			}	
			reboot |= sign_tbl[i].reboot;
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
		}
		else {
			if(!memcmp(Header.signature, BOOT_SIGNATURE, SIG_LEN))
80001960:	3c028001 	lui	v0,0x8001
80001964:	24420178 	addiu	v0,v0,376
80001968:	afa20034 	sw	v0,52(sp)
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
8000196c:	3c1e8001 	lui	s8,0x8001
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
80001970:	08000755 	j	80001d54 <checkAutoFlashing+0x490>
80001974:	27de270c 	addiu	s8,s8,9996
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
80001978:	02628021 	addu	s0,s3,v0
8000197c:	8a050000 	lwl	a1,0(s0)
80001980:	9a050003 	lwr	a1,3(s0)
80001984:	8a040004 	lwl	a0,4(s0)
80001988:	9a040007 	lwr	a0,7(s0)
8000198c:	8a030008 	lwl	v1,8(s0)
80001990:	9a03000b 	lwr	v1,11(s0)
80001994:	8a02000c 	lwl	v0,12(s0)
80001998:	9a02000f 	lwr	v0,15(s0)
8000199c:	afa50010 	sw	a1,16(sp)
800019a0:	afa40014 	sw	a0,20(sp)
800019a4:	afa30018 	sw	v1,24(sp)
800019a8:	afa2001c 	sw	v0,28(sp)
		
		if (!skip_check_signature) {
800019ac:	8fa30028 	lw	v1,40(sp)
800019b0:	14600037 	bnez	v1,80001a90 <checkAutoFlashing+0x1cc>
800019b4:	27a40010 	addiu	a0,sp,16
800019b8:	03c08821 	move	s1,s8
800019bc:	00009021 	move	s2,zero
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
800019c0:	27b60010 	addiu	s6,sp,16
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
800019c4:	24150007 	li	s5,7
			
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
800019c8:	02c02021 	move	a0,s6
800019cc:	8e250000 	lw	a1,0(s1)
800019d0:	0c0019ed 	jal	800067b4 <memcmp>
800019d4:	8e260008 	lw	a2,8(s1)
800019d8:	10400006 	beqz	v0,800019f4 <checkAutoFlashing+0x130>
800019dc:	24020007 	li	v0,7
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
		sum=0; sum1=0;
		memcpy(&Header, ((char *)startAddr + head_offset), sizeof(IMG_HEADER_T));
		
		if (!skip_check_signature) {
			for(i=0 ;i < MAX_SIG_TBL ; i++) {
800019e0:	26520001 	addiu	s2,s2,1
800019e4:	1655fff8 	bne	s2,s5,800019c8 <checkAutoFlashing+0x104>
800019e8:	26310018 	addiu	s1,s1,24
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
				head_offset += Header.len + sizeof(IMG_HEADER_T);
800019ec:	08000680 	j	80001a00 <checkAutoFlashing+0x13c>
800019f0:	8fb4001c 	lw	s4,28(sp)
				if(!memcmp(Header.signature, (char *)sign_tbl[i].signature, sign_tbl[i].sig_len))
					break;			
				
		
			}
			if(i == MAX_SIG_TBL){
800019f4:	16420005 	bne	s2,v0,80001a0c <checkAutoFlashing+0x148>
800019f8:	00121040 	sll	v0,s2,0x1
				head_offset += Header.len + sizeof(IMG_HEADER_T);
800019fc:	8fb4001c 	lw	s4,28(sp)
80001a00:	26940010 	addiu	s4,s4,16
				continue ;
80001a04:	08000754 	j	80001d50 <checkAutoFlashing+0x48c>
80001a08:	0293a021 	addu	s4,s4,s3
			}			
			skip_header = sign_tbl[i].skip ;
80001a0c:	00521021 	addu	v0,v0,s2
80001a10:	24420001 	addiu	v0,v0,1
80001a14:	000210c0 	sll	v0,v0,0x3
80001a18:	03c21021 	addu	v0,s8,v0
80001a1c:	8c420004 	lw	v0,4(v0)
80001a20:	10400003 	beqz	v0,80001a30 <checkAutoFlashing+0x16c>
80001a24:	26150010 	addiu	s5,s0,16
			if(skip_header){
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
					burnLen = Header.len; // +checksum
80001a28:	0800068f 	j	80001a3c <checkAutoFlashing+0x178>
80001a2c:	8fb1001c 	lw	s1,28(sp)
			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
80001a30:	8fb1001c 	lw	s1,28(sp)
80001a34:	26310010 	addiu	s1,s1,16
80001a38:	0200a821 	move	s5,s0
			}	
			reboot |= sign_tbl[i].reboot;
80001a3c:	001210c0 	sll	v0,s2,0x3
80001a40:	00129140 	sll	s2,s2,0x5
80001a44:	02429023 	subu	s2,s2,v0
80001a48:	03d29021 	addu	s2,s8,s2
80001a4c:	8e420014 	lw	v0,20(s2)
80001a50:	8fa3002c 	lw	v1,44(sp)
80001a54:	00621825 	or	v1,v1,v0
80001a58:	afa3002c 	sw	v1,44(sp)
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
80001a5c:	3c048001 	lui	a0,0x8001
80001a60:	24840160 	addiu	a0,a0,352
80001a64:	0c001cc1 	jal	80007304 <dprintf>
80001a68:	8e450004 	lw	a1,4(s2)
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
80001a6c:	27a40010 	addiu	a0,sp,16
80001a70:	3c058001 	lui	a1,0x8001
80001a74:	24a50170 	addiu	a1,a1,368
80001a78:	0c0019ed 	jal	800067b4 <memcmp>
80001a7c:	24060003 	li	a2,3
		    memcpy((void *)DRAM_BURN_TMP_ADDR,(void*)srcAddr,burnLen); 
		    srcAddr = DRAM_BURN_TMP_ADDR;
		}
#endif

		if(skip_check_signature || 
80001a80:	1440001b 	bnez	v0,80001af0 <checkAutoFlashing+0x22c>
80001a84:	27a40010 	addiu	a0,sp,16
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
80001a88:	080006b7 	j	80001adc <checkAutoFlashing+0x218>
80001a8c:	8fa6001c 	lw	a2,28(sp)
			}	
			reboot |= sign_tbl[i].reboot;
			prom_printf("\n%s upgrade.\n", sign_tbl[i].comment);
		}
		else {
			if(!memcmp(Header.signature, BOOT_SIGNATURE, SIG_LEN))
80001a90:	8fa50034 	lw	a1,52(sp)
80001a94:	0c0019ed 	jal	800067b4 <memcmp>
80001a98:	24060004 	li	a2,4
80001a9c:	10400009 	beqz	v0,80001ac4 <checkAutoFlashing+0x200>
80001aa0:	26150010 	addiu	s5,s0,16
				skip_header = 1;
			else {
				unsigned char *pRoot =((unsigned char *)startAddr) + head_offset + sizeof(IMG_HEADER_T);
				if (!memcmp(pRoot, SQSH_SIGNATURE, SIG_LEN))
80001aa4:	26040010 	addiu	a0,s0,16
80001aa8:	3c028001 	lui	v0,0x8001
80001aac:	24450180 	addiu	a1,v0,384
80001ab0:	0c0019ed 	jal	800067b4 <memcmp>
80001ab4:	24060004 	li	a2,4
					skip_header = 1;
				else				
					skip_header = 0;
			}				
			if(skip_header){
80001ab8:	14400004 	bnez	v0,80001acc <checkAutoFlashing+0x208>
80001abc:	00000000 	nop
				srcAddr = startAddr + head_offset + sizeof(IMG_HEADER_T);
80001ac0:	26150010 	addiu	s5,s0,16
				burnLen = Header.len ; // +checksum
80001ac4:	080006bb 	j	80001aec <checkAutoFlashing+0x228>
80001ac8:	8fb1001c 	lw	s1,28(sp)

			}else{
				srcAddr = startAddr + head_offset ;
				burnLen = Header.len + sizeof(IMG_HEADER_T) ;
80001acc:	8fb1001c 	lw	s1,28(sp)
80001ad0:	26310010 	addiu	s1,s1,16
80001ad4:	080006bb 	j	80001aec <checkAutoFlashing+0x228>
80001ad8:	0200a821 	move	s5,s0
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
80001adc:	14c0004c 	bnez	a2,80001c10 <checkAutoFlashing+0x34c>
80001ae0:	00002021 	move	a0,zero
80001ae4:	08000716 	j	80001c58 <checkAutoFlashing+0x394>
80001ae8:	00000000 	nop
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001aec:	27a40010 	addiu	a0,sp,16
80001af0:	02e02821 	move	a1,s7
80001af4:	0c0019ed 	jal	800067b4 <memcmp>
80001af8:	24060004 	li	a2,4
80001afc:	14400007 	bnez	v0,80001b1c <checkAutoFlashing+0x258>
80001b00:	27a40010 	addiu	a0,sp,16
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
80001b04:	8fa6001c 	lw	a2,28(sp)
80001b08:	24c60010 	addiu	a2,a2,16
80001b0c:	14c0000a 	bnez	a2,80001b38 <checkAutoFlashing+0x274>
80001b10:	00001021 	move	v0,zero
			if ( sum ) {
				prom_printf("%s imgage checksum error at %X!\n"
				, Header.signature, startAddr+head_offset);
				return ;
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
80001b14:	080006f8 	j	80001be0 <checkAutoFlashing+0x31c>
80001b18:	27a40010 	addiu	a0,sp,16

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
80001b1c:	8fa50030 	lw	a1,48(sp)
80001b20:	0c0019ed 	jal	800067b4 <memcmp>
80001b24:	24060004 	li	a2,4
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001b28:	1040fff7 	beqz	v0,80001b08 <checkAutoFlashing+0x244>
80001b2c:	8fa6001c 	lw	a2,28(sp)
				}				
			}	
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
80001b30:	080006da 	j	80001b68 <checkAutoFlashing+0x2a4>
80001b34:	a7a00020 	sh	zero,32(sp)
#endif

		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
80001b38:	00002021 	move	a0,zero
80001b3c:	00001821 	move	v1,zero
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
					sum += *((unsigned short *)(startAddr+ head_offset + i));
80001b40:	00902021 	addu	a0,a0,s0
80001b44:	94840000 	lhu	a0,0(a0)
80001b48:	00641821 	addu	v1,v1,a0
80001b4c:	3063ffff 	andi	v1,v1,0xffff
		if(skip_check_signature || 
			memcmp(Header.signature, WEB_SIGNATURE, 3)){
			//calculate checksum
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN) ||
					!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)) {										
				for (i=0; i< Header.len+sizeof(IMG_HEADER_T); i+=2) {
80001b50:	24420002 	addiu	v0,v0,2
80001b54:	0046282b 	sltu	a1,v0,a2
80001b58:	14a0fff9 	bnez	a1,80001b40 <checkAutoFlashing+0x27c>
80001b5c:	00402021 	move	a0,v0
80001b60:	080006ee 	j	80001bb8 <checkAutoFlashing+0x2f4>
80001b64:	00000000 	nop
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
80001b68:	8fa2001c 	lw	v0,28(sp)
80001b6c:	1040001b 	beqz	v0,80001bdc <checkAutoFlashing+0x318>
80001b70:	00002021 	move	a0,zero
80001b74:	00001021 	move	v0,zero
80001b78:	00001821 	move	v1,zero
					{
						
#if  defined(RTL8198)																		
#if 1				
						//sum +=*((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
						memcpy(&temp, (startAddr+ head_offset + sizeof(IMG_HEADER_T) + i), 2); // for alignment issue
80001b7c:	27a50020 	addiu	a1,sp,32
80001b80:	26070010 	addiu	a3,s0,16
80001b84:	00e42021 	addu	a0,a3,a0
80001b88:	90860000 	lbu	a2,0(a0)
80001b8c:	a0a60000 	sb	a2,0(a1)
80001b90:	90840001 	lbu	a0,1(a0)
80001b94:	a0a40001 	sb	a0,1(a1)
						sum+=temp;
80001b98:	97a40020 	lhu	a0,32(sp)
80001b9c:	00641821 	addu	v1,v1,a0
80001ba0:	3063ffff 	andi	v1,v1,0xffff
				else 
				{
					unsigned char x=0,y=0;
					unsigned short temp=0;
					
					for (i=0; i< Header.len; i+=2) 
80001ba4:	24420002 	addiu	v0,v0,2
80001ba8:	8fa6001c 	lw	a2,28(sp)
80001bac:	0046302b 	sltu	a2,v0,a2
80001bb0:	14c0fff4 	bnez	a2,80001b84 <checkAutoFlashing+0x2c0>
80001bb4:	00402021 	move	a0,v0
#else
				sum += *((unsigned short *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
#endif	// defined(RTL8198)
				}
			}
			if ( sum ) {
80001bb8:	10600009 	beqz	v1,80001be0 <checkAutoFlashing+0x31c>
80001bbc:	27a40010 	addiu	a0,sp,16
				prom_printf("%s imgage checksum error at %X!\n"
80001bc0:	3c048001 	lui	a0,0x8001
80001bc4:	24840198 	addiu	a0,a0,408
80001bc8:	27a50010 	addiu	a1,sp,16
80001bcc:	0c001cc1 	jal	80007304 <dprintf>
80001bd0:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
80001bd4:	08000769 	j	80001da4 <checkAutoFlashing+0x4e0>
80001bd8:	8fbf0074 	lw	ra,116(sp)
			}
			if(!memcmp(Header.signature, ALL1_SIGNATURE, SIG_LEN)){
80001bdc:	27a40010 	addiu	a0,sp,16
80001be0:	02e02821 	move	a1,s7
80001be4:	0c0019ed 	jal	800067b4 <memcmp>
80001be8:	24060004 	li	a2,4
80001bec:	10400058 	beqz	v0,80001d50 <checkAutoFlashing+0x48c>
80001bf0:	27a40010 	addiu	a0,sp,16
				head_offset += sizeof(IMG_HEADER_T);
				continue;		
			}		
			if(!memcmp(Header.signature, ALL2_SIGNATURE, SIG_LEN)){
80001bf4:	8fa50030 	lw	a1,48(sp)
80001bf8:	0c0019ed 	jal	800067b4 <memcmp>
80001bfc:	24060004 	li	a2,4
80001c00:	10400052 	beqz	v0,80001d4c <checkAutoFlashing+0x488>
80001c04:	24020001 	li	v0,1
80001c08:	08000716 	j	80001c58 <checkAutoFlashing+0x394>
80001c0c:	00000000 	nop
80001c10:	00001021 	move	v0,zero
80001c14:	00001821 	move	v1,zero
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
80001c18:	00902021 	addu	a0,a0,s0
80001c1c:	90840010 	lbu	a0,16(a0)
80001c20:	00641821 	addu	v1,v1,a0
80001c24:	306300ff 	andi	v1,v1,0xff
				continue;		
			}						
		}else
		{  //web page use different checksum algorimth

			for (i=0; i< Header.len; i++)
80001c28:	24420001 	addiu	v0,v0,1
80001c2c:	0046282b 	sltu	a1,v0,a2
80001c30:	14a0fff9 	bnez	a1,80001c18 <checkAutoFlashing+0x354>
80001c34:	00402021 	move	a0,v0
			       sum1 += *((unsigned char *)(startAddr+ head_offset + sizeof(IMG_HEADER_T) + i));
			if ( sum1 ) {
80001c38:	10600007 	beqz	v1,80001c58 <checkAutoFlashing+0x394>
80001c3c:	3c048001 	lui	a0,0x8001
				prom_printf("%s imgage checksum error at %X!\n"
80001c40:	24840198 	addiu	a0,a0,408
80001c44:	27a50010 	addiu	a1,sp,16
80001c48:	0c001cc1 	jal	80007304 <dprintf>
80001c4c:	02003021 	move	a2,s0
				, Header.signature, startAddr+head_offset);
				return ;
80001c50:	08000769 	j	80001da4 <checkAutoFlashing+0x4e0>
80001c54:	8fbf0074 	lw	ra,116(sp)
			}
		}
		prom_printf("checksum Ok !\n");
80001c58:	0c001cc1 	jal	80007304 <dprintf>
80001c5c:	8fa4003c 	lw	a0,60(sp)
		
		if( (burnLen % 0x1000) == 0) //mean 4k alignemnt
80001c60:	32220fff 	andi	v0,s1,0xfff
80001c64:	1440000d 	bnez	v0,80001c9c <checkAutoFlashing+0x3d8>
80001c68:	8fa40040 	lw	a0,64(sp)
		{
			if( (*((unsigned int *)(startAddr+burnLen))) == 0xdeadc0de ) //wrt jffs2 endof mark
80001c6c:	8fa30078 	lw	v1,120(sp)
80001c70:	02231021 	addu	v0,s1,v1
80001c74:	8c430000 	lw	v1,0(v0)
80001c78:	3c02dead 	lui	v0,0xdead
80001c7c:	3442c0de 	ori	v0,v0,0xc0de
80001c80:	14620007 	bne	v1,v0,80001ca0 <checkAutoFlashing+0x3dc>
80001c84:	8fa50018 	lw	a1,24(sp)

		 	    prom_printf("dual image burn_offset =0x%x \n", burn_offset); //mark_boot
			    //update bootinfo 
			    rtk_update_bootbank(next_bank);  //if bank is bank1 not bank0 ,then need add offset	
#endif		
		   	    prom_printf("it's special wrt image need add 4 byte to burnlen =%8x!\n",burnLen);
80001c88:	8fa4004c 	lw	a0,76(sp)
80001c8c:	0c001cc1 	jal	80007304 <dprintf>
80001c90:	02202821 	move	a1,s1
			    burnLen += 4;
80001c94:	26310004 	addiu	s1,s1,4
			}
		}
		
		prom_printf("burn Addr =0x%x! srcAddr=0x%x len =0x%x \n", Header.burnAddr, srcAddr, burnLen);
80001c98:	8fa40040 	lw	a0,64(sp)
80001c9c:	8fa50018 	lw	a1,24(sp)
80001ca0:	02a03021 	move	a2,s5
80001ca4:	0c001cc1 	jal	80007304 <dprintf>
80001ca8:	02203821 	move	a3,s1
		}
#endif
int trueorfalse = 0;
#ifdef CONFIG_SPI_FLASH
		#ifdef SUPPORT_SPI_MIO_8198_8196C
			if(Header.burnAddr+burn_offset+burnLen > spi_flash_info[0].chip_size)
80001cac:	8fa20018 	lw	v0,24(sp)
80001cb0:	8fa30038 	lw	v1,56(sp)
80001cb4:	8c67000c 	lw	a3,12(v1)
80001cb8:	02221821 	addu	v1,s1,v0
80001cbc:	00e3182b 	sltu	v1,a3,v1
80001cc0:	10600015 	beqz	v1,80001d18 <checkAutoFlashing+0x454>
80001cc4:	00002021 	move	a0,zero
				{
				if(spi_flw_image_mio_8198(0,Header.burnAddr+burn_offset, srcAddr, spi_flash_info[0].chip_size-(Header.burnAddr+burn_offset))&&
80001cc8:	00402821 	move	a1,v0
80001ccc:	02a03021 	move	a2,s5
80001cd0:	0c0011e9 	jal	800047a4 <spi_flw_image_mio_8198>
80001cd4:	00e23823 	subu	a3,a3,v0
80001cd8:	10400016 	beqz	v0,80001d34 <checkAutoFlashing+0x470>
80001cdc:	3c048001 	lui	a0,0x8001
					spi_flw_image_mio_8198(1,0, srcAddr+spi_flash_info[0].chip_size-(Header.burnAddr+burn_offset), Header.burnAddr+burn_offset+burnLen-spi_flash_info[0].chip_size))
80001ce0:	8fa30038 	lw	v1,56(sp)
80001ce4:	8c62000c 	lw	v0,12(v1)
80001ce8:	8fa70018 	lw	a3,24(sp)
80001cec:	00473023 	subu	a2,v0,a3
80001cf0:	00e23823 	subu	a3,a3,v0
80001cf4:	24040001 	li	a0,1
80001cf8:	00002821 	move	a1,zero
80001cfc:	00d53021 	addu	a2,a2,s5
80001d00:	0c0011e9 	jal	800047a4 <spi_flw_image_mio_8198>
80001d04:	00f13821 	addu	a3,a3,s1
int trueorfalse = 0;
#ifdef CONFIG_SPI_FLASH
		#ifdef SUPPORT_SPI_MIO_8198_8196C
			if(Header.burnAddr+burn_offset+burnLen > spi_flash_info[0].chip_size)
				{
				if(spi_flw_image_mio_8198(0,Header.burnAddr+burn_offset, srcAddr, spi_flash_info[0].chip_size-(Header.burnAddr+burn_offset))&&
80001d08:	1440001e 	bnez	v0,80001d84 <checkAutoFlashing+0x4c0>
80001d0c:	3c048001 	lui	a0,0x8001
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
80001d10:	0800074e 	j	80001d38 <checkAutoFlashing+0x474>
80001d14:	24840234 	addiu	a0,a0,564
				if(spi_flw_image_mio_8198(0,Header.burnAddr+burn_offset, srcAddr, spi_flash_info[0].chip_size-(Header.burnAddr+burn_offset))&&
					spi_flw_image_mio_8198(1,0, srcAddr+spi_flash_info[0].chip_size-(Header.burnAddr+burn_offset), Header.burnAddr+burn_offset+burnLen-spi_flash_info[0].chip_size))
					trueorfalse = 1;
				}
			else{
				if(spi_flw_image_mio_8198(0,Header.burnAddr+burn_offset, srcAddr, burnLen)){
80001d18:	00402821 	move	a1,v0
80001d1c:	02a03021 	move	a2,s5
80001d20:	0c0011e9 	jal	800047a4 <spi_flw_image_mio_8198>
80001d24:	02203821 	move	a3,s1
80001d28:	14400017 	bnez	v0,80001d88 <checkAutoFlashing+0x4c4>
80001d2c:	8fa40044 	lw	a0,68(sp)
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
80001d30:	3c048001 	lui	a0,0x8001
80001d34:	24840234 	addiu	a0,a0,564
80001d38:	3c058001 	lui	a1,0x8001
80001d3c:	0c001cc1 	jal	80007304 <dprintf>
80001d40:	24a500d8 	addiu	a1,a1,216
			return ;
80001d44:	08000769 	j	80001da4 <checkAutoFlashing+0x4e0>
80001d48:	8fbf0074 	lw	ra,116(sp)
80001d4c:	afa20028 	sw	v0,40(sp)
80001d50:	02809821 	move	s3,s4
#endif

#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE	
	check_dualbank_setting(0); //must do check image to get current boot_bank.......
#endif		
	while( (head_offset + sizeof(IMG_HEADER_T)) <  len){
80001d54:	26740010 	addiu	s4,s3,16
80001d58:	8fa3007c 	lw	v1,124(sp)
80001d5c:	0283102b 	sltu	v0,s4,v1
80001d60:	1440ff05 	bnez	v0,80001978 <checkAutoFlashing+0xb4>
80001d64:	8fa20078 	lw	v0,120(sp)
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
	} //while
	if(reboot){
80001d68:	8fa2002c 	lw	v0,44(sp)
80001d6c:	1040000c 	beqz	v0,80001da0 <checkAutoFlashing+0x4dc>
80001d70:	00000000 	nop
	    	autoreboot();
80001d74:	0c000461 	jal	80001184 <autoreboot>
80001d78:	00000000 	nop
	}
		
}
80001d7c:	08000769 	j	80001da4 <checkAutoFlashing+0x4e0>
80001d80:	8fbf0074 	lw	ra,116(sp)
}
FINISH_GO:
	
#endif
		if(trueorfalse)
			prom_printf("\nFlash Write Successed!\n%s", "<RealTek>");
80001d84:	8fa40044 	lw	a0,68(sp)
80001d88:	0c001cc1 	jal	80007304 <dprintf>
80001d8c:	8fa50048 	lw	a1,72(sp)
		else{
			prom_printf("\nFlash Write Failed!\n%s", "<RealTek>");
			return ;
		}

		head_offset += Header.len + sizeof(IMG_HEADER_T);
80001d90:	8fb4001c 	lw	s4,28(sp)
80001d94:	26940010 	addiu	s4,s4,16
80001d98:	08000754 	j	80001d50 <checkAutoFlashing+0x48c>
80001d9c:	0293a021 	addu	s4,s4,s3
	} //while
	if(reboot){
	    	autoreboot();
	}
		
}
80001da0:	8fbf0074 	lw	ra,116(sp)
80001da4:	8fbe0070 	lw	s8,112(sp)
80001da8:	8fb7006c 	lw	s7,108(sp)
80001dac:	8fb60068 	lw	s6,104(sp)
80001db0:	8fb50064 	lw	s5,100(sp)
80001db4:	8fb40060 	lw	s4,96(sp)
80001db8:	8fb3005c 	lw	s3,92(sp)
80001dbc:	8fb20058 	lw	s2,88(sp)
80001dc0:	8fb10054 	lw	s1,84(sp)
80001dc4:	8fb00050 	lw	s0,80(sp)
80001dc8:	03e00008 	jr	ra
80001dcc:	27bd0078 	addiu	sp,sp,120

80001dd0 <prepareACK>:
	}
    return NULL;
}
#endif
static void prepareACK(void)
{
80001dd0:	27bdffd8 	addiu	sp,sp,-40
80001dd4:	afbf0024 	sw	ra,36(sp)
80001dd8:	afb10020 	sw	s1,32(sp)
80001ddc:	afb0001c 	sw	s0,28(sp)
 struct udphdr *udpheader;
 struct tftp_t *tftppacket;
 Int16 tftpopcode;
 Int32 tftpdata_length;
 volatile Int16 block_received=0;
80001de0:	a7a00010 	sh	zero,16(sp)
    IMG_HEADER_T header;
    int ret;
    extern int check_system_image(unsigned long addr, IMG_HEADER_Tp pHeader);
#endif

    if (!tftpd_is_ready)
80001de4:	3c028001 	lui	v0,0x8001
80001de8:	8c423304 	lw	v0,13060(v0)
80001dec:	104000a2 	beqz	v0,80002078 <prepareACK+0x2a8>
80001df0:	3c028001 	lui	v0,0x8001
        return;

	//dprintf("Receive TFTP Data\n");
 
 udpheader = (struct udphdr *)&nic.packet[ETH_HLEN+ sizeof(struct iphdr)];
80001df4:	8c423198 	lw	v0,12696(v0)
80001df8:	24420022 	addiu	v0,v0,34
#ifdef SUPPORT_TFTP_CLIENT
 if((tftp_client_enabled && (udpheader->dest==htons(CLIENT_port))) || 	
	 (!tftp_client_enabled && (udpheader->dest==htons(SERVER_port))))
#else	
 if(udpheader->dest==htons(SERVER_port))
80001dfc:	94440002 	lhu	a0,2(v0)
80001e00:	3c038001 	lui	v1,0x8001
80001e04:	946331a0 	lhu	v1,12704(v1)
80001e08:	1483009c 	bne	a0,v1,8000207c <prepareACK+0x2ac>
80001e0c:	8fbf0024 	lw	ra,36(sp)
   	if (tftp_client_enabled)
		SERVER_port = ntohs(udpheader->src); 
	else
#endif		
          /*memorize CLIENT port*/
          CLIENT_port=  ntohs(udpheader->src); 
80001e10:	94440000 	lhu	a0,0(v0)
80001e14:	3c038001 	lui	v1,0x8001
80001e18:	a46431a2 	sh	a0,12706(v1)
    tftppacket = (struct tftp_t *)&nic.packet[ETH_HLEN];
80001e1c:	3c038001 	lui	v1,0x8001
80001e20:	8c653198 	lw	a1,12696(v1)
80001e24:	24a5000e 	addiu	a1,a1,14
    /*no need to check opcode, this is a Data packet*/     
    /*parse the TFTP block number*/	
    block_received=tftppacket->u.data.block;
80001e28:	94a3001e 	lhu	v1,30(a1)
80001e2c:	a7a30010 	sh	v1,16(sp)
//prom_printf("line=%d:		block_received=%d\n", __LINE__,  block_received); // for debug
    
    if(block_received != (block_expected))
80001e30:	97a40010 	lhu	a0,16(sp)
80001e34:	3084ffff 	andi	a0,a0,0xffff
80001e38:	3c038001 	lui	v1,0x8001
80001e3c:	94633194 	lhu	v1,12692(v1)
80001e40:	3063ffff 	andi	v1,v1,0xffff
80001e44:	1083000b 	beq	a0,v1,80001e74 <prepareACK+0xa4>
80001e48:	3c108001 	lui	s0,0x8001
    {
     //prom_printf("line=%d: block_received=%d, block_expected=%d\n", __LINE__,  block_received,  block_expected); // for debug
     prom_printf("TFTP #\n");
80001e4c:	3c048001 	lui	a0,0x8001
80001e50:	0c001cc1 	jal	80007304 <dprintf>
80001e54:	24840268 	addiu	a0,a0,616
     /*restore the block number*/
     tftpd_send_ack(block_expected-1);    
80001e58:	3c028001 	lui	v0,0x8001
80001e5c:	94443194 	lhu	a0,12692(v0)
80001e60:	2484ffff 	addiu	a0,a0,-1
80001e64:	0c0005b0 	jal	800016c0 <tftpd_send_ack>
80001e68:	3084ffff 	andi	a0,a0,0xffff
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
80001e6c:	0800081f 	j	8000207c <prepareACK+0x2ac>
80001e70:	8fbf0024 	lw	ra,36(sp)
     tftpd_send_ack(block_expected-1);    
    }
    else 
     {      
          
      tftpdata_length=ntohs(udpheader->len)-4-sizeof(struct udphdr);
80001e74:	94510004 	lhu	s1,4(v0)
80001e78:	2631fff4 	addiu	s1,s1,-12
      /*put the image into memory address*/
      memcpy((void *)address_to_store, tftppacket->u.data.download, tftpdata_length);
80001e7c:	8e043190 	lw	a0,12688(s0)
80001e80:	24a50020 	addiu	a1,a1,32
80001e84:	0c0019e2 	jal	80006788 <memcpy>
80001e88:	02203021 	move	a2,s1
	//flush_cache_range(address_to_store,tftpdata_length);
	// ddump(address_to_store, tftpdata_length);
      //prom_printf("a %x. l %x\n",address_to_store,tftpdata_length);
      
      address_to_store=address_to_store+tftpdata_length;
80001e8c:	8e023190 	lw	v0,12688(s0)
80001e90:	02221021 	addu	v0,s1,v0
80001e94:	ae023190 	sw	v0,12688(s0)
      /*use this to count the image bytes*/
      file_length_to_server=file_length_to_server+tftpdata_length;
80001e98:	3c028001 	lui	v0,0x8001
80001e9c:	8c4331b0 	lw	v1,12720(v0)
80001ea0:	02231821 	addu	v1,s1,v1
      /*this is for receiving one packet*/
      //prom_printf("%x.\n",address_to_store);
      twiddle();
80001ea4:	0c001bf9 	jal	80006fe4 <twiddle>
80001ea8:	ac4331b0 	sw	v1,12720(v0)
      //prom_printf(" <- ");
      //prom_printf("%x. %x. %x\n",block_expected,address_to_store,tftpdata_length);
      
      tftpd_send_ack(block_expected);               
80001eac:	3c108001 	lui	s0,0x8001
80001eb0:	96043194 	lhu	a0,12692(s0)
80001eb4:	0c0005b0 	jal	800016c0 <tftpd_send_ack>
80001eb8:	3084ffff 	andi	a0,a0,0xffff
      block_expected=block_expected+1;
80001ebc:	96023194 	lhu	v0,12692(s0)
80001ec0:	24420001 	addiu	v0,v0,1
80001ec4:	3042ffff 	andi	v0,v0,0xffff
80001ec8:	a6023194 	sh	v0,12692(s0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
      
      /*remember to check if it is the last packet*/      
      if(tftpdata_length < TFTP_DEFAULTSIZE_PACKET)
80001ecc:	2e310200 	sltiu	s1,s1,512
80001ed0:	1220006a 	beqz	s1,8000207c <prepareACK+0x2ac>
80001ed4:	8fbf0024 	lw	ra,36(sp)
        {
         prom_printf("\n**TFTP Client Upload File Size = %X Bytes at %X\n",file_length_to_server,image_address);          
80001ed8:	3c118001 	lui	s1,0x8001
80001edc:	3c108001 	lui	s0,0x8001
80001ee0:	3c048001 	lui	a0,0x8001
80001ee4:	24840270 	addiu	a0,a0,624
80001ee8:	8e2531b0 	lw	a1,12720(s1)
80001eec:	0c001cc1 	jal	80007304 <dprintf>
80001ef0:	8e062708 	lw	a2,9992(s0)
         /*change the boot state back to orignal, and some variables also*/
         nic.packet = eth_packet;
80001ef4:	3c028001 	lui	v0,0x8001
80001ef8:	3c038001 	lui	v1,0x8001
80001efc:	24634414 	addiu	v1,v1,17428
80001f00:	ac433198 	sw	v1,12696(v0)
         nic.packetlen = 0;        
80001f04:	24423198 	addiu	v0,v0,12696
80001f08:	ac400004 	sw	zero,4(v0)
         block_expected =0;   
80001f0c:	3c028001 	lui	v0,0x8001
80001f10:	a4403194 	sh	zero,12692(v0)
//prom_printf("line=%d:		block_expected=%d\n", __LINE__,  block_expected); // for debug
				 
         /*reset the file position*/
         //image_address=FILESTART;
         address_to_store=image_address;
80001f14:	8e032708 	lw	v1,9992(s0)
80001f18:	3c028001 	lui	v0,0x8001
80001f1c:	ac433190 	sw	v1,12688(v0)
         file_length_to_client=file_length_to_server;
80001f20:	8e2331b0 	lw	v1,12720(s1)
80001f24:	3c028001 	lui	v0,0x8001
80001f28:	ac4331a8 	sw	v1,12712(v0)
         /*file_length_to_server can not be reset,only when another WRQ */
         /*and export to file_length_to_client for our SDRAM direct RRQ*/
         it_is_EOF=0;
80001f2c:	3c028001 	lui	v0,0x8001
80001f30:	ac403310 	sw	zero,13072(v0)
#if defined(SUPPORT_TFTP_CLIENT)
		if(tftp_from_command)
		    tftp_client_recvdone = 1;
#endif
         bootState=BOOT_STATE0_INIT_ARP;
80001f34:	3c028001 	lui	v0,0x8001
80001f38:	ac4031a4 	sw	zero,12708(v0)
         /*Cyrus Tsai*/
         one_tftp_lock=0; 
80001f3c:	3c028001 	lui	v0,0x8001
80001f40:	a040330c 	sb	zero,13068(v0)
         SERVER_port++;
80001f44:	3c028001 	lui	v0,0x8001
80001f48:	944331a0 	lhu	v1,12704(v0)
80001f4c:	24630001 	addiu	v1,v1,1
80001f50:	a44331a0 	sh	v1,12704(v0)
#if defined(SUPPORT_TFTP_CLIENT)
     if(tftp_from_command)
		prom_printf( "\nSuccess!\n");
	 else
#endif
		prom_printf( "\nSuccess!\n%s", "<RealTek>" );
80001f54:	3c048001 	lui	a0,0x8001
80001f58:	248402a4 	addiu	a0,a0,676
80001f5c:	3c058001 	lui	a1,0x8001
80001f60:	0c001cc1 	jal	80007304 <dprintf>
80001f64:	24a500d8 	addiu	a1,a1,216
		
		jump_to_test = 1;  //wei add
	}
#endif  //CONFIG_NFBI

         if(jump_to_test==1)
80001f68:	3c028001 	lui	v0,0x8001
80001f6c:	8c433300 	lw	v1,13056(v0)
80001f70:	24020001 	li	v0,1
80001f74:	14620038 	bne	v1,v0,80002058 <prepareACK+0x288>
80001f78:	3c028001 	lui	v0,0x8001
           {
            jump_to_test=0;
80001f7c:	3c028001 	lui	v0,0x8001
80001f80:	ac403300 	sw	zero,13056(v0)
	    /*we should clear all irq mask.*/
	    //jumpF = (void *)(TESTSTART); //sc_yang
	 REG32(0xb8000010)=REG32(0xb8000010) &(~(1<<11)); //disable switch IRQ
80001f84:	3c02b800 	lui	v0,0xb800
80001f88:	34420010 	ori	v0,v0,0x10
80001f8c:	8c440000 	lw	a0,0(v0)
80001f90:	2403f7ff 	li	v1,-2049
80001f94:	00831824 	and	v1,a0,v1
80001f98:	ac430000 	sw	v1,0(v0)
		image_address &= ~0x20000000;
80001f9c:	8e042708 	lw	a0,9992(s0)
80001fa0:	3c02dfff 	lui	v0,0xdfff
80001fa4:	3442ffff 	ori	v0,v0,0xffff
80001fa8:	00821024 	and	v0,a0,v0
80001fac:	ae022708 	sw	v0,9992(s0)
	    jumpF = (void *)(image_address);
80001fb0:	3c038001 	lui	v1,0x8001
80001fb4:	ac6231ac 	sw	v0,12716(v1)
80001fb8:	3c03b800 	lui	v1,0xb800
80001fbc:	00001021 	move	v0,zero
80001fc0:	ac623000 	sw	v0,12288(v1)
80001fc4:	40016000 	mfc0	at,c0_status
80001fc8:	34210001 	ori	at,at,0x1
80001fcc:	38210001 	xori	at,at,0x1
80001fd0:	40816000 	mtc0	at,c0_status
80001fd4:	000000c0 	ehb
	...
	    /*we should clear all irq mask.*/
	    
		outl(0,GIMR0); // mask all interrupt	    
	   cli();
		REG32(0xb8003114)=0;  //disable timer interrupt
80001fe4:	3c02b800 	lui	v0,0xb800
80001fe8:	34433114 	ori	v1,v0,0x3114
80001fec:	ac600000 	sw	zero,0(v1)
		REG32(0xb8000010)&=~(1<<11);
80001ff0:	34420010 	ori	v0,v0,0x10
80001ff4:	8c440000 	lw	a0,0(v0)
80001ff8:	2403f7ff 	li	v1,-2049
80001ffc:	00831824 	and	v1,a0,v1
80002000:	ac430000 	sw	v1,0(v0)
		
		REG32(0xbbdc0300)=0xFFFFFFFF;
80002004:	3c03bbdc 	lui	v1,0xbbdc
80002008:	34640300 	ori	a0,v1,0x300
8000200c:	2402ffff 	li	v0,-1
80002010:	ac820000 	sw	v0,0(a0)
		REG32(0xbbdc0304)=0xFFFFFFFF;
80002014:	34630304 	ori	v1,v1,0x304
80002018:	ac620000 	sw	v0,0(v1)
		dprintf("Jump to 0x%x\n", image_address);
8000201c:	3c048001 	lui	a0,0x8001
80002020:	248402b4 	addiu	a0,a0,692
80002024:	3c028001 	lui	v0,0x8001
80002028:	0c001cc1 	jal	80007304 <dprintf>
8000202c:	8c452708 	lw	a1,9992(v0)
		flush_cache();
80002030:	0c00187c 	jal	800061f0 <flush_cache>
80002034:	00000000 	nop
		invalidate_cache();
80002038:	0c001870 	jal	800061c0 <invalidate_cache>
8000203c:	00000000 	nop
	    jumpF();	
80002040:	3c028001 	lui	v0,0x8001
80002044:	8c4231ac 	lw	v0,12716(v0)
80002048:	0040f809 	jalr	v0
8000204c:	00000000 	nop
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
80002050:	0800081f 	j	8000207c <prepareACK+0x2ac>
80002054:	8fbf0024 	lw	ra,36(sp)
		flush_cache();
		invalidate_cache();
	    jumpF();	
           }
#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))
	   else if(autoBurn)
80002058:	8c4227b4 	lw	v0,10164(v0)
8000205c:	10400007 	beqz	v0,8000207c <prepareACK+0x2ac>
80002060:	8fbf0024 	lw	ra,36(sp)
	   {
	   	checkAutoFlashing(image_address, file_length_to_server);
80002064:	3c028001 	lui	v0,0x8001
80002068:	8c442708 	lw	a0,9992(v0)
8000206c:	3c028001 	lui	v0,0x8001
80002070:	0c000631 	jal	800018c4 <checkAutoFlashing>
80002074:	8c4531b0 	lw	a1,12720(v0)
     }
   }
//else 
//   prom_printf("\n**TFTP port number error");   

}
80002078:	8fbf0024 	lw	ra,36(sp)
8000207c:	8fb10020 	lw	s1,32(sp)
80002080:	8fb0001c 	lw	s0,28(sp)
80002084:	03e00008 	jr	ra
80002088:	27bd0028 	addiu	sp,sp,40
8000208c:	00000000 	nop

80002090 <prepare_txpkt>:
}

//----------------------------------------------------------------------------------------
/*Just a start address, and the data length*/
void prepare_txpkt(int etherport, Int16 type, Int8* destaddr, Int8* data, Int16 len) 
{
80002090:	27bdffd8 	addiu	sp,sp,-40
80002094:	afbf0024 	sw	ra,36(sp)
80002098:	afb10020 	sw	s1,32(sp)
8000209c:	afb0001c 	sw	s0,28(sp)
800020a0:	30a5ffff 	andi	a1,a1,0xffff
800020a4:	97b1003a 	lhu	s1,58(sp)
	char *tx_buffer=&ETH0_tx_buf[0][0];
800020a8:	3c108001 	lui	s0,0x8001
800020ac:	2610332c 	addiu	s0,s0,13100
 	Int16 nstype;	
	int Length=len;
	
	memcpy(tx_buffer,destaddr,6);
800020b0:	88c20000 	lwl	v0,0(a2)
800020b4:	98c20003 	lwr	v0,3(a2)
800020b8:	aa020000 	swl	v0,0(s0)
800020bc:	ba020003 	swr	v0,3(s0)
800020c0:	90c20004 	lbu	v0,4(a2)
800020c4:	a2020004 	sb	v0,4(s0)
800020c8:	90c20005 	lbu	v0,5(a2)
800020cc:	a2020005 	sb	v0,5(s0)

	/*Source Address*/
	memcpy(tx_buffer+6,eth0_mac,6);
800020d0:	26020006 	addiu	v0,s0,6
800020d4:	3c038001 	lui	v1,0x8001
800020d8:	8c6429e0 	lw	a0,10720(v1)
800020dc:	a8440000 	swl	a0,0(v0)
800020e0:	b8440003 	swr	a0,3(v0)
800020e4:	246329e0 	addiu	v1,v1,10720
800020e8:	90640004 	lbu	a0,4(v1)
800020ec:	a0440004 	sb	a0,4(v0)
800020f0:	90630005 	lbu	v1,5(v1)
800020f4:	a0430005 	sb	v1,5(v0)

	/*Payload type*/
	nstype = htons(type);
800020f8:	a7a50010 	sh	a1,16(sp)
	memcpy(tx_buffer + 12,(Int8*)&nstype,2);
800020fc:	2602000c 	addiu	v0,s0,12
80002100:	00051a02 	srl	v1,a1,0x8
80002104:	a0430000 	sb	v1,0(v0)
80002108:	a0450001 	sb	a1,1(v0)

	/*Payload */
	memcpy(tx_buffer + 14,(Int8*)data,Length);
8000210c:	2604000e 	addiu	a0,s0,14
80002110:	00e02821 	move	a1,a3
80002114:	0c0019e2 	jal	80006788 <memcpy>
80002118:	02203021 	move	a2,s1
	Length += 14;

//	printf("tx pkt\n");
	swNic_send(tx_buffer,Length);
8000211c:	02002021 	move	a0,s0
80002120:	0c000f50 	jal	80003d40 <swNic_send>
80002124:	2625000e 	addiu	a1,s1,14
}
80002128:	8fbf0024 	lw	ra,36(sp)
8000212c:	8fb10020 	lw	s1,32(sp)
80002130:	8fb0001c 	lw	s0,28(sp)
80002134:	03e00008 	jr	ra
80002138:	27bd0028 	addiu	sp,sp,40

8000213c <eth_startup>:
}

#endif
//----------------------------------------------------------------------------------------
void eth_startup(int etherport)
{
8000213c:	27bdff90 	addiu	sp,sp,-112
80002140:	afbf006c 	sw	ra,108(sp)
	Int32 val;
	int i;

#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH)|| defined(CONFIG_NAND_FLASH)||defined(CONFIG_NAND_FLASH_BOOTING))
	memset(eth0_ip_httpd, 0, 4);
80002144:	3c028001 	lui	v0,0x8001
#ifdef CONFIG_HTTP_SERVER
	getmacandip(eth0_mac_httpd,eth0_ip_httpd);
#endif
#endif

	if (swCore_init()) {  	
80002148:	0c000cc5 	jal	80003314 <swCore_init>
8000214c:	ac403328 	sw	zero,13096(v0)
80002150:	10400006 	beqz	v0,8000216c <eth_startup+0x30>
80002154:	24020004 	li	v0,4
		dprintf("\nSwitch core initialization failed!\n");        
80002158:	3c048001 	lui	a0,0x8001
8000215c:	0c001cc1 	jal	80007304 <dprintf>
80002160:	24840350 	addiu	a0,a0,848
		return;
80002164:	080008a4 	j	80002290 <eth_startup+0x154>
80002168:	8fbf006c 	lw	ra,108(sp)
	}

    	//avoid download bin checksum error
	uint32 rx[6] = {4, 0, 0, 0, 0, 0};
8000216c:	afa20010 	sw	v0,16(sp)
80002170:	afa00014 	sw	zero,20(sp)
80002174:	afa00018 	sw	zero,24(sp)
80002178:	afa0001c 	sw	zero,28(sp)
8000217c:	afa00020 	sw	zero,32(sp)
80002180:	afa00024 	sw	zero,36(sp)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
        uint32 tx[4] = {4, 2, 2, 2};
80002184:	afa20028 	sw	v0,40(sp)
80002188:	24020002 	li	v0,2
8000218c:	afa2002c 	sw	v0,44(sp)
80002190:	afa20030 	sw	v0,48(sp)
80002194:	afa20034 	sw	v0,52(sp)
#else
        uint32 tx[2] = {4, 2};
#endif

	/* Initialize NIC module */
	if (swNic_init(rx, 4, tx, MBUF_LEN)) {
80002198:	27a40010 	addiu	a0,sp,16
8000219c:	24050004 	li	a1,4
800021a0:	27a60028 	addiu	a2,sp,40
800021a4:	0c000da9 	jal	800036a4 <swNic_init>
800021a8:	24070800 	li	a3,2048
800021ac:	10400006 	beqz	v0,800021c8 <eth_startup+0x8c>
800021b0:	27a50044 	addiu	a1,sp,68
		dprintf("\nSwitch nic initialization failed!\n");            
800021b4:	3c048001 	lui	a0,0x8001
800021b8:	0c001cc1 	jal	80007304 <dprintf>
800021bc:	24840378 	addiu	a0,a0,888
		return;
800021c0:	080008a4 	j	80002290 <eth_startup+0x154>
800021c4:	8fbf006c 	lw	ra,108(sp)
	rtl_netif_param_t np;
	rtl_acl_param_t ap;

	/* Create Netif */
#if !(defined(CONFIG_RTL_LAN_WAN_ISOLATION) || defined(CONFIG_RTL_ALL_PORT_ISOLATION))
	bzero((void *) &np, sizeof(rtl_netif_param_t));
800021c8:	aca00004 	sw	zero,4(a1)
	np.vid = 8;
800021cc:	24020008 	li	v0,8
800021d0:	a7a2004e 	sh	v0,78(sp)
	np.valid = 1;
800021d4:	24020001 	li	v0,1
	np.enableRoute = 0;
800021d8:	00021f80 	sll	v1,v0,0x1e
800021dc:	7c03ffc4 	ins	v1,zero,0x1f,0x1
800021e0:	afa30064 	sw	v1,100(sp)
	np.inAclEnd = 0;
800021e4:	afa00054 	sw	zero,84(sp)
	np.inAclStart = 0;
800021e8:	afa00050 	sw	zero,80(sp)
	np.outAclEnd = 0;
800021ec:	afa0005c 	sw	zero,92(sp)
	np.outAclStart = 0;
800021f0:	afa00058 	sw	zero,88(sp)
	memcpy(&np.gMac, &eth0_mac[0], 6);
800021f4:	3c038001 	lui	v1,0x8001
800021f8:	8c6429e0 	lw	a0,10720(v1)
800021fc:	aca40000 	sw	a0,0(a1)
80002200:	246329e0 	addiu	v1,v1,10720
80002204:	94630004 	lhu	v1,4(v1)
80002208:	a4a30004 	sh	v1,4(a1)

	np.macAddrNumber = 1;
8000220c:	a7a2004c 	sh	v0,76(sp)
	np.mtu = 1500;
80002210:	240205dc 	li	v0,1500
80002214:	afa20060 	sw	v0,96(sp)
	ret = swCore_netifCreate(0, &np);
80002218:	0c001113 	jal	8000444c <swCore_netifCreate>
8000221c:	00002021 	move	a0,zero
	if (ret != 0) {
80002220:	10400007 	beqz	v0,80002240 <eth_startup+0x104>
80002224:	27a50038 	addiu	a1,sp,56
		printf( "Creating intif fails:%d\n", ret );
80002228:	3c048001 	lui	a0,0x8001
8000222c:	2484039c 	addiu	a0,a0,924
80002230:	0c001cc1 	jal	80007304 <dprintf>
80002234:	00402821 	move	a1,v0
		return;
80002238:	080008a4 	j	80002290 <eth_startup+0x154>
8000223c:	8fbf006c 	lw	ra,108(sp)
	}

	/* Create vlan */
	bzero((void *) &vp, sizeof(rtl_vlan_param_t));
80002240:	aca00008 	sw	zero,8(a1)
	vp.egressUntag = ALL_PORT_MASK;
80002244:	2402003f 	li	v0,63
80002248:	afa2003c 	sw	v0,60(sp)
	vp.memberPort = ALL_PORT_MASK;
8000224c:	afa20038 	sw	v0,56(sp)
	ret = swCore_vlanCreate(8, &vp);
80002250:	0c0010d6 	jal	80004358 <vlanTable_create>
80002254:	24040008 	li	a0,8
	if (ret != 0) {       
80002258:	10400007 	beqz	v0,80002278 <eth_startup+0x13c>
8000225c:	24040019 	li	a0,25
		printf( "Creating vlan fails:%d\n", ret );
80002260:	3c048001 	lui	a0,0x8001
80002264:	248403b8 	addiu	a0,a0,952
80002268:	0c001cc1 	jal	80007304 <dprintf>
8000226c:	00402821 	move	a1,v0
       return;
80002270:	080008a4 	j	80002290 <eth_startup+0x154>
80002274:	8fbf006c 	lw	ra,108(sp)
    /* Set interrupt routing register */

#if !defined(CONFIG_RTL8198C)
	REG32(IRR1_REG) |= (3<<28); 
#endif	
 	request_IRQ(ETH0_IRQ, &irq_eth15,&(ETH[0]));
80002278:	3c058001 	lui	a1,0x8001
8000227c:	24a529e8 	addiu	a1,a1,10728
80002280:	3c068001 	lui	a2,0x8001
80002284:	0c000274 	jal	800009d0 <request_IRQ>
80002288:	24c63fac 	addiu	a2,a2,16300
}
8000228c:	8fbf006c 	lw	ra,108(sp)
80002290:	03e00008 	jr	ra
80002294:	27bd0070 	addiu	sp,sp,112

80002298 <gethwmac>:
}
//---------------------------------------------------------------------------------------

#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH)|| defined(CONFIG_NAND_FLASH)||defined(CONFIG_NAND_FLASH_BOOTING))
void gethwmac(unsigned char *mac)
{
80002298:	27bdffd8 	addiu	sp,sp,-40
8000229c:	afbf0024 	sw	ra,36(sp)
800022a0:	afb20020 	sw	s2,32(sp)
800022a4:	afb1001c 	sw	s1,28(sp)
800022a8:	afb00018 	sw	s0,24(sp)
800022ac:	00808021 	move	s0,a0
	unsigned short len;
	unsigned char *buf;
	unsigned char sum=0;
	int i;
	
	if (flashread(tmpbuf, HW_SETTING_OFFSET,6)==0 ) {
800022b0:	27a40010 	addiu	a0,sp,16
800022b4:	3c050002 	lui	a1,0x2
800022b8:	0c0011c2 	jal	80004708 <flashread>
800022bc:	24060006 	li	a2,6
800022c0:	10400040 	beqz	v0,800023c4 <gethwmac+0x12c>
800022c4:	93a30010 	lbu	v1,16(sp)
		return;
	}
	if(tmpbuf[0] == 'h')
800022c8:	24020068 	li	v0,104
800022cc:	1462003e 	bne	v1,v0,800023c8 <gethwmac+0x130>
800022d0:	8fbf0024 	lw	ra,36(sp)
	{
		memcpy(&len, &tmpbuf[4], 2);
800022d4:	97a40014 	lhu	a0,20(sp)
800022d8:	a7a40016 	sh	a0,22(sp)
		if(len > 0x2000)
800022dc:	3084ffff 	andi	a0,a0,0xffff
800022e0:	2c822001 	sltiu	v0,a0,8193
800022e4:	10400038 	beqz	v0,800023c8 <gethwmac+0x130>
800022e8:	8fbf0024 	lw	ra,36(sp)
			return;
		if(NULL==(buf=(unsigned char *)malloc(len)))
800022ec:	0c0018f1 	jal	800063c4 <malloc>
800022f0:	00000000 	nop
800022f4:	00408821 	move	s1,v0
800022f8:	10400032 	beqz	v0,800023c4 <gethwmac+0x12c>
800022fc:	00409021 	move	s2,v0
			return;
		flashread(buf,HW_SETTING_OFFSET+6,len);
80002300:	00402021 	move	a0,v0
80002304:	3c050002 	lui	a1,0x2
80002308:	34a50006 	ori	a1,a1,0x6
8000230c:	0c0011c2 	jal	80004708 <flashread>
80002310:	97a60016 	lhu	a2,22(sp)
		if(len != 0 && len <= 0x2000) {					
80002314:	97a40016 	lhu	a0,22(sp)
80002318:	2482ffff 	addiu	v0,a0,-1
8000231c:	3042ffff 	andi	v0,v0,0xffff
80002320:	2c422000 	sltiu	v0,v0,8192
80002324:	10400025 	beqz	v0,800023bc <gethwmac+0x124>
80002328:	00000000 	nop
			for (i=0;i<len;i++) 
8000232c:	18800009 	blez	a0,80002354 <gethwmac+0xbc>
80002330:	00912021 	addu	a0,a0,s1
	swNic_txDone();
}
//---------------------------------------------------------------------------------------

#if !(defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH)|| defined(CONFIG_NAND_FLASH)||defined(CONFIG_NAND_FLASH_BOOTING))
void gethwmac(unsigned char *mac)
80002334:	00001021 	move	v0,zero
		if(NULL==(buf=(unsigned char *)malloc(len)))
			return;
		flashread(buf,HW_SETTING_OFFSET+6,len);
		if(len != 0 && len <= 0x2000) {					
			for (i=0;i<len;i++) 
				sum += buf[i];
80002338:	92230000 	lbu	v1,0(s1)
8000233c:	00431021 	addu	v0,v0,v1
80002340:	26310001 	addiu	s1,s1,1
			return;
		if(NULL==(buf=(unsigned char *)malloc(len)))
			return;
		flashread(buf,HW_SETTING_OFFSET+6,len);
		if(len != 0 && len <= 0x2000) {					
			for (i=0;i<len;i++) 
80002344:	1624fffc 	bne	s1,a0,80002338 <gethwmac+0xa0>
80002348:	304200ff 	andi	v0,v0,0xff
				sum += buf[i];
		}
		else
			sum=1;
		if(0 == sum)
8000234c:	1440001b 	bnez	v0,800023bc <gethwmac+0x124>
80002350:	00000000 	nop
		{			
			memcpy(mac,buf+HW_NIC0_MAC_OFFSET,6);
80002354:	26420001 	addiu	v0,s2,1
80002358:	88430000 	lwl	v1,0(v0)
8000235c:	98430003 	lwr	v1,3(v0)
80002360:	aa030000 	swl	v1,0(s0)
80002364:	ba030003 	swr	v1,3(s0)
80002368:	90430004 	lbu	v1,4(v0)
8000236c:	a2030004 	sb	v1,4(s0)
80002370:	90420005 	lbu	v0,5(v0)
80002374:	a2020005 	sb	v0,5(s0)
			if(memcmp(mac,"\x0\x0\x0\x0\x0\x0", 6) && !(mac[0] & 0x1))
80002378:	02002021 	move	a0,s0
8000237c:	3c058001 	lui	a1,0x8001
80002380:	24a5e260 	addiu	a1,a1,-7584
80002384:	0c0019ed 	jal	800067b4 <memcmp>
80002388:	24060006 	li	a2,6
8000238c:	10400005 	beqz	v0,800023a4 <gethwmac+0x10c>
80002390:	00000000 	nop
80002394:	92020000 	lbu	v0,0(s0)
80002398:	30420001 	andi	v0,v0,0x1
8000239c:	10400007 	beqz	v0,800023bc <gethwmac+0x124>
800023a0:	00000000 	nop
			{
				/*normal mac*/
			}
			else
			{
				memset(mac,0x0,6);
800023a4:	a2000000 	sb	zero,0(s0)
800023a8:	a2000001 	sb	zero,1(s0)
800023ac:	a2000002 	sb	zero,2(s0)
800023b0:	a2000003 	sb	zero,3(s0)
800023b4:	a2000004 	sb	zero,4(s0)
800023b8:	a2000005 	sb	zero,5(s0)
			}
		}
		if(buf)
			free(buf);
800023bc:	0c001922 	jal	80006488 <free>
800023c0:	02402021 	move	a0,s2
	}
	return;
}
800023c4:	8fbf0024 	lw	ra,36(sp)
800023c8:	8fb20020 	lw	s2,32(sp)
800023cc:	8fb1001c 	lw	s1,28(sp)
800023d0:	8fb00018 	lw	s0,24(sp)
800023d4:	03e00008 	jr	ra
800023d8:	27bd0028 	addiu	sp,sp,40

800023dc <getmacandip>:

void getmacandip(unsigned char *mac,unsigned char *ip)
{
800023dc:	27bdffd0 	addiu	sp,sp,-48
800023e0:	afbf002c 	sw	ra,44(sp)
800023e4:	afb30028 	sw	s3,40(sp)
800023e8:	afb20024 	sw	s2,36(sp)
800023ec:	afb10020 	sw	s1,32(sp)
800023f0:	afb0001c 	sw	s0,28(sp)
800023f4:	00808821 	move	s1,a0
800023f8:	00a08021 	move	s0,a1
	int i;

	int currSettingMaxLen = 0x4000;

	
	if (flashread(tmpbuf, CURRENT_SETTING_OFFSET,6)==0 ) {
800023fc:	27a40010 	addiu	a0,sp,16
80002400:	3c050002 	lui	a1,0x2
80002404:	34a5a000 	ori	a1,a1,0xa000
80002408:	0c0011c2 	jal	80004708 <flashread>
8000240c:	24060006 	li	a2,6
80002410:	10400069 	beqz	v0,800025b8 <getmacandip+0x1dc>
80002414:	93a30010 	lbu	v1,16(sp)
	}


#if defined(RTL8198)

	if(tmpbuf[0] == '6')
80002418:	24020036 	li	v0,54
8000241c:	14620067 	bne	v1,v0,800025bc <getmacandip+0x1e0>
80002420:	8fbf002c 	lw	ra,44(sp)
	if(tmpbuf[0] == 'c')
#endif		
	{

		/*current setting*/
		memcpy(&len, &tmpbuf[4], 2);
80002424:	97a40014 	lhu	a0,20(sp)
80002428:	a7a40016 	sh	a0,22(sp)


		if(len > currSettingMaxLen)
8000242c:	3084ffff 	andi	a0,a0,0xffff
80002430:	28824001 	slti	v0,a0,16385
80002434:	10400061 	beqz	v0,800025bc <getmacandip+0x1e0>
80002438:	8fbf002c 	lw	ra,44(sp)
			return;

		/*alloc mem for reading current setting*/
		if(NULL==(buf=(unsigned char *)malloc(len)))
8000243c:	0c0018f1 	jal	800063c4 <malloc>
80002440:	00000000 	nop
80002444:	00409021 	move	s2,v0
80002448:	1040005b 	beqz	v0,800025b8 <getmacandip+0x1dc>
8000244c:	00409821 	move	s3,v0
			return;

		flashread(buf,CURRENT_SETTING_OFFSET+6,len);
80002450:	00402021 	move	a0,v0
80002454:	3c050002 	lui	a1,0x2
80002458:	34a5a006 	ori	a1,a1,0xa006
8000245c:	0c0011c2 	jal	80004708 <flashread>
80002460:	97a60016 	lhu	a2,22(sp)
		if(len != 0 && len <= currSettingMaxLen) {					
80002464:	97a20016 	lhu	v0,22(sp)
80002468:	10400051 	beqz	v0,800025b0 <getmacandip+0x1d4>
8000246c:	28434001 	slti	v1,v0,16385
80002470:	1060004f 	beqz	v1,800025b0 <getmacandip+0x1d4>
80002474:	00000000 	nop
			for (i=0;i<len;i++) 
80002478:	18400009 	blez	v0,800024a0 <getmacandip+0xc4>
8000247c:	02422021 	addu	a0,s2,v0
			free(buf);
	}
	return;
}

void getmacandip(unsigned char *mac,unsigned char *ip)
80002480:	00001021 	move	v0,zero
			return;

		flashread(buf,CURRENT_SETTING_OFFSET+6,len);
		if(len != 0 && len <= currSettingMaxLen) {					
			for (i=0;i<len;i++) 
				sum += buf[i];
80002484:	92430000 	lbu	v1,0(s2)
80002488:	00431021 	addu	v0,v0,v1
8000248c:	26520001 	addiu	s2,s2,1
		if(NULL==(buf=(unsigned char *)malloc(len)))
			return;

		flashread(buf,CURRENT_SETTING_OFFSET+6,len);
		if(len != 0 && len <= currSettingMaxLen) {					
			for (i=0;i<len;i++) 
80002490:	1644fffc 	bne	s2,a0,80002484 <getmacandip+0xa8>
80002494:	304200ff 	andi	v0,v0,0xff
				sum += buf[i];
		}
		else
			sum=1;

		if(0 == sum)
80002498:	14400045 	bnez	v0,800025b0 <getmacandip+0x1d4>
8000249c:	00000000 	nop
		{
			/*check sum ok*/
			memcpy(ip,buf+CURRENT_IP_ADDR_OFFSET,4);
800024a0:	8a620000 	lwl	v0,0(s3)
800024a4:	9a620003 	lwr	v0,3(s3)
800024a8:	aa020000 	swl	v0,0(s0)
800024ac:	ba020003 	swr	v0,3(s0)
			memcpy(mac,buf+CURRENT_ELAN_MAC_OFFSET,6);
800024b0:	26620015 	addiu	v0,s3,21
800024b4:	88430000 	lwl	v1,0(v0)
800024b8:	98430003 	lwr	v1,3(v0)
800024bc:	aa230000 	swl	v1,0(s1)
800024c0:	ba230003 	swr	v1,3(s1)
800024c4:	90430004 	lbu	v1,4(v0)
800024c8:	a2230004 	sb	v1,4(s1)
800024cc:	90420005 	lbu	v0,5(v0)
800024d0:	a2220005 	sb	v0,5(s1)

//printf("\n ip: %d.%d.%d.%d__%u\n",*ip,*(ip+1),*(ip+2),*(ip+3),__LINE__);
//printf("\n mac: %x-%x-%x-%x-%x-%x __%u\n",*mac,*(mac+1),*(mac+2),*(mac+3),*(mac+4),*(mac+5),__LINE__);

			
			if(memcmp(ip,"\x0\x0\x0\x0",4) && !(0xFF==ip[3] ||0x0==ip[3]))
800024d4:	02002021 	move	a0,s0
800024d8:	3c058001 	lui	a1,0x8001
800024dc:	24a5e268 	addiu	a1,a1,-7576
800024e0:	0c0019ed 	jal	800067b4 <memcmp>
800024e4:	24060004 	li	a2,4
800024e8:	1040002d 	beqz	v0,800025a0 <getmacandip+0x1c4>
800024ec:	00000000 	nop
800024f0:	92020003 	lbu	v0,3(s0)
800024f4:	2442ffff 	addiu	v0,v0,-1
800024f8:	304200ff 	andi	v0,v0,0xff
800024fc:	2c4200fe 	sltiu	v0,v0,254
80002500:	10400027 	beqz	v0,800025a0 <getmacandip+0x1c4>
80002504:	02202021 	move	a0,s1
			{
				/*normal ip*/
				if(memcmp(mac,"\x0\x0\x0\x0\x0\x0", 6) && !(mac[0] & 0x1))
80002508:	3c058001 	lui	a1,0x8001
8000250c:	24a5e260 	addiu	a1,a1,-7584
80002510:	0c0019ed 	jal	800067b4 <memcmp>
80002514:	24060006 	li	a2,6
80002518:	10400005 	beqz	v0,80002530 <getmacandip+0x154>
8000251c:	00000000 	nop
80002520:	92220000 	lbu	v0,0(s1)
80002524:	30420001 	andi	v0,v0,0x1
80002528:	10400004 	beqz	v0,8000253c <getmacandip+0x160>
8000252c:	02002021 	move	a0,s0

				}
				else
				{
					/*bad mac. user hw setting mac*/
					gethwmac(mac);
80002530:	0c0008a6 	jal	80002298 <gethwmac>
80002534:	02202021 	move	a0,s1
				}
				
				if(memcmp(ip,"\xC0\xA8\x0\x1",4) !=0)
80002538:	02002021 	move	a0,s0
8000253c:	3c058001 	lui	a1,0x8001
80002540:	24a5e270 	addiu	a1,a1,-7568
80002544:	0c0019ed 	jal	800067b4 <memcmp>
80002548:	24060004 	li	a2,4
8000254c:	1040000f 	beqz	v0,8000258c <getmacandip+0x1b0>
80002550:	3c028001 	lui	v0,0x8001
				{
					/* different ip with 192.168.0.1, MUST use different MAC */
					eth0_mac[0]=0x56;
80002554:	24030056 	li	v1,86
80002558:	a04329e0 	sb	v1,10720(v0)
					eth0_mac[1]=0xaa;
8000255c:	244229e0 	addiu	v0,v0,10720
80002560:	2403ffaa 	li	v1,-86
80002564:	a0430001 	sb	v1,1(v0)
					eth0_mac[2]=0xa5;
80002568:	2403ffa5 	li	v1,-91
8000256c:	a0430002 	sb	v1,2(v0)
					eth0_mac[3]=0x5a;
80002570:	2403005a 	li	v1,90
80002574:	a0430003 	sb	v1,3(v0)
					eth0_mac[4]=0x7d;
80002578:	2403007d 	li	v1,125
8000257c:	a0430004 	sb	v1,4(v0)
					eth0_mac[5]=0xe8;
80002580:	2403ffe8 	li	v1,-24
80002584:	0800096c 	j	800025b0 <getmacandip+0x1d4>
80002588:	a0430005 	sb	v1,5(v0)
				}
				else
				{
					/* same ip with 192.168.0.1, so use the same mac */
					gethwmac(eth0_mac);
8000258c:	3c048001 	lui	a0,0x8001
80002590:	0c0008a6 	jal	80002298 <gethwmac>
80002594:	248429e0 	addiu	a0,a0,10720
80002598:	0800096c 	j	800025b0 <getmacandip+0x1d4>
8000259c:	00000000 	nop
				}
			}
			else
			{
				/*use hard code 192.168.1.6*/
				memset(ip,0x0,4);
800025a0:	a2000000 	sb	zero,0(s0)
800025a4:	a2000001 	sb	zero,1(s0)
800025a8:	a2000002 	sb	zero,2(s0)
800025ac:	a2000003 	sb	zero,3(s0)
			}
		}
		if(buf)
			free(buf);
800025b0:	0c001922 	jal	80006488 <free>
800025b4:	02602021 	move	a0,s3
	}
}
800025b8:	8fbf002c 	lw	ra,44(sp)
800025bc:	8fb30028 	lw	s3,40(sp)
800025c0:	8fb20024 	lw	s2,36(sp)
800025c4:	8fb10020 	lw	s1,32(sp)
800025c8:	8fb0001c 	lw	s0,28(sp)
800025cc:	03e00008 	jr	ra
800025d0:	27bd0030 	addiu	sp,sp,48

800025d4 <eth_interrupt>:
static struct eth_private ETH[2];
static struct irqaction irq_eth15 = {eth_interrupt, 0, 15,"eth0", NULL, NULL};  
//--------------------------------------------------------------------------------------------

void eth_interrupt(int irq, void *dev_id, struct pt_regs *regs)
{
800025d4:	27bdffe0 	addiu	sp,sp,-32
800025d8:	afbf001c 	sw	ra,28(sp)
800025dc:	afb10018 	sw	s1,24(sp)
800025e0:	afb00014 	sw	s0,20(sp)
#ifdef CONFIG_NIC_LOOPBACK
	int i=0;
#endif
	int status=*(volatile Int32*)(0xb801002c);
800025e4:	3c02b801 	lui	v0,0xb801
800025e8:	3442002c 	ori	v0,v0,0x2c
800025ec:	8c430000 	lw	v1,0(v0)
	*(volatile Int32*)(0xb801002c)=status;
800025f0:	ac430000 	sw	v1,0(v0)
  	if (swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
800025f4:	3c028001 	lui	v0,0x8001
800025f8:	ac40319c 	sw	zero,12700(v0)
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
800025fc:	3c108001 	lui	s0,0x8001
80002600:	26103198 	addiu	s0,s0,12696
80002604:	08000988 	j	80002620 <eth_interrupt+0x4c>
80002608:	2451319c 	addiu	s1,v0,12700
				swNic_txDone();
		}
		else 
#endif		
		{
			swNic_txDone();
8000260c:	0c000d8e 	jal	80003638 <swNic_txDone>
80002610:	00000000 	nop
			kick_tftpd();  	
80002614:	0c0003b9 	jal	80000ee4 <kick_tftpd>
80002618:	00000000 	nop
			nic.packetlen=0;
8000261c:	ae000004 	sw	zero,4(s0)
 		kick_tftpd();  	
*/
//		printf("rx intterupt...\n");

	nic.packetlen=0;
	while(swNic_receive((void **)&nic.packet, &nic.packetlen)== 0) 
80002620:	02002021 	move	a0,s0
80002624:	0c000faf 	jal	80003ebc <swNic_receive>
80002628:	02202821 	move	a1,s1
8000262c:	1040fff7 	beqz	v0,8000260c <eth_interrupt+0x38>
80002630:	00000000 	nop
			kick_tftpd();  	
			nic.packetlen=0;
		}
	}

	swNic_txDone();
80002634:	0c000d8e 	jal	80003638 <swNic_txDone>
80002638:	00000000 	nop
}
8000263c:	8fbf001c 	lw	ra,28(sp)
80002640:	8fb10018 	lw	s1,24(sp)
80002644:	8fb00014 	lw	s0,20(sp)
80002648:	03e00008 	jr	ra
8000264c:	27bd0020 	addiu	sp,sp,32

80002650 <rtl8651_filterDbIndex>:
	#endif

	return SUCCESS;
}

uint32 rtl8651_filterDbIndex(ether_addr_t * macAddr,uint16 fid) {
80002650:	30a5ffff 	andi	a1,a1,0xffff
80002654:	90830001 	lbu	v1,1(a0)
80002658:	90820000 	lbu	v0,0(a0)
8000265c:	00621026 	xor	v0,v1,v0
80002660:	90830002 	lbu	v1,2(a0)
80002664:	00431026 	xor	v0,v0,v1
80002668:	90830003 	lbu	v1,3(a0)
8000266c:	00431026 	xor	v0,v0,v1
80002670:	90830004 	lbu	v1,4(a0)
80002674:	00431026 	xor	v0,v0,v1
80002678:	90830005 	lbu	v1,5(a0)
8000267c:	3c048001 	lui	a0,0x8001
80002680:	2484e280 	addiu	a0,a0,-7552
80002684:	00a42821 	addu	a1,a1,a0
80002688:	00431026 	xor	v0,v0,v1
8000268c:	90a30000 	lbu	v1,0(a1)
80002690:	00431026 	xor	v0,v0,v1
    return ( macAddr->octet[0] ^ macAddr->octet[1] ^
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}
80002694:	03e00008 	jr	ra
80002698:	304200ff 	andi	v0,v0,0xff

8000269c <FullAndSemiReset>:
#define __mdelay(x) { int i=x; while(i--) __udelay(1000, loops_per_jiffy * 100); }

void FullAndSemiReset( void )
{

	REG32(SIRR) |= FULL_RST;
8000269c:	3c02bb80 	lui	v0,0xbb80
800026a0:	34424204 	ori	v0,v0,0x4204
800026a4:	8c430000 	lw	v1,0(v0)
800026a8:	34630004 	ori	v1,v1,0x4
800026ac:	ac430000 	sw	v1,0(v0)
	__asm__("multu\t%2,%3"
		:"=h" (usecs), "=l" (lo)
		:"r" (usecs),"r" (lps));
	__delay(usecs);
#else
	lo = ((usecs * 0x000010c6) >> 12) * (lps >> 20);
800026b0:	3c028001 	lui	v0,0x8001
800026b4:	8c432f28 	lw	v1,12072(v0)
800026b8:	00031080 	sll	v0,v1,0x2
800026bc:	00031900 	sll	v1,v1,0x4
800026c0:	00431021 	addu	v0,v0,v1
800026c4:	00021880 	sll	v1,v0,0x2
800026c8:	00431021 	addu	v0,v0,v1
800026cc:	00021502 	srl	v0,v0,0x14
800026d0:	00022080 	sll	a0,v0,0x2
800026d4:	000219c0 	sll	v1,v0,0x7
800026d8:	00832021 	addu	a0,a0,v1
800026dc:	00821023 	subu	v0,a0,v0
800026e0:	000220c0 	sll	a0,v0,0x3
800026e4:	2402012b 	li	v0,299
	__mdelay(300);
800026e8:	2405ffff 	li	a1,-1
#include <linux/config.h>

extern __inline__ void
__delay(unsigned long loops)
{
	__asm__ __volatile__ (
800026ec:	00801821 	move	v1,a0
800026f0:	1460ffff 	bnez	v1,800026f0 <FullAndSemiReset+0x54>
800026f4:	2463ffff 	addiu	v1,v1,-1
800026f8:	2442ffff 	addiu	v0,v0,-1
800026fc:	1445fffc 	bne	v0,a1,800026f0 <FullAndSemiReset+0x54>
80002700:	00801821 	move	v1,a0

	REG32(SYS_CLK_MAG) &= ~CM_ACTIVE_SWCORE;
80002704:	3c02b800 	lui	v0,0xb800
80002708:	34420010 	ori	v0,v0,0x10
8000270c:	8c450000 	lw	a1,0(v0)
80002710:	2403f7ff 	li	v1,-2049
80002714:	00a31824 	and	v1,a1,v1
80002718:	ac430000 	sw	v1,0(v0)
8000271c:	2402012b 	li	v0,299
	__mdelay(300);
80002720:	2405ffff 	li	a1,-1
80002724:	00801821 	move	v1,a0
80002728:	1460ffff 	bnez	v1,80002728 <FullAndSemiReset+0x8c>
8000272c:	2463ffff 	addiu	v1,v1,-1
80002730:	2442ffff 	addiu	v0,v0,-1
80002734:	1445fffc 	bne	v0,a1,80002728 <FullAndSemiReset+0x8c>
80002738:	00801821 	move	v1,a0
	
	REG32(SYS_CLK_MAG) |= CM_ACTIVE_SWCORE;
8000273c:	3c02b800 	lui	v0,0xb800
80002740:	34420010 	ori	v0,v0,0x10
80002744:	8c430000 	lw	v1,0(v0)
80002748:	34630800 	ori	v1,v1,0x800
8000274c:	ac430000 	sw	v1,0(v0)
80002750:	24020031 	li	v0,49
	__mdelay(50);
80002754:	2405ffff 	li	a1,-1
80002758:	00801821 	move	v1,a0
8000275c:	1460ffff 	bnez	v1,8000275c <FullAndSemiReset+0xc0>
80002760:	2463ffff 	addiu	v1,v1,-1
80002764:	2442ffff 	addiu	v0,v0,-1
80002768:	1445fffc 	bne	v0,a1,8000275c <FullAndSemiReset+0xc0>
8000276c:	00801821 	move	v1,a0
}
80002770:	03e00008 	jr	ra
80002774:	00000000 	nop

80002778 <rtl8651_getAsicEthernetPHYReg>:

int32 rtl8651_getAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 *rData)
{
	uint32 status;
	
	WRITE_MEM32( MDCIOCR, COMMAND_READ | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) );
80002778:	00052c00 	sll	a1,a1,0x10
8000277c:	00042600 	sll	a0,a0,0x18
80002780:	00a42825 	or	a1,a1,a0
80002784:	3c02bb80 	lui	v0,0xbb80
80002788:	34424004 	ori	v0,v0,0x4004
8000278c:	ac450000 	sw	a1,0(v0)
#else
#if defined(CONFIG_RTL8198) && !defined(CONFIG_RTL8198C)
	REG32(GIMR_REG) = REG32(GIMR_REG) | (0x1<<8);    //add by jiawenjian
	delay_ms(10);   //wei add, for 8196C_test chip patch. mdio data read will delay 1 mdc clock.
#endif
	do { status = READ_MEM32( MDCIOSR ); } while ( ( status & STATUS ) != 0 );
80002790:	3c03bb80 	lui	v1,0xbb80
80002794:	34634008 	ori	v1,v1,0x4008
80002798:	8c620000 	lw	v0,0(v1)
8000279c:	0440fffe 	bltz	v0,80002798 <rtl8651_getAsicEthernetPHYReg+0x20>
800027a0:	3042ffff 	andi	v0,v0,0xffff
#endif

	status &= 0xffff;
	*rData = status;
800027a4:	acc20000 	sw	v0,0(a2)

	return SUCCESS;
}
800027a8:	03e00008 	jr	ra
800027ac:	00001021 	move	v0,zero

800027b0 <rtl8651_setAsicEthernetPHYReg>:
    //dprintf("\nSet enable_10M_power_saving01!\n");
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );*/

int32 rtl8651_setAsicEthernetPHYReg(uint32 phyId, uint32 regId, uint32 wData)
{
	WRITE_MEM32( MDCIOCR, COMMAND_WRITE | ( phyId << PHYADD_OFFSET ) | ( regId << REGADD_OFFSET ) | wData );
800027b0:	00042600 	sll	a0,a0,0x18
800027b4:	3c028000 	lui	v0,0x8000
800027b8:	00822025 	or	a0,a0,v0
800027bc:	00052c00 	sll	a1,a1,0x10
800027c0:	00852025 	or	a0,a0,a1
800027c4:	00862025 	or	a0,a0,a2
800027c8:	3c02bb80 	lui	v0,0xbb80
800027cc:	34424004 	ori	v0,v0,0x4004
800027d0:	ac440000 	sw	a0,0(v0)

#ifdef RTL865X_TEST
#else
	while( ( READ_MEM32( MDCIOSR ) & STATUS ) != 0 );		/* wait until command complete */
800027d4:	3c03bb80 	lui	v1,0xbb80
800027d8:	34634008 	ori	v1,v1,0x4008
800027dc:	8c620000 	lw	v0,0(v1)
800027e0:	0440fffe 	bltz	v0,800027dc <rtl8651_setAsicEthernetPHYReg+0x2c>
800027e4:	00001021 	move	v0,zero
#endif

	return SUCCESS;
}
800027e8:	03e00008 	jr	ra
800027ec:	00000000 	nop

800027f0 <rtl8651_restartAsicEthernetPHYNway>:

int32 rtl8651_restartAsicEthernetPHYNway(uint32 port, uint32 phyid)
{
800027f0:	27bdffe0 	addiu	sp,sp,-32
800027f4:	afbf001c 	sw	ra,28(sp)
800027f8:	afb00018 	sw	s0,24(sp)
800027fc:	00a08021 	move	s0,a1
	uint32 statCtrlReg0;

	/* read current PHY reg 0 */
	rtl8651_getAsicEthernetPHYReg( phyid, 0, &statCtrlReg0 );
80002800:	00a02021 	move	a0,a1
80002804:	00002821 	move	a1,zero
80002808:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000280c:	27a60010 	addiu	a2,sp,16

	/* enable 'restart Nway' bit */
	statCtrlReg0 |= RESTART_AUTONEGO;
80002810:	8fa60010 	lw	a2,16(sp)
80002814:	34c60200 	ori	a2,a2,0x200
80002818:	afa60010 	sw	a2,16(sp)

	/* write PHY reg 0 */
	rtl8651_setAsicEthernetPHYReg( phyid, 0, statCtrlReg0 );
8000281c:	02002021 	move	a0,s0
80002820:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002824:	00002821 	move	a1,zero

	return SUCCESS;
}
80002828:	00001021 	move	v0,zero
8000282c:	8fbf001c 	lw	ra,28(sp)
80002830:	8fb00018 	lw	s0,24(sp)
80002834:	03e00008 	jr	ra
80002838:	27bd0020 	addiu	sp,sp,32

8000283c <rtl8651_setAsicFlowControlRegister>:
	return SUCCESS;
}
#endif

int32 rtl8651_setAsicFlowControlRegister(uint32 port, uint32 enable, uint32 phyid)
{
8000283c:	27bdffd8 	addiu	sp,sp,-40
80002840:	afbf0024 	sw	ra,36(sp)
80002844:	afb20020 	sw	s2,32(sp)
80002848:	afb1001c 	sw	s1,28(sp)
8000284c:	afb00018 	sw	s0,24(sp)
80002850:	00808021 	move	s0,a0
80002854:	00a09021 	move	s2,a1
80002858:	00c08821 	move	s1,a2
	uint32 statCtrlReg4;

	/* Read */
	rtl8651_getAsicEthernetPHYReg( phyid, 4, &statCtrlReg4 );
8000285c:	00c02021 	move	a0,a2
80002860:	24050004 	li	a1,4
80002864:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002868:	27a60010 	addiu	a2,sp,16

	if ( enable && ( statCtrlReg4 & CAPABLE_PAUSE ) == 0 )
8000286c:	12400006 	beqz	s2,80002888 <rtl8651_setAsicFlowControlRegister+0x4c>
80002870:	8fa20010 	lw	v0,16(sp)
80002874:	30430400 	andi	v1,v0,0x400
80002878:	1460000f 	bnez	v1,800028b8 <rtl8651_setAsicFlowControlRegister+0x7c>
8000287c:	34420400 	ori	v0,v0,0x400
80002880:	08000a27 	j	8000289c <rtl8651_setAsicFlowControlRegister+0x60>
80002884:	afa20010 	sw	v0,16(sp)
	{
		statCtrlReg4 |= CAPABLE_PAUSE;		
	}
	else if ( enable == 0 && ( statCtrlReg4 & CAPABLE_PAUSE ) )
80002888:	30430400 	andi	v1,v0,0x400
8000288c:	1060000a 	beqz	v1,800028b8 <rtl8651_setAsicFlowControlRegister+0x7c>
80002890:	2403fbff 	li	v1,-1025
	{
		statCtrlReg4 &= ~CAPABLE_PAUSE;
80002894:	00431024 	and	v0,v0,v1
80002898:	afa20010 	sw	v0,16(sp)
	}
	else
		return SUCCESS;	/* The configuration does not change. Do nothing. */

	rtl8651_setAsicEthernetPHYReg( phyid, 4, statCtrlReg4 );
8000289c:	02202021 	move	a0,s1
800028a0:	24050004 	li	a1,4
800028a4:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800028a8:	8fa60010 	lw	a2,16(sp)
	
	/* restart N-way. */
	rtl8651_restartAsicEthernetPHYNway(port, phyid);
800028ac:	02002021 	move	a0,s0
800028b0:	0c0009fc 	jal	800027f0 <rtl8651_restartAsicEthernetPHYNway>
800028b4:	02202821 	move	a1,s1

	return SUCCESS;
}
800028b8:	00001021 	move	v0,zero
800028bc:	8fbf0024 	lw	ra,36(sp)
800028c0:	8fb20020 	lw	s2,32(sp)
800028c4:	8fb1001c 	lw	s1,28(sp)
800028c8:	8fb00018 	lw	s0,24(sp)
800028cc:	03e00008 	jr	ra
800028d0:	27bd0028 	addiu	sp,sp,40

800028d4 <Set_GPHYWB>:

//====================================================================

#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) || defined(CONFIG_RTL8198C)
void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
{
800028d4:	27bdffc8 	addiu	sp,sp,-56
800028d8:	afbf0034 	sw	ra,52(sp)
800028dc:	afb60030 	sw	s6,48(sp)
800028e0:	afb5002c 	sw	s5,44(sp)
800028e4:	afb40028 	sw	s4,40(sp)
800028e8:	afb30024 	sw	s3,36(sp)
800028ec:	afb20020 	sw	s2,32(sp)
800028f0:	afb1001c 	sw	s1,28(sp)
800028f4:	afb00018 	sw	s0,24(sp)
800028f8:	00a0a021 	move	s4,a1
800028fc:	00c09021 	move	s2,a2
80002900:	00e08821 	move	s1,a3
80002904:	8fb50048 	lw	s5,72(sp)

	unsigned int data=0;
	unsigned int wphyid=0;	//start
	unsigned int wphyid_end=1;   //end
	if(phyid==999)
80002908:	240203e7 	li	v0,999
8000290c:	14820004 	bne	a0,v0,80002920 <Set_GPHYWB+0x4c>
80002910:	afa00010 	sw	zero,16(sp)
80002914:	24130005 	li	s3,5
80002918:	08000a4c 	j	80002930 <Set_GPHYWB+0x5c>
8000291c:	00008021 	move	s0,zero
	{	wphyid=0;
		wphyid_end=5;    //total phyid=0~4
	}
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
80002920:	24930001 	addiu	s3,a0,1
	}

	for(; wphyid<wphyid_end; wphyid++)
80002924:	0093102b 	sltu	v0,a0,s3
80002928:	10400017 	beqz	v0,80002988 <Set_GPHYWB+0xb4>
8000292c:	00808021 	move	s0,a0
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
		
		if(mask!=0)
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
80002930:	27b60010 	addiu	s6,sp,16
	}

	for(; wphyid<wphyid_end; wphyid++)
	{
		//change page 
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, page  );
80002934:	02002021 	move	a0,s0
80002938:	2405001f 	li	a1,31
8000293c:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002940:	02803021 	move	a2,s4
		
		if(mask!=0)
80002944:	12200008 	beqz	s1,80002968 <Set_GPHYWB+0x94>
80002948:	02002021 	move	a0,s0
		{
			rtl8651_getAsicEthernetPHYReg( wphyid, reg, &data);
8000294c:	02402821 	move	a1,s2
80002950:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002954:	02c03021 	move	a2,s6
			data=data&mask;
80002958:	8fa20010 	lw	v0,16(sp)
8000295c:	00511024 	and	v0,v0,s1
80002960:	afa20010 	sw	v0,16(sp)
		}
		rtl8651_setAsicEthernetPHYReg( wphyid, reg, data|val  );
80002964:	02002021 	move	a0,s0
80002968:	02402821 	move	a1,s2
8000296c:	8fa60010 	lw	a2,16(sp)
80002970:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002974:	02a63025 	or	a2,s5,a2
	else
	{	wphyid=phyid;
		wphyid_end=phyid+1;
	}

	for(; wphyid<wphyid_end; wphyid++)
80002978:	26100001 	addiu	s0,s0,1
8000297c:	0213102b 	sltu	v0,s0,s3
80002980:	1440ffed 	bnez	v0,80002938 <Set_GPHYWB+0x64>
80002984:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( wphyid, 31, 0  );
		}
		*/
#endif		
	}
}
80002988:	8fbf0034 	lw	ra,52(sp)
8000298c:	8fb60030 	lw	s6,48(sp)
80002990:	8fb5002c 	lw	s5,44(sp)
80002994:	8fb40028 	lw	s4,40(sp)
80002998:	8fb30024 	lw	s3,36(sp)
8000299c:	8fb20020 	lw	s2,32(sp)
800029a0:	8fb1001c 	lw	s1,28(sp)
800029a4:	8fb00018 	lw	s0,24(sp)
800029a8:	03e00008 	jr	ra
800029ac:	27bd0038 	addiu	sp,sp,56

800029b0 <Get_P0_RxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
800029b0:	3c02b800 	lui	v0,0xb800
800029b4:	34420008 	ori	v0,v0,0x8
800029b8:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 26, RANG3);
	return val;

}
800029bc:	03e00008 	jr	ra
800029c0:	7c421680 	ext	v0,v0,0x1a,0x3

800029c4 <Get_P0_TxDelay>:
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
800029c4:	3c02b800 	lui	v0,0xb800
800029c8:	34420008 	ori	v0,v0,0x8
800029cc:	8c420000 	lw	v0,0(v0)
	unsigned int val=GET_BITVAL(v, 29, RANG1);
	return val;

}
800029d0:	03e00008 	jr	ra
800029d4:	7c420740 	ext	v0,v0,0x1d,0x1

800029d8 <Ado_RamCode_Efuse>:
    27, 0xb832,
    28, 0x0001,
};

int Ado_RamCode_Efuse(int phyport)
{
800029d8:	27bdffc8 	addiu	sp,sp,-56
800029dc:	afbf0034 	sw	ra,52(sp)
800029e0:	afb30030 	sw	s3,48(sp)
800029e4:	afb2002c 	sw	s2,44(sp)
800029e8:	afb10028 	sw	s1,40(sp)
800029ec:	afb00024 	sw	s0,36(sp)
	unsigned int readReg;
	int j , len;

	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xa46 );
800029f0:	00808021 	move	s0,a0
		rtl8651_getAsicEthernetPHYReg( phyport, 21, &readReg );
800029f4:	27b30018 	addiu	s3,sp,24
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0);

		if(((readReg >> 8) & 7) == 3)
800029f8:	24120003 	li	s2,3
	unsigned int readReg;
	int j , len;

	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xa46 );
800029fc:	02008821 	move	s1,s0
80002a00:	02002021 	move	a0,s0
80002a04:	2405001f 	li	a1,31
80002a08:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002a0c:	24060a46 	li	a2,2630
		rtl8651_getAsicEthernetPHYReg( phyport, 21, &readReg );
80002a10:	02002021 	move	a0,s0
80002a14:	24050015 	li	a1,21
80002a18:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002a1c:	02603021 	move	a2,s3
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0);
80002a20:	02002021 	move	a0,s0
80002a24:	2405001f 	li	a1,31
80002a28:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002a2c:	00003021 	move	a2,zero

		if(((readReg >> 8) & 7) == 3)
80002a30:	8fa20018 	lw	v0,24(sp)
80002a34:	7c421200 	ext	v0,v0,0x8,0x3
80002a38:	1452fff0 	bne	v0,s2,800029fc <Ado_RamCode_Efuse+0x24>
80002a3c:	24020010 	li	v0,16
			break;
	}

	Set_GPHYWB(phyport, 0xb82, 16, (0xffff & ~(1<<4)), (1<<4));
80002a40:	afa20010 	sw	v0,16(sp)
80002a44:	02002021 	move	a0,s0
80002a48:	24050b82 	li	a1,2946
80002a4c:	24060010 	li	a2,16
80002a50:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002a54:	3407ffef 	li	a3,0xffef

	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xb80 );
		rtl8651_getAsicEthernetPHYReg( phyport, 16, &readReg );
80002a58:	27b00018 	addiu	s0,sp,24

	Set_GPHYWB(phyport, 0xb82, 16, (0xffff & ~(1<<4)), (1<<4));

	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xb80 );
80002a5c:	02202021 	move	a0,s1
80002a60:	2405001f 	li	a1,31
80002a64:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002a68:	24060b80 	li	a2,2944
		rtl8651_getAsicEthernetPHYReg( phyport, 16, &readReg );
80002a6c:	02202021 	move	a0,s1
80002a70:	24050010 	li	a1,16
80002a74:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002a78:	02003021 	move	a2,s0
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0);
80002a7c:	02202021 	move	a0,s1
80002a80:	2405001f 	li	a1,31
80002a84:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002a88:	00003021 	move	a2,zero

		if(((readReg >> 6) & 1) == 1)
80002a8c:	8fa20018 	lw	v0,24(sp)
80002a90:	30420040 	andi	v0,v0,0x40
80002a94:	1040fff2 	beqz	v0,80002a60 <Ado_RamCode_Efuse+0x88>
80002a98:	02202021 	move	a0,s1
80002a9c:	3c108001 	lui	s0,0x8001
80002aa0:	2610ea24 	addiu	s0,s0,-5596
    28, 0xfffd,
    27, 0xb832,
    28, 0x0001,
};

int Ado_RamCode_Efuse(int phyport)
80002aa4:	3c128001 	lui	s2,0x8001
80002aa8:	2652eadc 	addiu	s2,s2,-5412
	}

	len = sizeof(phy_98c_ado)/sizeof(unsigned int);
	for(j=0;j<len;j=j+2)
	{
		Set_GPHYWB(phyport, 0, phy_98c_ado[j], 0, phy_98c_ado[j+1]);
80002aac:	8e060000 	lw	a2,0(s0)
80002ab0:	8e020004 	lw	v0,4(s0)
80002ab4:	afa20010 	sw	v0,16(sp)
80002ab8:	02202021 	move	a0,s1
80002abc:	00002821 	move	a1,zero
80002ac0:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002ac4:	00003821 	move	a3,zero
80002ac8:	26100008 	addiu	s0,s0,8
		if(((readReg >> 6) & 1) == 1)
			break;
	}

	len = sizeof(phy_98c_ado)/sizeof(unsigned int);
	for(j=0;j<len;j=j+2)
80002acc:	1612fff7 	bne	s0,s2,80002aac <Ado_RamCode_Efuse+0xd4>
80002ad0:	02202021 	move	a0,s1
	{
		Set_GPHYWB(phyport, 0, phy_98c_ado[j], 0, phy_98c_ado[j+1]);
	}

	Set_GPHYWB(phyport, 0xb82, 16, (0xffff & ~(1<<4)), (0<<4));
80002ad4:	afa00010 	sw	zero,16(sp)
80002ad8:	24050b82 	li	a1,2946
80002adc:	24060010 	li	a2,16
80002ae0:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002ae4:	3407ffef 	li	a3,0xffef
	return 0;
}
80002ae8:	00001021 	move	v0,zero
80002aec:	8fbf0034 	lw	ra,52(sp)
80002af0:	8fb30030 	lw	s3,48(sp)
80002af4:	8fb2002c 	lw	s2,44(sp)
80002af8:	8fb10028 	lw	s1,40(sp)
80002afc:	8fb00024 	lw	s0,36(sp)
80002b00:	03e00008 	jr	ra
80002b04:	27bd0038 	addiu	sp,sp,56

80002b08 <phy_ready>:
	27, 0x87f2,
	28, 0x000f,	
};  

int phy_ready(int phyport)
{
80002b08:	27bdffd0 	addiu	sp,sp,-48
80002b0c:	afbf002c 	sw	ra,44(sp)
80002b10:	afb40028 	sw	s4,40(sp)
80002b14:	afb30024 	sw	s3,36(sp)
80002b18:	afb20020 	sw	s2,32(sp)
80002b1c:	afb1001c 	sw	s1,28(sp)
80002b20:	afb00018 	sw	s0,24(sp)
80002b24:	00808021 	move	s0,a0
80002b28:	00008821 	move	s1,zero
	uint32 readReg, count=0;
	
	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xa46 );
		rtl8651_getAsicEthernetPHYReg( phyport, 21, &readReg );
80002b2c:	27b40010 	addiu	s4,sp,16
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0);

		if(((readReg >> 8) & 7) == 2)
80002b30:	24120002 	li	s2,2
			return 1;
		else if((count++) >= 10) 
80002b34:	2413000a 	li	s3,10
{
	uint32 readReg, count=0;
	
	while(1)
	{
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0xa46 );
80002b38:	02002021 	move	a0,s0
80002b3c:	2405001f 	li	a1,31
80002b40:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002b44:	24060a46 	li	a2,2630
		rtl8651_getAsicEthernetPHYReg( phyport, 21, &readReg );
80002b48:	02002021 	move	a0,s0
80002b4c:	24050015 	li	a1,21
80002b50:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002b54:	02803021 	move	a2,s4
		rtl8651_setAsicEthernetPHYReg( phyport, 31, 0);
80002b58:	02002021 	move	a0,s0
80002b5c:	2405001f 	li	a1,31
80002b60:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002b64:	00003021 	move	a2,zero

		if(((readReg >> 8) & 7) == 2)
80002b68:	8fa20010 	lw	v0,16(sp)
80002b6c:	7c421200 	ext	v0,v0,0x8,0x3
80002b70:	10520004 	beq	v0,s2,80002b84 <phy_ready+0x7c>
80002b74:	24020001 	li	v0,1
			return 1;
		else if((count++) >= 10) 
80002b78:	1633ffef 	bne	s1,s3,80002b38 <phy_ready+0x30>
80002b7c:	26310001 	addiu	s1,s1,1
80002b80:	00001021 	move	v0,zero
			return 0;
	}
}
80002b84:	8fbf002c 	lw	ra,44(sp)
80002b88:	8fb40028 	lw	s4,40(sp)
80002b8c:	8fb30024 	lw	s3,36(sp)
80002b90:	8fb20020 	lw	s2,32(sp)
80002b94:	8fb1001c 	lw	s1,28(sp)
80002b98:	8fb00018 	lw	s0,24(sp)
80002b9c:	03e00008 	jr	ra
80002ba0:	27bd0030 	addiu	sp,sp,48

80002ba4 <ado_refine>:
/*
 must do this adc refinement in phy_state 2 (page 0xa46, reg 21, bit 9-8),
 */
unsigned int efuse_value[5];
void ado_refine(void)
{
80002ba4:	27bdffb8 	addiu	sp,sp,-72
80002ba8:	afbf0044 	sw	ra,68(sp)
80002bac:	afbe0040 	sw	s8,64(sp)
80002bb0:	afb7003c 	sw	s7,60(sp)
80002bb4:	afb60038 	sw	s6,56(sp)
80002bb8:	afb50034 	sw	s5,52(sp)
80002bbc:	afb40030 	sw	s4,48(sp)
80002bc0:	afb3002c 	sw	s3,44(sp)
80002bc4:	afb20028 	sw	s2,40(sp)
80002bc8:	afb10024 	sw	s1,36(sp)
80002bcc:	afb00020 	sw	s0,32(sp)
	int i,phyport;
	int j, len;
	uint32 readReg;

	REG32(SYS_CLK_MAG) |= CM_ACTIVE_SWCORE;
80002bd0:	3c02b800 	lui	v0,0xb800
80002bd4:	34420010 	ori	v0,v0,0x10
80002bd8:	8c430000 	lw	v1,0(v0)
80002bdc:	34630800 	ori	v1,v1,0x800
80002be0:	ac430000 	sw	v1,0(v0)
80002be4:	3c02bb80 	lui	v0,0xbb80
80002be8:	34424104 	ori	v0,v0,0x4104

	for(i=0;i<5;i++) {
		REG32(PCRP0+i*4) |= (EnForceMode);
80002bec:	3c070200 	lui	a3,0x200
		efuse_value[i] = 0;
80002bf0:	3c068001 	lui	a2,0x8001
80002bf4:	24c64a04 	addiu	a2,a2,18948
80002bf8:	3c05447f 	lui	a1,0x447f
80002bfc:	34a5befc 	ori	a1,a1,0xbefc
	int j, len;
	uint32 readReg;

	REG32(SYS_CLK_MAG) |= CM_ACTIVE_SWCORE;

	for(i=0;i<5;i++) {
80002c00:	3c04bb80 	lui	a0,0xbb80
80002c04:	34844118 	ori	a0,a0,0x4118
		REG32(PCRP0+i*4) |= (EnForceMode);
80002c08:	8c430000 	lw	v1,0(v0)
80002c0c:	00671825 	or	v1,v1,a3
80002c10:	ac430000 	sw	v1,0(v0)
		efuse_value[i] = 0;
80002c14:	00c21821 	addu	v1,a2,v0
80002c18:	00651821 	addu	v1,v1,a1
80002c1c:	24420004 	addiu	v0,v0,4
	int j, len;
	uint32 readReg;

	REG32(SYS_CLK_MAG) |= CM_ACTIVE_SWCORE;

	for(i=0;i<5;i++) {
80002c20:	1444fff9 	bne	v0,a0,80002c08 <ado_refine+0x64>
80002c24:	ac600000 	sw	zero,0(v1)
		REG32(PCRP0+i*4) |= (EnForceMode);
		efuse_value[i] = 0;
	}
	
	if ((REG32(REVR) & 0xfff) > 0) {
80002c28:	3c02b800 	lui	v0,0xb800
80002c2c:	8c420000 	lw	v0,0(v0)
80002c30:	30420fff 	andi	v0,v0,0xfff
80002c34:	10400020 	beqz	v0,80002cb8 <ado_refine+0x114>
80002c38:	24040008 	li	a0,8
		REG32(EFUSE_TIMING_CONTROL)=0x030c174f; 
80002c3c:	3c02b800 	lui	v0,0xb800
80002c40:	3443070c 	ori	v1,v0,0x70c
80002c44:	3c04030c 	lui	a0,0x30c
80002c48:	3484174f 	ori	a0,a0,0x174f
80002c4c:	ac640000 	sw	a0,0(v1)
		REG32(EFUSE_CONFIG)=0x00040112; 
80002c50:	34420704 	ori	v0,v0,0x704
80002c54:	3c030004 	lui	v1,0x4
80002c58:	34630112 	ori	v1,v1,0x112
80002c5c:	ac430000 	sw	v1,0(v0)
80002c60:	3c058001 	lui	a1,0x8001
80002c64:	24a54a04 	addiu	a1,a1,18948
80002c68:	00002021 	move	a0,zero

		for(i=0; i<5; i++) {
			REG32(EFUSE_CONFIG) |= EFUSE_CFG_INT_STS;		/* clear efuse interrupt status bit */
80002c6c:	3c07b800 	lui	a3,0xb800
80002c70:	00401821 	move	v1,v0
			REG32(EFUSE_CMD) = i;
80002c74:	34e80700 	ori	t0,a3,0x700
			while( ( REG32(EFUSE_CONFIG) & EFUSE_CFG_INT_STS ) == 0 );		/* Wait efuse_interrupt */
			efuse_value[i] = REG32(EFUSE_RW_DATA);
80002c78:	34e70708 	ori	a3,a3,0x708
	
	if ((REG32(REVR) & 0xfff) > 0) {
		REG32(EFUSE_TIMING_CONTROL)=0x030c174f; 
		REG32(EFUSE_CONFIG)=0x00040112; 

		for(i=0; i<5; i++) {
80002c7c:	24060005 	li	a2,5
			REG32(EFUSE_CONFIG) |= EFUSE_CFG_INT_STS;		/* clear efuse interrupt status bit */
80002c80:	8c620000 	lw	v0,0(v1)
80002c84:	34420100 	ori	v0,v0,0x100
80002c88:	ac620000 	sw	v0,0(v1)
			REG32(EFUSE_CMD) = i;
80002c8c:	ad040000 	sw	a0,0(t0)
			while( ( REG32(EFUSE_CONFIG) & EFUSE_CFG_INT_STS ) == 0 );		/* Wait efuse_interrupt */
80002c90:	8c620000 	lw	v0,0(v1)
80002c94:	30420100 	andi	v0,v0,0x100
80002c98:	1040fffd 	beqz	v0,80002c90 <ado_refine+0xec>
80002c9c:	00000000 	nop
			efuse_value[i] = REG32(EFUSE_RW_DATA);
80002ca0:	8ce20000 	lw	v0,0(a3)
80002ca4:	aca20000 	sw	v0,0(a1)
	
	if ((REG32(REVR) & 0xfff) > 0) {
		REG32(EFUSE_TIMING_CONTROL)=0x030c174f; 
		REG32(EFUSE_CONFIG)=0x00040112; 

		for(i=0; i<5; i++) {
80002ca8:	24840001 	addiu	a0,a0,1
80002cac:	1486fff4 	bne	a0,a2,80002c80 <ado_refine+0xdc>
80002cb0:	24a50004 	addiu	a1,a1,4
			while( ( REG32(EFUSE_CONFIG) & EFUSE_CFG_INT_STS ) == 0 );		/* Wait efuse_interrupt */
			efuse_value[i] = REG32(EFUSE_RW_DATA);
		}
	}

	rtl8651_getAsicEthernetPHYReg( RTL8198C_PORT0_PHY_ID, 0, &readReg );
80002cb4:	24040008 	li	a0,8
80002cb8:	00002821 	move	a1,zero
80002cbc:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002cc0:	27a60018 	addiu	a2,sp,24
80002cc4:	3c148001 	lui	s4,0x8001
80002cc8:	26944a04 	addiu	s4,s4,18948
80002ccc:	00009821 	move	s3,zero
80002cd0:	24100008 	li	s0,8
		if (i==0)
			phyport = RTL8198C_PORT0_PHY_ID;
		else 
			phyport = i;
		
		rtl8651_getAsicEthernetPHYReg( phyport, 0, &readReg );
80002cd4:	27b60018 	addiu	s6,sp,24
			continue;
		
		if ((phy_ready(phyport)) == 0) // phy state=2, do it
			continue;
		
		if ((efuse_value[i] & 0x80))   // bit7=0, do it
80002cd8:	3c1e8001 	lui	s8,0x8001
80002cdc:	27dee284 	addiu	s8,s8,-7548

/*
 must do this adc refinement in phy_state 2 (page 0xa46, reg 21, bit 9-8),
 */
unsigned int efuse_value[5];
void ado_refine(void)
80002ce0:	3c128001 	lui	s2,0x8001
80002ce4:	2652ea24 	addiu	s2,s2,-5596
		}
	}

	rtl8651_getAsicEthernetPHYReg( RTL8198C_PORT0_PHY_ID, 0, &readReg );
	
	for(i=0;i<5;i++)
80002ce8:	24150005 	li	s5,5
	{
		if (i==0)
80002cec:	08000b3f 	j	80002cfc <ado_refine+0x158>
80002cf0:	24170008 	li	s7,8
80002cf4:	0273800b 	movn	s0,s3,s3
80002cf8:	26940004 	addiu	s4,s4,4
			phyport = RTL8198C_PORT0_PHY_ID;
		else 
			phyport = i;
		
		rtl8651_getAsicEthernetPHYReg( phyport, 0, &readReg );
80002cfc:	02008821 	move	s1,s0
80002d00:	02002021 	move	a0,s0
80002d04:	00002821 	move	a1,zero
80002d08:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002d0c:	02c03021 	move	a2,s6
		
		if((readReg & POWER_DOWN) == 0) // power_down=1, do it
80002d10:	8fa20018 	lw	v0,24(sp)
80002d14:	30420800 	andi	v0,v0,0x800
80002d18:	10400013 	beqz	v0,80002d68 <ado_refine+0x1c4>
80002d1c:	00000000 	nop
			continue;
		
		if ((phy_ready(phyport)) == 0) // phy state=2, do it
80002d20:	0c000ac2 	jal	80002b08 <phy_ready>
80002d24:	02002021 	move	a0,s0
80002d28:	1040000f 	beqz	v0,80002d68 <ado_refine+0x1c4>
80002d2c:	00000000 	nop
			continue;
		
		if ((efuse_value[i] & 0x80))   // bit7=0, do it
80002d30:	8e820000 	lw	v0,0(s4)
80002d34:	30420080 	andi	v0,v0,0x80
80002d38:	1440000b 	bnez	v0,80002d68 <ado_refine+0x1c4>
80002d3c:	03c08021 	move	s0,s8
			continue;

		len = sizeof(phy_ado_data)/sizeof(unsigned int);
		for(j=0;j<len;j=j+2)
		{
			Set_GPHYWB(phyport, 0, phy_ado_data[j], 0, phy_ado_data[j+1]);
80002d40:	8e060000 	lw	a2,0(s0)
80002d44:	8e020004 	lw	v0,4(s0)
80002d48:	afa20010 	sw	v0,16(sp)
80002d4c:	02202021 	move	a0,s1
80002d50:	00002821 	move	a1,zero
80002d54:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002d58:	00003821 	move	a3,zero
80002d5c:	26100008 	addiu	s0,s0,8
		
		if ((efuse_value[i] & 0x80))   // bit7=0, do it
			continue;

		len = sizeof(phy_ado_data)/sizeof(unsigned int);
		for(j=0;j<len;j=j+2)
80002d60:	1612fff7 	bne	s0,s2,80002d40 <ado_refine+0x19c>
80002d64:	00000000 	nop
		}
	}

	rtl8651_getAsicEthernetPHYReg( RTL8198C_PORT0_PHY_ID, 0, &readReg );
	
	for(i=0;i<5;i++)
80002d68:	26730001 	addiu	s3,s3,1
80002d6c:	1675ffe1 	bne	s3,s5,80002cf4 <ado_refine+0x150>
80002d70:	02e08021 	move	s0,s7
		for(j=0;j<len;j=j+2)
		{
			Set_GPHYWB(phyport, 0, phy_ado_data[j], 0, phy_ado_data[j+1]);
		}	
	}
}
80002d74:	8fbf0044 	lw	ra,68(sp)
80002d78:	8fbe0040 	lw	s8,64(sp)
80002d7c:	8fb7003c 	lw	s7,60(sp)
80002d80:	8fb60038 	lw	s6,56(sp)
80002d84:	8fb50034 	lw	s5,52(sp)
80002d88:	8fb40030 	lw	s4,48(sp)
80002d8c:	8fb3002c 	lw	s3,44(sp)
80002d90:	8fb20028 	lw	s2,40(sp)
80002d94:	8fb10024 	lw	s1,36(sp)
80002d98:	8fb00020 	lw	s0,32(sp)
80002d9c:	03e00008 	jr	ra
80002da0:	27bd0048 	addiu	sp,sp,72

80002da4 <Setting_RTL8198C_GPHY>:

int Setting_RTL8198C_GPHY(void)
{
80002da4:	27bdffc8 	addiu	sp,sp,-56
80002da8:	afbf0034 	sw	ra,52(sp)
80002dac:	afb40030 	sw	s4,48(sp)
80002db0:	afb3002c 	sw	s3,44(sp)
80002db4:	afb20028 	sw	s2,40(sp)
80002db8:	afb10024 	sw	s1,36(sp)
80002dbc:	afb00020 	sw	s0,32(sp)
80002dc0:	3c02bb80 	lui	v0,0xbb80
80002dc4:	34424104 	ori	v0,v0,0x4104
	int i, phyid;
	unsigned int data;

	for(i=0; i<5; i++)
		REG32(PCRP0+i*4) |= (EnForceMode);
80002dc8:	3c050200 	lui	a1,0x200
int Setting_RTL8198C_GPHY(void)
{
	int i, phyid;
	unsigned int data;

	for(i=0; i<5; i++)
80002dcc:	3c04bb80 	lui	a0,0xbb80
80002dd0:	34844118 	ori	a0,a0,0x4118
		REG32(PCRP0+i*4) |= (EnForceMode);
80002dd4:	8c430000 	lw	v1,0(v0)
80002dd8:	00651825 	or	v1,v1,a1
80002ddc:	ac430000 	sw	v1,0(v0)
80002de0:	24420004 	addiu	v0,v0,4
int Setting_RTL8198C_GPHY(void)
{
	int i, phyid;
	unsigned int data;

	for(i=0; i<5; i++)
80002de4:	1444fffb 	bne	v0,a0,80002dd4 <Setting_RTL8198C_GPHY+0x30>
80002de8:	24060012 	li	a2,18
		REG32(PCRP0+i*4) |= (EnForceMode);

	// to disable the PCS INT (GPHY PCS interrupt (MAC_INTRUPT  signal )). 
	Set_GPHYWB(999, 0xa42, 18, 0, 0);
80002dec:	afa00010 	sw	zero,16(sp)
80002df0:	240403e7 	li	a0,999
80002df4:	24050a42 	li	a1,2626
80002df8:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002dfc:	00003821 	move	a3,zero
80002e00:	24110001 	li	s1,1
80002e04:	00008021 	move	s0,zero
			phyid = RTL8198C_PORT0_PHY_ID;
		else 
			phyid = i;
		
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0xa42);
		rtl8651_getAsicEthernetPHYReg( phyid, 29, &data);		
80002e08:	08000b86 	j	80002e18 <Setting_RTL8198C_GPHY+0x74>
80002e0c:	27b20018 	addiu	s2,sp,24

	for(i=0; i<5; i++)
		REG32(PCRP0+i*4) |= (EnForceMode);

	// to disable the PCS INT (GPHY PCS interrupt (MAC_INTRUPT  signal )). 
	Set_GPHYWB(999, 0xa42, 18, 0, 0);
80002e10:	26100001 	addiu	s0,s0,1
80002e14:	26310001 	addiu	s1,s1,1

	// read to clear INT status. 
	for(i=0; i<5; i++) {
		if (i==0)
80002e18:	12000074 	beqz	s0,80002fec <Setting_RTL8198C_GPHY+0x248>
80002e1c:	24040008 	li	a0,8
			phyid = RTL8198C_PORT0_PHY_ID;
		else 
			phyid = i;
		
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0xa42);
80002e20:	02002021 	move	a0,s0
80002e24:	2405001f 	li	a1,31
80002e28:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002e2c:	24060a42 	li	a2,2626
		rtl8651_getAsicEthernetPHYReg( phyid, 29, &data);		
80002e30:	02002021 	move	a0,s0
80002e34:	2405001d 	li	a1,29
80002e38:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80002e3c:	02403021 	move	a2,s2
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0);
80002e40:	02002021 	move	a0,s0
80002e44:	2405001f 	li	a1,31
80002e48:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002e4c:	00003021 	move	a2,zero

	// to disable the PCS INT (GPHY PCS interrupt (MAC_INTRUPT  signal )). 
	Set_GPHYWB(999, 0xa42, 18, 0, 0);

	// read to clear INT status. 
	for(i=0; i<5; i++) {
80002e50:	2a220005 	slti	v0,s1,5
80002e54:	1440ffee 	bnez	v0,80002e10 <Setting_RTL8198C_GPHY+0x6c>
80002e58:	24022222 	li	v0,8738
		rtl8651_getAsicEthernetPHYReg( phyid, 29, &data);		
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0);
	}

	// fix MDI 10pf codedsp shift
	Set_GPHYWB(999, 0xBCD, 21, 0, 0x2222);	// codedsp register = 2
80002e5c:	afa20010 	sw	v0,16(sp)
80002e60:	240403e7 	li	a0,999
80002e64:	24050bcd 	li	a1,3021
80002e68:	24060015 	li	a2,21
80002e6c:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002e70:	00003821 	move	a3,zero
	Set_GPHYWB(999, 0, 27, 0, 0x8277);
80002e74:	34028277 	li	v0,0x8277
80002e78:	afa20010 	sw	v0,16(sp)
80002e7c:	240403e7 	li	a0,999
80002e80:	00002821 	move	a1,zero
80002e84:	2406001b 	li	a2,27
80002e88:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002e8c:	00003821 	move	a3,zero
	Set_GPHYWB(999, 0, 28, 0xffff - 0xff00, 0x02 << 8);	// uc codedsp = 2
80002e90:	24020200 	li	v0,512
80002e94:	afa20010 	sw	v0,16(sp)
80002e98:	240403e7 	li	a0,999
80002e9c:	00002821 	move	a1,zero
80002ea0:	2406001c 	li	a2,28
80002ea4:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002ea8:	240700ff 	li	a3,255

	// giga master sd_thd
	Set_GPHYWB(999, 0, 27, 0, 0x8101);
80002eac:	34028101 	li	v0,0x8101
80002eb0:	afa20010 	sw	v0,16(sp)
80002eb4:	240403e7 	li	a0,999
80002eb8:	00002821 	move	a1,zero
80002ebc:	2406001b 	li	a2,27
80002ec0:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002ec4:	00003821 	move	a3,zero
	Set_GPHYWB(999, 0, 28, 0, 0x4000);
80002ec8:	24024000 	li	v0,16384
80002ecc:	afa20010 	sw	v0,16(sp)
80002ed0:	240403e7 	li	a0,999
80002ed4:	00002821 	move	a1,zero
80002ed8:	2406001c 	li	a2,28
80002edc:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002ee0:	00003821 	move	a3,zero

	/* enlarge "Flow control DSC tolerance" from 36 pages to 48 pages
	    to prevent the hardware may drop incoming packets
	    after flow control triggered and Pause frame sent */
 	REG32(MACCR)= (REG32(MACCR) & ~CF_FCDSC_MASK) | (0x30 << CF_FCDSC_OFFSET);
80002ee4:	3c03bb80 	lui	v1,0xbb80
80002ee8:	34624000 	ori	v0,v1,0x4000
80002eec:	8c450000 	lw	a1,0(v0)
80002ef0:	2404f80f 	li	a0,-2033
80002ef4:	00a42024 	and	a0,a1,a0
80002ef8:	34840300 	ori	a0,a0,0x300
80002efc:	ac440000 	sw	a0,0(v0)

	/* set "System clock selection" to 100MHz 
		2'b00: 50MHz, 2'b01: 100MHz, 2'b10, 2'b11 reserved
	*/
 	REG32(MACCR)= (REG32(MACCR) & ~(CF_SYSCLK_SEL_MASK)) | (0x01 << CF_SYSCLK_SEL_OFFSET); 
80002f00:	8c450000 	lw	a1,0(v0)
80002f04:	2404cfff 	li	a0,-12289
80002f08:	00a42024 	and	a0,a1,a0
80002f0c:	34841000 	ori	a0,a0,0x1000
80002f10:	ac440000 	sw	a0,0(v0)

	/* set "Cport MAC clock selection with NIC interface" to lx_clk */
 	REG32(MACCTRL1) |= CF_CMAC_CLK_SEL;
80002f14:	34625100 	ori	v0,v1,0x5100
80002f18:	8c430000 	lw	v1,0(v0)
80002f1c:	34630001 	ori	v1,v1,0x1
80002f20:	ac430000 	sw	v1,0(v0)

	if ((REG32(REVR) & 0xfff) > 0) {
80002f24:	3c02b800 	lui	v0,0xb800
80002f28:	8c420000 	lw	v0,0(v0)
80002f2c:	30420fff 	andi	v0,v0,0xfff
80002f30:	14400008 	bnez	v0,80002f54 <Setting_RTL8198C_GPHY+0x1b0>
80002f34:	24140008 	li	s4,8
80002f38:	3c02bb80 	lui	v0,0xbb80
80002f3c:	34424104 	ori	v0,v0,0x4104
			}
		}
	}	

	for(i=0; i<5; i++)
		REG32(PCRP0+i*4) &= ~(EnForceMode);
80002f40:	3c05fdff 	lui	a1,0xfdff
80002f44:	34a5ffff 	ori	a1,a1,0xffff
				Set_GPHYWB(phyid, 0xbcf, 22, 0, (efuse_value[i]>>8)&0xffff);
			}
		}
	}	

	for(i=0; i<5; i++)
80002f48:	3c04bb80 	lui	a0,0xbb80
80002f4c:	08000bed 	j	80002fb4 <Setting_RTL8198C_GPHY+0x210>
80002f50:	34844118 	ori	a0,a0,0x4118
 	REG32(MACCR)= (REG32(MACCR) & ~(CF_SYSCLK_SEL_MASK)) | (0x01 << CF_SYSCLK_SEL_OFFSET); 

	/* set "Cport MAC clock selection with NIC interface" to lx_clk */
 	REG32(MACCTRL1) |= CF_CMAC_CLK_SEL;

	if ((REG32(REVR) & 0xfff) > 0) {
80002f54:	3c108001 	lui	s0,0x8001
80002f58:	26104a04 	addiu	s0,s0,18948
80002f5c:	00008821 	move	s1,zero
		for(i=0;i<5;i++)
80002f60:	24130005 	li	s3,5
		{
			if ((efuse_value[i] & 0x80)) { // bit7 != 0
80002f64:	8e020000 	lw	v0,0(s0)
80002f68:	30420080 	andi	v0,v0,0x80
80002f6c:	1040000c 	beqz	v0,80002fa0 <Setting_RTL8198C_GPHY+0x1fc>
80002f70:	02809021 	move	s2,s4
			 	// to backfill adc_ioffset
				if (i==0)
80002f74:	0231900b 	movn	s2,s1,s1
					phyid = RTL8198C_PORT0_PHY_ID;
				else 
					phyid = i;

				Ado_RamCode_Efuse(phyid);								
80002f78:	0c000a76 	jal	800029d8 <Ado_RamCode_Efuse>
80002f7c:	02402021 	move	a0,s2
				Set_GPHYWB(phyid, 0xbcf, 22, 0, (efuse_value[i]>>8)&0xffff);
80002f80:	8e020000 	lw	v0,0(s0)
80002f84:	7c427a00 	ext	v0,v0,0x8,0x10
80002f88:	afa20010 	sw	v0,16(sp)
80002f8c:	02402021 	move	a0,s2
80002f90:	24050bcf 	li	a1,3023
80002f94:	24060016 	li	a2,22
80002f98:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80002f9c:	00003821 	move	a3,zero

	/* set "Cport MAC clock selection with NIC interface" to lx_clk */
 	REG32(MACCTRL1) |= CF_CMAC_CLK_SEL;

	if ((REG32(REVR) & 0xfff) > 0) {
		for(i=0;i<5;i++)
80002fa0:	26310001 	addiu	s1,s1,1
80002fa4:	1633ffef 	bne	s1,s3,80002f64 <Setting_RTL8198C_GPHY+0x1c0>
80002fa8:	26100004 	addiu	s0,s0,4
 	REG32(MACCR)= (REG32(MACCR) & ~(CF_SYSCLK_SEL_MASK)) | (0x01 << CF_SYSCLK_SEL_OFFSET); 

	/* set "Cport MAC clock selection with NIC interface" to lx_clk */
 	REG32(MACCTRL1) |= CF_CMAC_CLK_SEL;

	if ((REG32(REVR) & 0xfff) > 0) {
80002fac:	08000bcf 	j	80002f3c <Setting_RTL8198C_GPHY+0x198>
80002fb0:	3c02bb80 	lui	v0,0xbb80
			}
		}
	}	

	for(i=0; i<5; i++)
		REG32(PCRP0+i*4) &= ~(EnForceMode);
80002fb4:	8c430000 	lw	v1,0(v0)
80002fb8:	00651824 	and	v1,v1,a1
80002fbc:	ac430000 	sw	v1,0(v0)
80002fc0:	24420004 	addiu	v0,v0,4
				Set_GPHYWB(phyid, 0xbcf, 22, 0, (efuse_value[i]>>8)&0xffff);
			}
		}
	}	

	for(i=0; i<5; i++)
80002fc4:	1444fffb 	bne	v0,a0,80002fb4 <Setting_RTL8198C_GPHY+0x210>
80002fc8:	8fbf0034 	lw	ra,52(sp)
		REG32(PCRP0+i*4) &= ~(EnForceMode);

	return 0;
}
80002fcc:	00001021 	move	v0,zero
80002fd0:	8fb40030 	lw	s4,48(sp)
80002fd4:	8fb3002c 	lw	s3,44(sp)
80002fd8:	8fb20028 	lw	s2,40(sp)
80002fdc:	8fb10024 	lw	s1,36(sp)
80002fe0:	8fb00020 	lw	s0,32(sp)
80002fe4:	03e00008 	jr	ra
80002fe8:	27bd0038 	addiu	sp,sp,56
		if (i==0)
			phyid = RTL8198C_PORT0_PHY_ID;
		else 
			phyid = i;
		
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0xa42);
80002fec:	2405001f 	li	a1,31
80002ff0:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80002ff4:	24060a42 	li	a2,2626
		rtl8651_getAsicEthernetPHYReg( phyid, 29, &data);		
80002ff8:	24040008 	li	a0,8
80002ffc:	2405001d 	li	a1,29
80003000:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80003004:	02403021 	move	a2,s2
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0);
80003008:	24040008 	li	a0,8
8000300c:	2405001f 	li	a1,31
80003010:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80003014:	00003021 	move	a2,zero

	for(i=0; i<5; i++)
		REG32(PCRP0+i*4) |= (EnForceMode);

	// to disable the PCS INT (GPHY PCS interrupt (MAC_INTRUPT  signal )). 
	Set_GPHYWB(999, 0xa42, 18, 0, 0);
80003018:	08000b85 	j	80002e14 <Setting_RTL8198C_GPHY+0x70>
8000301c:	26100001 	addiu	s0,s0,1

80003020 <set_phy_pwr_save>:



#define BIT(x)     (1 << (x))
void set_phy_pwr_save(int val)
{
80003020:	27bdffc8 	addiu	sp,sp,-56
80003024:	afbf0034 	sw	ra,52(sp)
80003028:	afb60030 	sw	s6,48(sp)
8000302c:	afb5002c 	sw	s5,44(sp)
80003030:	afb40028 	sw	s4,40(sp)
80003034:	afb30024 	sw	s3,36(sp)
80003038:	afb20020 	sw	s2,32(sp)
8000303c:	afb1001c 	sw	s1,28(sp)
80003040:	afb00018 	sw	s0,24(sp)
80003044:	00809021 	move	s2,a0
80003048:	00008021 	move	s0,zero
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
8000304c:	27b50010 	addiu	s5,sp,16

		if (val == 1)
80003050:	24130001 	li	s3,1
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
80003054:	3c16ffff 	lui	s6,0xffff
80003058:	36d67fff 	ori	s6,s6,0x7fff
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
8000305c:	24140005 	li	s4,5
	{
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);
80003060:	02002021 	move	a0,s0
80003064:	24050018 	li	a1,24
80003068:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000306c:	02a03021 	move	a2,s5

		if (val == 1)
80003070:	16530007 	bne	s2,s3,80003090 <set_phy_pwr_save+0x70>
80003074:	02002021 	move	a0,s0
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
80003078:	24050018 	li	a1,24
8000307c:	8fa60010 	lw	a2,16(sp)
80003080:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80003084:	34c68000 	ori	a2,a2,0x8000
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
80003088:	08000c29 	j	800030a4 <set_phy_pwr_save+0x84>
8000308c:	26100001 	addiu	s0,s0,1
		rtl8651_getAsicEthernetPHYReg( i, 24, &reg_val);

		if (val == 1)
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val | BIT(15)) );
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
80003090:	24050018 	li	a1,24
80003094:	8fa60010 	lw	a2,16(sp)
80003098:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000309c:	00d63024 	and	a2,a2,s6
void set_phy_pwr_save(int val)
{
	int i;
	uint32 reg_val;
	
	for(i=0; i<5; i++)
800030a0:	26100001 	addiu	s0,s0,1
800030a4:	1614ffef 	bne	s0,s4,80003064 <set_phy_pwr_save+0x44>
800030a8:	02002021 	move	a0,s0
		else 
			rtl8651_setAsicEthernetPHYReg( i, 24, (reg_val & (~BIT(15))) );
		
//		rtl8651_restartAsicEthernetPHYNway(i+1, i);							
			}
}
800030ac:	8fbf0034 	lw	ra,52(sp)
800030b0:	8fb60030 	lw	s6,48(sp)
800030b4:	8fb5002c 	lw	s5,44(sp)
800030b8:	8fb40028 	lw	s4,40(sp)
800030bc:	8fb30024 	lw	s3,36(sp)
800030c0:	8fb20020 	lw	s2,32(sp)
800030c4:	8fb1001c 	lw	s1,28(sp)
800030c8:	8fb00018 	lw	s0,24(sp)
800030cc:	03e00008 	jr	ra
800030d0:	27bd0038 	addiu	sp,sp,56

800030d4 <_rtl8651_clearSpecifiedAsicTable>:
#endif
#endif

//------------------------------------------------------------------------
static void _rtl8651_clearSpecifiedAsicTable(uint32 type, uint32 count) 
{
800030d4:	27bdffb8 	addiu	sp,sp,-72
800030d8:	afbf0044 	sw	ra,68(sp)
800030dc:	afb30040 	sw	s3,64(sp)
800030e0:	afb2003c 	sw	s2,60(sp)
800030e4:	afb10038 	sw	s1,56(sp)
800030e8:	afb00034 	sw	s0,52(sp)
800030ec:	00809821 	move	s3,a0
800030f0:	00a09021 	move	s2,a1
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
800030f4:	afa00010 	sw	zero,16(sp)
800030f8:	afa00014 	sw	zero,20(sp)
800030fc:	afa00018 	sw	zero,24(sp)
80003100:	afa0001c 	sw	zero,28(sp)
80003104:	afa00020 	sw	zero,32(sp)
80003108:	afa00024 	sw	zero,36(sp)
8000310c:	afa00028 	sw	zero,40(sp)
	for (idx=0; idx<count; idx++)// Write into hardware
80003110:	10a0000b 	beqz	a1,80003140 <_rtl8651_clearSpecifiedAsicTable+0x6c>
80003114:	afa0002c 	sw	zero,44(sp)
80003118:	00008021 	move	s0,zero
		swTable_addEntry(type, idx, &entry);
8000311c:	27b10010 	addiu	s1,sp,16
80003120:	02602021 	move	a0,s3
80003124:	02002821 	move	a1,s0
80003128:	0c00106e 	jal	800041b8 <swTable_addEntry>
8000312c:	02203021 	move	a2,s1
{
	struct { uint32 _content[8]; } entry;
	uint32 idx;
	
	bzero(&entry, sizeof(entry));
	for (idx=0; idx<count; idx++)// Write into hardware
80003130:	26100001 	addiu	s0,s0,1
80003134:	0212102b 	sltu	v0,s0,s2
80003138:	1440fffa 	bnez	v0,80003124 <_rtl8651_clearSpecifiedAsicTable+0x50>
8000313c:	02602021 	move	a0,s3
		swTable_addEntry(type, idx, &entry);
}
80003140:	8fbf0044 	lw	ra,68(sp)
80003144:	8fb30040 	lw	s3,64(sp)
80003148:	8fb2003c 	lw	s2,60(sp)
8000314c:	8fb10038 	lw	s1,56(sp)
80003150:	8fb00034 	lw	s0,52(sp)
80003154:	03e00008 	jr	ra
80003158:	27bd0048 	addiu	sp,sp,72

8000315c <rtl8651_setAsicL2Table>:
                    macAddr->octet[2] ^ macAddr->octet[3] ^
                    macAddr->octet[4] ^ macAddr->octet[5] ^fidHashTable[fid]) & 0xFF;
}

static int32 rtl8651_setAsicL2Table(ether_addr_t	*mac, uint32 column)
{
8000315c:	27bdffc0 	addiu	sp,sp,-64
80003160:	afbf003c 	sw	ra,60(sp)
80003164:	afb20038 	sw	s2,56(sp)
80003168:	afb10034 	sw	s1,52(sp)
8000316c:	afb00030 	sw	s0,48(sp)
80003170:	00809021 	move	s2,a0
80003174:	00a08821 	move	s1,a1
	rtl865xc_tblAsic_l2Table_t entry;
	uint32	row;

	row = rtl8651_filterDbIndex(mac, 0);
80003178:	0c000994 	jal	80002650 <rtl8651_filterDbIndex>
8000317c:	00002821 	move	a1,zero
80003180:	00408021 	move	s0,v0
	if((row >= RTL8651_L2TBL_ROW) || (column >= RTL8651_L2TBL_COLUMN))
80003184:	2c420100 	sltiu	v0,v0,256
80003188:	1040005c 	beqz	v0,800032fc <rtl8651_setAsicL2Table+0x1a0>
8000318c:	2402ffff 	li	v0,-1
80003190:	2e220004 	sltiu	v0,s1,4
80003194:	10400059 	beqz	v0,800032fc <rtl8651_setAsicL2Table+0x1a0>
80003198:	2402ffff 	li	v0,-1
		return FAILED;
	if(mac->octet[5] != ((row^(fidHashTable[0])^ mac->octet[0] ^ mac->octet[1] ^ mac->octet[2] ^ mac->octet[3] ^ mac->octet[4] ) & 0xff))
8000319c:	92430005 	lbu	v1,5(s2)
800031a0:	92440001 	lbu	a0,1(s2)
800031a4:	92420000 	lbu	v0,0(s2)
800031a8:	00822026 	xor	a0,a0,v0
800031ac:	92420002 	lbu	v0,2(s2)
800031b0:	00822026 	xor	a0,a0,v0
800031b4:	92420003 	lbu	v0,3(s2)
800031b8:	00822026 	xor	a0,a0,v0
800031bc:	92420004 	lbu	v0,4(s2)
800031c0:	00821026 	xor	v0,a0,v0
800031c4:	00501026 	xor	v0,v0,s0
800031c8:	304200ff 	andi	v0,v0,0xff
800031cc:	1462004b 	bne	v1,v0,800032fc <rtl8651_setAsicL2Table+0x1a0>
800031d0:	2402ffff 	li	v0,-1
		return FAILED;

	memset(&entry, 0,sizeof(entry));
800031d4:	27a40010 	addiu	a0,sp,16
800031d8:	00002821 	move	a1,zero
800031dc:	0c0019d9 	jal	80006764 <memset>
800031e0:	24060020 	li	a2,32
	entry.mac47_40 = mac->octet[0];
800031e4:	92420000 	lbu	v0,0(s2)
800031e8:	a3a20017 	sb	v0,23(sp)
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
800031ec:	92420001 	lbu	v0,1(s2)
800031f0:	92430002 	lbu	v1,2(s2)
800031f4:	00021200 	sll	v0,v0,0x8
800031f8:	00431025 	or	v0,v0,v1
800031fc:	a7a20010 	sh	v0,16(sp)
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
80003200:	92460003 	lbu	a2,3(s2)
80003204:	92450004 	lbu	a1,4(s2)
static int32 _rtl8651_forceAddAsicEntry(uint32 tableType, uint32 eidx, void *entryContent_P) {

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{	/* No need to stop HW table lookup process */
		WRITE_MEM32(SWTCR0,EN_STOP_TLU|READ_MEM32(SWTCR0));
80003208:	3c02bb80 	lui	v0,0xbb80
8000320c:	34424418 	ori	v0,v0,0x4418
80003210:	8c440000 	lw	a0,0(v0)
80003214:	3c030004 	lui	v1,0x4
80003218:	00831825 	or	v1,a0,v1
8000321c:	ac430000 	sw	v1,0(v0)
		while ( (READ_MEM32(SWTCR0) & STOP_TLU_READY)==0);
80003220:	00402021 	move	a0,v0
80003224:	3c030008 	lui	v1,0x8
80003228:	8c820000 	lw	v0,0(a0)
8000322c:	00431024 	and	v0,v0,v1
80003230:	1040fffd 	beqz	v0,80003228 <rtl8651_setAsicL2Table+0xcc>
80003234:	00000000 	nop

static void _rtl8651_asicTableAccessForward(uint32 tableType, uint32 eidx, void *entryContent_P) {
	ASSERT_CSP(entryContent_P);


	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
80003238:	3c03bb80 	lui	v1,0xbb80
8000323c:	34634d00 	ori	v1,v1,0x4d00
80003240:	8c620000 	lw	v0,0(v1)
80003244:	30420001 	andi	v0,v0,0x1
80003248:	1440fffd 	bnez	v0,80003240 <rtl8651_setAsicL2Table+0xe4>
8000324c:	00061200 	sll	v0,a2,0x8
		return FAILED;

	memset(&entry, 0,sizeof(entry));
	entry.mac47_40 = mac->octet[0];
	entry.mac39_24 = (mac->octet[1] << 8) | mac->octet[2];
	entry.mac23_8 = (mac->octet[3] << 8) | mac->octet[4];
80003250:	00a21025 	or	v0,a1,v0
80003254:	a7a20012 	sh	v0,18(sp)

//	entry.extMemberPort = 0;   
	entry.memberPort = 7;
80003258:	8fa30014 	lw	v1,20(sp)
8000325c:	24020007 	li	v0,7
80003260:	7c436a04 	ins	v1,v0,0x8,0x6
	entry.toCPU = 1;
80003264:	24020001 	li	v0,1
80003268:	7c438c44 	ins	v1,v0,0x11,0x1
	entry.isStatic = 1;
8000326c:	7c439484 	ins	v1,v0,0x12,0x1
//	entry.nxtHostFlag = 1;

	/* RTL865xC: modification of age from ( 2 -> 3 -> 1 -> 0 ) to ( 3 -> 2 -> 1 -> 0 ). modification of granularity 100 sec to 150 sec. */
	entry.agingTime = 0x03;
80003270:	24040003 	li	a0,3
80003274:	7c83a4c4 	ins	v1,a0,0x13,0x2
	
//	entry.srcBlock = 0;
	entry.fid=0;
80003278:	7c03c5c4 	ins	v1,zero,0x17,0x2
	entry.auth=1;
8000327c:	7c43ce44 	ins	v1,v0,0x19,0x1
80003280:	afa30014 	sw	v1,20(sp)
	{
		register uint32 index;

		for( index = 0; index < _rtl8651_asicTableSize[tableType]; index++ )
		{
			WRITE_MEM32(TCR0+(index<<2), *((uint32 *)entryContent_P + index));
80003284:	27a30010 	addiu	v1,sp,16
80003288:	8c650000 	lw	a1,0(v1)
8000328c:	3c02bb80 	lui	v0,0xbb80
80003290:	34444d20 	ori	a0,v0,0x4d20
80003294:	ac850000 	sw	a1,0(a0)
80003298:	8c640004 	lw	a0,4(v1)
8000329c:	34434d24 	ori	v1,v0,0x4d24
800032a0:	ac640000 	sw	a0,0(v1)
	WRITE_MEM32(TCR4, *((uint32 *)entryContent_P + 4));
	WRITE_MEM32(TCR5, *((uint32 *)entryContent_P + 5));
	WRITE_MEM32(TCR6, *((uint32 *)entryContent_P + 6));
	WRITE_MEM32(TCR7, *((uint32 *)entryContent_P + 7));
#endif	
	WRITE_MEM32(SWTAA, ((uint32) rtl8651_asicTableAccessAddrBase(tableType) + eidx * RTL8651_ASICTABLE_ENTRY_LENGTH));//Fill address
800032a4:	00102080 	sll	a0,s0,0x2
800032a8:	00912025 	or	a0,a0,s1
800032ac:	00042140 	sll	a0,a0,0x5
800032b0:	3c03bb00 	lui	v1,0xbb00
800032b4:	00832021 	addu	a0,a0,v1
800032b8:	34434d08 	ori	v1,v0,0x4d08
800032bc:	ac640000 	sw	a0,0(v1)
	}
	#endif

	_rtl8651_asicTableAccessForward(tableType, eidx, entryContent_P);

 	WRITE_MEM32(SWTACR, ACTION_START | CMD_FORCE);//Activate add command
800032c0:	34424d00 	ori	v0,v0,0x4d00
800032c4:	24030009 	li	v1,9
800032c8:	ac430000 	sw	v1,0(v0)
	while ( (READ_MEM32(SWTACR) & ACTION_MASK) != ACTION_DONE );//Wait for command done
800032cc:	00401821 	move	v1,v0
800032d0:	8c620000 	lw	v0,0(v1)
800032d4:	30420001 	andi	v0,v0,0x1
800032d8:	1440fffd 	bnez	v0,800032d0 <rtl8651_setAsicL2Table+0x174>
800032dc:	3c02bb80 	lui	v0,0xbb80

	#ifdef RTL865XC_ASIC_WRITE_PROTECTION
	if (RTL865X_TLU_BUG_FIXED)	/* No need to stop HW table lookup process */
	{
		WRITE_MEM32(SWTCR0,~EN_STOP_TLU&READ_MEM32(SWTCR0));
800032e0:	34424418 	ori	v0,v0,0x4418
800032e4:	8c440000 	lw	a0,0(v0)
800032e8:	3c03fffb 	lui	v1,0xfffb
800032ec:	3463ffff 	ori	v1,v1,0xffff
800032f0:	00831824 	and	v1,a0,v1
800032f4:	ac430000 	sw	v1,0(v0)
800032f8:	00001021 	move	v0,zero
//	entry.srcBlock = 0;
	entry.fid=0;
	entry.auth=1;

	return _rtl8651_forceAddAsicEntry(TYPE_L2_SWITCH_TABLE, row<<2 | column, &entry);
}
800032fc:	8fbf003c 	lw	ra,60(sp)
80003300:	8fb20038 	lw	s2,56(sp)
80003304:	8fb10034 	lw	s1,52(sp)
80003308:	8fb00030 	lw	s0,48(sp)
8000330c:	03e00008 	jr	ra
80003310:	27bd0040 	addiu	sp,sp,64

80003314 <swCore_init>:
	return 0;
}
#endif

int32 swCore_init()
{
80003314:	27bdffe0 	addiu	sp,sp,-32
80003318:	afbf001c 	sw	ra,28(sp)
8000331c:	afb10018 	sw	s1,24(sp)
80003320:	afb00014 	sw	s0,20(sp)
	#define REG32_ANDOR(x,y,z)   (REG32(x)=(REG32(x)& (y))|(z))

	int port;

#ifdef CONFIG_RTL8198C
	ado_refine();
80003324:	0c000ae9 	jal	80002ba4 <ado_refine>
80003328:	3c10bb80 	lui	s0,0xbb80
#endif

	/* Full reset and semreset */
	FullAndSemiReset();
8000332c:	0c0009a7 	jal	8000269c <FullAndSemiReset>
80003330:	00000000 	nop
	
#ifdef CONFIG_RTL8198C
	Setting_RTL8198C_GPHY();
80003334:	0c000b69 	jal	80002da4 <Setting_RTL8198C_GPHY>
80003338:	00000000 	nop
	}
#endif		

	/* rtl8651_clearAsicAllTable */
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E) ||defined(CONFIG_RTL8881A)
	REG32(MEMCR) = 0;
8000333c:	36024234 	ori	v0,s0,0x4234
80003340:	ac400000 	sw	zero,0(v0)
	REG32(MEMCR) = 0x7f;
80003344:	2403007f 	li	v1,127
80003348:	ac430000 	sw	v1,0(v0)
	_rtl8651_clearSpecifiedAsicTable(TYPE_MULTICAST_TABLE, RTL8651_IPMULTICASTTBL_SIZE);
8000334c:	24040003 	li	a0,3
80003350:	0c000c35 	jal	800030d4 <_rtl8651_clearSpecifiedAsicTable>
80003354:	24050040 	li	a1,64
	_rtl8651_clearSpecifiedAsicTable(TYPE_NETINTERFACE_TABLE, RTL865XC_NETINTERFACE_NUMBER);
80003358:	24040004 	li	a0,4
8000335c:	0c000c35 	jal	800030d4 <_rtl8651_clearSpecifiedAsicTable>
80003360:	24050008 	li	a1,8

#else  //8198, not NFBI
		//anson add
		//REG32(0xbb804300)= 0x00055500;

		REG32(PCRP0) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80003364:	36034104 	ori	v1,s0,0x4104
80003368:	8c640000 	lw	a0,0(v1)
8000336c:	2402fff7 	li	v0,-9
80003370:	00822024 	and	a0,a0,v0
80003374:	ac640000 	sw	a0,0(v1)
                REG32(PCRP1) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80003378:	36074108 	ori	a3,s0,0x4108
8000337c:	8ce40000 	lw	a0,0(a3)
80003380:	00822024 	and	a0,a0,v0
80003384:	ace40000 	sw	a0,0(a3)
                REG32(PCRP2) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80003388:	3606410c 	ori	a2,s0,0x410c
8000338c:	8cc40000 	lw	a0,0(a2)
80003390:	00822024 	and	a0,a0,v0
80003394:	acc40000 	sw	a0,0(a2)
                REG32(PCRP3) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
80003398:	36054110 	ori	a1,s0,0x4110
8000339c:	8ca40000 	lw	a0,0(a1)
800033a0:	00822024 	and	a0,a0,v0
800033a4:	aca40000 	sw	a0,0(a1)
                REG32(PCRP4) &= (0xFFFFFFFF-(0x00000000|MacSwReset));
800033a8:	36044114 	ori	a0,s0,0x4114
800033ac:	8c880000 	lw	t0,0(a0)
800033b0:	01021024 	and	v0,t0,v0
800033b4:	ac820000 	sw	v0,0(a0)

//		REG32(PCRP0) = REG32(PCRP0) | (0 << ExtPHYID_OFFSET) | AcptMaxLen_16K | EnablePHYIf | MacSwReset;   //move to below

		REG32(PCRP1) = REG32(PCRP1) | (1 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
800033b8:	8ce80000 	lw	t0,0(a3)
800033bc:	3c020400 	lui	v0,0x400
800033c0:	34420009 	ori	v0,v0,0x9
800033c4:	01021025 	or	v0,t0,v0
800033c8:	ace20000 	sw	v0,0(a3)
		REG32(PCRP2) = REG32(PCRP2) | (2 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
800033cc:	8cc70000 	lw	a3,0(a2)
800033d0:	3c020800 	lui	v0,0x800
800033d4:	34420009 	ori	v0,v0,0x9
800033d8:	00e21025 	or	v0,a3,v0
800033dc:	acc20000 	sw	v0,0(a2)
		REG32(PCRP3) = REG32(PCRP3) | (3 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
800033e0:	8ca60000 	lw	a2,0(a1)
800033e4:	3c020c00 	lui	v0,0xc00
800033e8:	34420009 	ori	v0,v0,0x9
800033ec:	00c21025 	or	v0,a2,v0
800033f0:	aca20000 	sw	v0,0(a1)
		REG32(PCRP4) = REG32(PCRP4) | (4 << ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;
800033f4:	8c850000 	lw	a1,0(a0)
800033f8:	3c021000 	lui	v0,0x1000
800033fc:	34420009 	ori	v0,v0,0x9
80003400:	00a21025 	or	v0,a1,v0
80003404:	ac820000 	sw	v0,0(a0)
			PHYID= 0x10	: 0x011	:	0x01
		*/
		REG32_ANDOR(0xbb804050, ~(0x1f<<0), 0x11<<0); 
		REG32(PCRP0) |=  (0<< ExtPHYID_OFFSET) |  EnablePHYIf | MacSwReset;	//emabedded
#else
		REG32(PCRP0) |=  (0 << ExtPHYID_OFFSET) | EnablePHYIf | MacSwReset;	//emabedded
80003408:	8c620000 	lw	v0,0(v1)
8000340c:	34420009 	ori	v0,v0,0x9
80003410:	ac620000 	sw	v0,0(v1)
	
#endif


	/* Set PVID of all ports to 8 */
	REG32(PVCR0) = (0x8 << 16) | 0x8;
80003414:	36034a08 	ori	v1,s0,0x4a08
80003418:	3c020008 	lui	v0,0x8
8000341c:	34420008 	ori	v0,v0,0x8
80003420:	ac620000 	sw	v0,0(v1)
	REG32(PVCR1) = (0x8 << 16) | 0x8;
80003424:	36034a0c 	ori	v1,s0,0x4a0c
80003428:	ac620000 	sw	v0,0(v1)
	REG32(PVCR2) = (0x8 << 16) | 0x8;
8000342c:	36034a10 	ori	v1,s0,0x4a10
80003430:	ac620000 	sw	v0,0(v1)
	REG32(PVCR3) = (0x8 << 16) | 0x8;
80003434:	36034a14 	ori	v1,s0,0x4a14
80003438:	ac620000 	sw	v0,0(v1)

	
	/* Enable L2 lookup engine and spanning tree functionality */
	// REG32(MSCR) = EN_L2 | EN_L3 | EN_L4 | EN_IN_ACL;
	REG32(MSCR) = EN_L2;
8000343c:	36024410 	ori	v0,s0,0x4410
80003440:	24030001 	li	v1,1
80003444:	ac430000 	sw	v1,0(v0)
	REG32(QNUMCR) = P0QNum_1 | P1QNum_1 | P2QNum_1 | P3QNum_1 | P4QNum_1;
80003448:	36024754 	ori	v0,s0,0x4754
8000344c:	24031249 	li	v1,4681
80003450:	ac430000 	sw	v1,0(v0)

	/* Start normal TX and RX */
	REG32(SIRR) |= TRXRDY;
80003454:	36024204 	ori	v0,s0,0x4204
80003458:	8c430000 	lw	v1,0(v0)
8000345c:	34630001 	ori	v1,v1,0x1
80003460:	ac430000 	sw	v1,0(v0)
#if defined(CONFIG_RTL8198C)

	#ifdef CONFIG_USING_JTAG
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF));  //LED0~LED4
	#else
	REG32(PIN_MUX_SEL3) = (REG32(PIN_MUX_SEL3) & ~ (0x7FFF)) | ((1<<0) | (1<<3) | (1<<6) | (1<<9) | (1<<12));  //LED0~LED4
80003464:	3c02b800 	lui	v0,0xb800
80003468:	34420108 	ori	v0,v0,0x108
8000346c:	8c440000 	lw	a0,0(v0)
80003470:	24038000 	li	v1,-32768
80003474:	00831824 	and	v1,a0,v1
80003478:	34631249 	ori	v1,v1,0x1249
8000347c:	ac430000 	sw	v1,0(v0)
	#endif

	REG32(LEDCR0) = (REG32(LEDCR0) & ~ LEDTOPOLOGY_MASK) |LEDMODE_DIRECT;
80003480:	36024300 	ori	v0,s0,0x4300
80003484:	8c440000 	lw	a0,0(v0)
80003488:	3c03ffcf 	lui	v1,0xffcf
8000348c:	3463ffff 	ori	v1,v1,0xffff
80003490:	00831824 	and	v1,a0,v1
80003494:	3c040020 	lui	a0,0x20
80003498:	00641825 	or	v1,v1,a0
8000349c:	ac430000 	sw	v1,0(v0)
	REG32(DIRECTLCR) = (REG32(DIRECTLCR) & ~ LEDONSCALEP0_MASK) |(7<<LEDONSCALEP0_OFFSET);
800034a0:	36104314 	ori	s0,s0,0x4314
800034a4:	8e030000 	lw	v1,0(s0)
800034a8:	3c020007 	lui	v0,0x7
800034ac:	00621025 	or	v0,v1,v0
800034b0:	ae020000 	sw	v0,0(s0)
800034b4:	00008021 	move	s0,zero
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
800034b8:	24110006 	li	s1,6
		if(port ==0)
					rtl8651_restartAsicEthernetPHYNway(port+1, 0x11);
		else
			
#endif
		rtl8651_restartAsicEthernetPHYNway(port+1, port);
800034bc:	26100001 	addiu	s0,s0,1
800034c0:	02002021 	move	a0,s0
800034c4:	0c0009fc 	jal	800027f0 <rtl8651_restartAsicEthernetPHYNway>
800034c8:	2605ffff 	addiu	a1,s0,-1
	REG32(LEDCR)  = (2<<20) | (0<<18) | (0<<16) | (0<<14) | (0<<12) | (0<<10) | (0<<8);  //P0-P5
#endif

	
	/*PHY FlowControl. Default enable*/
	for(port=0;port<MAX_PORT_NUMBER;port++)
800034cc:	1611fffc 	bne	s0,s1,800034c0 <swCore_init+0x1ac>
800034d0:	26100001 	addiu	s0,s0,1
#if ! (defined( CONFIG_NFBI) || defined(CONFIG_NONE_FLASH))

	{		
		extern char eth0_mac[6];
		extern char eth0_mac_httpd[6];
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac), 0);
800034d4:	3c048001 	lui	a0,0x8001
800034d8:	248429e0 	addiu	a0,a0,10720
800034dc:	0c000c57 	jal	8000315c <rtl8651_setAsicL2Table>
800034e0:	00002821 	move	a1,zero
		rtl8651_setAsicL2Table((ether_addr_t*)(&eth0_mac_httpd), 1);
800034e4:	3c048001 	lui	a0,0x8001
800034e8:	24843320 	addiu	a0,a0,13088
800034ec:	0c000c57 	jal	8000315c <rtl8651_setAsicL2Table>
800034f0:	24050001 	li	a1,1
	}
#endif

	REG32(FFCR) = EN_UNUNICAST_TOCPU | EN_UNMCAST_TOCPU; // rx broadcast and unicast packet
800034f4:	24030003 	li	v1,3
800034f8:	3c02bb80 	lui	v0,0xbb80
800034fc:	34424428 	ori	v0,v0,0x4428
80003500:	ac430000 	sw	v1,0(v0)
	return 0;
}
80003504:	00001021 	move	v0,zero
80003508:	8fbf001c 	lw	ra,28(sp)
8000350c:	8fb10018 	lw	s1,24(sp)
80003510:	8fb00014 	lw	s0,20(sp)
80003514:	03e00008 	jr	ra
80003518:	27bd0020 	addiu	sp,sp,32

8000351c <Get_P0_MiiMode>:
#define MACTYPE_MII_PHY 1
#define MACTYPE_RGMII 2
#define MACTYPE_GMII 3

unsigned int Get_P0_MiiMode()
{
8000351c:	27bdffd8 	addiu	sp,sp,-40
80003520:	afbf0024 	sw	ra,36(sp)
80003524:	afb00020 	sw	s0,32(sp)
		const unsigned char *miimodename[]={ "MII-MAC", "MII-PHY", "RGMII", "GMII-MAC" };
80003528:	3c028001 	lui	v0,0x8001
8000352c:	24420554 	addiu	v0,v0,1364
80003530:	afa20010 	sw	v0,16(sp)
80003534:	3c028001 	lui	v0,0x8001
80003538:	2442055c 	addiu	v0,v0,1372
8000353c:	afa20014 	sw	v0,20(sp)
80003540:	3c028001 	lui	v0,0x8001
80003544:	24420564 	addiu	v0,v0,1380
80003548:	afa20018 	sw	v0,24(sp)
8000354c:	3c028001 	lui	v0,0x8001
80003550:	2442056c 	addiu	v0,v0,1388
80003554:	afa2001c 	sw	v0,28(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
80003558:	3c02b800 	lui	v0,0xb800
8000355c:	34420008 	ori	v0,v0,0x8
80003560:	8c500000 	lw	s0,0(v0)
	unsigned int mode=GET_BITVAL(v, 30, RANG2);
80003564:	00108782 	srl	s0,s0,0x1e

	printf("P0miimode=%02x, %s\n", mode, miimodename[mode] );
80003568:	00101080 	sll	v0,s0,0x2
8000356c:	03a21021 	addu	v0,sp,v0
80003570:	3c048001 	lui	a0,0x8001
80003574:	24840578 	addiu	a0,a0,1400
80003578:	02002821 	move	a1,s0
8000357c:	0c001cc1 	jal	80007304 <dprintf>
80003580:	8c460010 	lw	a2,16(v0)


	if(mode==0)		return MACTYPE_MII_MAC;
80003584:	12000008 	beqz	s0,800035a8 <Get_P0_MiiMode+0x8c>
80003588:	00001021 	move	v0,zero
	else if(mode==1)	return MACTYPE_MII_PHY;
8000358c:	24030001 	li	v1,1
80003590:	12030005 	beq	s0,v1,800035a8 <Get_P0_MiiMode+0x8c>
80003594:	24020001 	li	v0,1
	else if(mode==2) return MACTYPE_RGMII;
80003598:	3a100002 	xori	s0,s0,0x2
8000359c:	24030003 	li	v1,3
800035a0:	24020002 	li	v0,2
800035a4:	0070100b 	movn	v0,v1,s0
	else				return MACTYPE_GMII;

	
}
800035a8:	8fbf0024 	lw	ra,36(sp)
800035ac:	8fb00020 	lw	s0,32(sp)
800035b0:	03e00008 	jr	ra
800035b4:	27bd0028 	addiu	sp,sp,40

800035b8 <Get_P0_PhyMode>:
//====================================================================
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
#define PHYTYPE_EMB 0
#define PHYTYPE_EXT 1
unsigned int Get_P0_PhyMode()
{
800035b8:	27bdffe8 	addiu	sp,sp,-24
800035bc:	afbf0014 	sw	ra,20(sp)
800035c0:	afb00010 	sw	s0,16(sp)
	#define RANG3  7
	#define RANG4 0xf	
	
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	
	unsigned int v=REG32(SYS_HW_STRAP);
800035c4:	3c02b800 	lui	v0,0xb800
800035c8:	34420008 	ori	v0,v0,0x8
800035cc:	8c420000 	lw	v0,0(v0)
	unsigned int mode=GET_BITVAL(v, 6, RANG1) *2 + GET_BITVAL(v, 7, RANG1);
800035d0:	7c500180 	ext	s0,v0,0x6,0x1
800035d4:	00108040 	sll	s0,s0,0x1
800035d8:	7c4201c0 	ext	v0,v0,0x7,0x1
800035dc:	02028021 	addu	s0,s0,v0
	
	printf("P0phymode=%02x, %s phy\n", mode,   (mode==2) ? "external" : "embedded"  );
800035e0:	24020002 	li	v0,2
800035e4:	12020003 	beq	s0,v0,800035f4 <Get_P0_PhyMode+0x3c>
800035e8:	3c068001 	lui	a2,0x8001
800035ec:	08000d7f 	j	800035fc <Get_P0_PhyMode+0x44>
800035f0:	24c6058c 	addiu	a2,a2,1420
800035f4:	3c068001 	lui	a2,0x8001
800035f8:	24c60598 	addiu	a2,a2,1432
800035fc:	3c048001 	lui	a0,0x8001
80003600:	248405a4 	addiu	a0,a0,1444
80003604:	0c001cc1 	jal	80007304 <dprintf>
80003608:	02002821 	move	a1,s0
8000360c:	3a020002 	xori	v0,s0,0x2
	
	if(mode==2)	return PHYTYPE_EXT;
	else 		return PHYTYPE_EMB;

	
}
80003610:	2c420001 	sltiu	v0,v0,1
80003614:	8fbf0014 	lw	ra,20(sp)
80003618:	8fb00010 	lw	s0,16(sp)
8000361c:	03e00008 	jr	ra
80003620:	27bd0018 	addiu	sp,sp,24
	...

80003630 <swNic_intHandler>:
*       intPending      Pending interrupt sources.
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
void swNic_intHandler(uint32 intPending) {return;}
80003630:	03e00008 	jr	ra
80003634:	00000000 	nop

80003638 <swNic_txDone>:

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80003638:	3c028001 	lui	v0,0x8001
8000363c:	8c4640a0 	lw	a2,16544(v0)
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
80003640:	3c028001 	lui	v0,0x8001
80003644:	8c484074 	lw	t0,16500(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
80003648:	3c028001 	lui	v0,0x8001
8000364c:	8c474084 	lw	a3,16516(v0)
80003650:	3c028001 	lui	v0,0x8001
80003654:	8c4240a4 	lw	v0,16548(v0)

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80003658:	08000da2 	j	80003688 <swNic_txDone+0x50>
8000365c:	00004821 	move	t1,zero
	    if ( (*(volatile uint32 *)&txPkthdrRing[0][txPktDoneDescIndex] 
80003660:	8c640000 	lw	a0,0(v1)
80003664:	30840001 	andi	a0,a0,0x1
80003668:	10800004 	beqz	a0,8000367c <swNic_txDone+0x44>
8000366c:	24420001 	addiu	v0,v0,1
80003670:	3c028001 	lui	v0,0x8001
80003674:	03e00008 	jr	ra
80003678:	ac4540a4 	sw	a1,16548(v0)
                    & DESC_OWNED_BIT) == DESC_RISC_OWNED ) {										
	    
		    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][txPktDoneDescIndex] 
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

			if (++txPktDoneDescIndex == txPkthdrRingCnt[0])
8000367c:	14e20004 	bne	a3,v0,80003690 <swNic_txDone+0x58>
80003680:	24630004 	addiu	v1,v1,4
80003684:	01201021 	move	v0,t1
80003688:	00021880 	sll	v1,v0,0x2
8000368c:	01031821 	addu	v1,t0,v1

void swNic_txDone(void)
{
	struct pktHdr * pPkthdr;
	
	while (txPktDoneDescIndex != currTxPkthdrDescIndex) {		
80003690:	14c2fff3 	bne	a2,v0,80003660 <swNic_txDone+0x28>
80003694:	00402821 	move	a1,v0
80003698:	3c028001 	lui	v0,0x8001
8000369c:	03e00008 	jr	ra
800036a0:	ac4540a4 	sw	a1,16548(v0)

800036a4 <swNic_init>:

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
                 uint32 userNeedRxMbufRingCnt,
                 uint32 userNeedTxPkthdrRingCnt[RTL865X_SWNIC_TXRING_MAX_PKTDESC],
                 uint32 clusterSize)
{
800036a4:	27bdffc0 	addiu	sp,sp,-64
800036a8:	afbf003c 	sw	ra,60(sp)
800036ac:	afbe0038 	sw	s8,56(sp)
800036b0:	afb70034 	sw	s7,52(sp)
800036b4:	afb60030 	sw	s6,48(sp)
800036b8:	afb5002c 	sw	s5,44(sp)
800036bc:	afb40028 	sw	s4,40(sp)
800036c0:	afb30024 	sw	s3,36(sp)
800036c4:	afb20020 	sw	s2,32(sp)
800036c8:	afb1001c 	sw	s1,28(sp)
800036cc:	afb00018 	sw	s0,24(sp)
800036d0:	00809021 	move	s2,a0
800036d4:	00a0b821 	move	s7,a1
800036d8:	00c0b021 	move	s6,a2
    uint8 * pClusterList;
    struct pktHdr * pPkthdr;
    struct mBuf * pMbuf;

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;
800036dc:	24030800 	li	v1,2048
800036e0:	3c028001 	lui	v0,0x8001
800036e4:	ac434094 	sw	v1,16532(v0)
800036e8:	3c158001 	lui	s5,0x8001
800036ec:	26b5405c 	addiu	s5,s5,16476
800036f0:	02a08821 	move	s1,s5
800036f4:	00008021 	move	s0,zero
800036f8:	0000a021 	move	s4,zero
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
		if (rxPkthdrRingCnt[i] == 0)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
800036fc:	3c1ea000 	lui	s8,0xa000
80003700:	3c028001 	lui	v0,0x8001
80003704:	24424044 	addiu	v0,v0,16452
80003708:	afa20010 	sw	v0,16(sp)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
8000370c:	3c020fff 	lui	v0,0xfff
80003710:	3442ffff 	ori	v0,v0,0xffff
80003714:	afa20014 	sw	v0,20(sp)

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
80003718:	24130018 	li	s3,24
		rxPkthdrRingCnt[i] = userNeedRxPkthdrRingCnt[i];
8000371c:	02501021 	addu	v0,s2,s0
80003720:	8c440000 	lw	a0,0(v0)
		if (rxPkthdrRingCnt[i] == 0)
80003724:	10800015 	beqz	a0,8000377c <swNic_init+0xd8>
80003728:	ae240000 	sw	a0,0(s1)
			continue;

		rxPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(rxPkthdrRingCnt[i] * sizeof(uint32));
8000372c:	0c0018f1 	jal	800063c4 <malloc>
80003730:	00042080 	sll	a0,a0,0x2
80003734:	005e2025 	or	a0,v0,s8
80003738:	8fa30010 	lw	v1,16(sp)
8000373c:	00701021 	addu	v0,v1,s0
80003740:	ac440000 	sw	a0,0(v0)
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
80003744:	8fa30014 	lw	v1,20(sp)
80003748:	00831024 	and	v0,a0,v1
8000374c:	14400006 	bnez	v0,80003768 <swNic_init+0xc4>
80003750:	00002821 	move	a1,zero
80003754:	3c048001 	lui	a0,0x8001
80003758:	0c001cc1 	jal	80007304 <dprintf>
8000375c:	248405bc 	addiu	a0,a0,1468
80003760:	08000dd8 	j	80003760 <swNic_init+0xbc>
80003764:	00000000 	nop
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
80003768:	8e260000 	lw	a2,0(s1)
8000376c:	0c0019d9 	jal	80006764 <memset>
80003770:	00063080 	sll	a2,a2,0x2
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
80003774:	8e220000 	lw	v0,0(s1)
80003778:	0282a021 	addu	s4,s4,v0
8000377c:	26100004 	addiu	s0,s0,4

    /* Cluster size is always 2048 */
    size_of_cluster = 2048;

    /* Allocate Rx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++) {
80003780:	1613ffe6 	bne	s0,s3,8000371c <swNic_init+0x78>
80003784:	26310004 	addiu	s1,s1,4
		ASSERT_CSP( (uint32) rxPkthdrRing[i] & 0x0fffffff );
		memset(rxPkthdrRing[i],0,rxPkthdrRingCnt[i] * sizeof(uint32));
		totalRxPkthdrRingCnt += rxPkthdrRingCnt[i];
    }
	
	if (totalRxPkthdrRingCnt == 0)
80003788:	12800160 	beqz	s4,80003d0c <swNic_init+0x668>
8000378c:	3c138001 	lui	s3,0x8001
80003790:	26734084 	addiu	s3,s3,16516
80003794:	02608021 	move	s0,s3
80003798:	00008821 	move	s1,zero
8000379c:	00009021 	move	s2,zero
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];

		if (txPkthdrRingCnt[i] == 0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
800037a0:	3c028001 	lui	v0,0x8001
800037a4:	24424074 	addiu	v0,v0,16500
800037a8:	afa20010 	sw	v0,16(sp)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
800037ac:	3c020fff 	lui	v0,0xfff
800037b0:	3442ffff 	ori	v0,v0,0xffff
800037b4:	afa20014 	sw	v0,20(sp)
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
800037b8:	241e0010 	li	s8,16
		txPkthdrRingCnt[i] = userNeedTxPkthdrRingCnt[i];
800037bc:	02d11021 	addu	v0,s6,s1
800037c0:	8c440000 	lw	a0,0(v0)

		if (txPkthdrRingCnt[i] == 0)
800037c4:	10800016 	beqz	a0,80003820 <swNic_init+0x17c>
800037c8:	ae040000 	sw	a0,0(s0)
			continue;

		txPkthdrRing[i] = (uint32 *) UNCACHED_MALLOC(txPkthdrRingCnt[i] * sizeof(uint32));
800037cc:	0c0018f1 	jal	800063c4 <malloc>
800037d0:	00042080 	sll	a0,a0,0x2
800037d4:	3c03a000 	lui	v1,0xa000
800037d8:	00432025 	or	a0,v0,v1
800037dc:	8fa30010 	lw	v1,16(sp)
800037e0:	00711021 	addu	v0,v1,s1
800037e4:	ac440000 	sw	a0,0(v0)
		
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
800037e8:	8fa30014 	lw	v1,20(sp)
800037ec:	00831024 	and	v0,a0,v1
800037f0:	14400006 	bnez	v0,8000380c <swNic_init+0x168>
800037f4:	00002821 	move	a1,zero
800037f8:	3c048001 	lui	a0,0x8001
800037fc:	0c001cc1 	jal	80007304 <dprintf>
80003800:	248405bc 	addiu	a0,a0,1468
80003804:	08000e01 	j	80003804 <swNic_init+0x160>
80003808:	00000000 	nop
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
8000380c:	8e060000 	lw	a2,0(s0)
80003810:	0c0019d9 	jal	80006764 <memset>
80003814:	00063080 	sll	a2,a2,0x2
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
80003818:	8e020000 	lw	v0,0(s0)
8000381c:	02429021 	addu	s2,s2,v0
80003820:	26310004 	addiu	s1,s1,4
	
	if (totalRxPkthdrRingCnt == 0)
		return EINVAL;

    /* Allocate Tx descriptors of rings */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++) {
80003824:	163effe5 	bne	s1,s8,800037bc <swNic_init+0x118>
80003828:	26100004 	addiu	s0,s0,4
		ASSERT_CSP( (uint32) txPkthdrRing[i] & 0x0fffffff );
		memset(txPkthdrRing[i],0,(txPkthdrRingCnt[i] * sizeof(uint32)));
		totalTxPkthdrRingCnt += txPkthdrRingCnt[i];
    }

	if (totalTxPkthdrRingCnt == 0)
8000382c:	12400137 	beqz	s2,80003d0c <swNic_init+0x668>
80003830:	3c028001 	lui	v0,0x8001
		return EINVAL;

    /* Allocate MBuf descriptors of rings */
	rxMbufRingCnt = userNeedRxMbufRingCnt;

	if (userNeedRxMbufRingCnt == 0)
80003834:	12e00135 	beqz	s7,80003d0c <swNic_init+0x668>
80003838:	ac5731b8 	sw	s7,12728(v0)
		return EINVAL;

	rxMbufRing = (uint32 *) UNCACHED_MALLOC(userNeedRxMbufRingCnt * sizeof(uint32));
8000383c:	0017b880 	sll	s7,s7,0x2
80003840:	0c0018f1 	jal	800063c4 <malloc>
80003844:	02e02021 	move	a0,s7
80003848:	3c03a000 	lui	v1,0xa000
8000384c:	00432025 	or	a0,v0,v1
80003850:	3c028001 	lui	v0,0x8001
80003854:	ac444040 	sw	a0,16448(v0)
    ASSERT_CSP( (uint32) rxMbufRing & 0x0fffffff );
80003858:	3c020fff 	lui	v0,0xfff
8000385c:	3442ffff 	ori	v0,v0,0xffff
80003860:	00821024 	and	v0,a0,v0
80003864:	14400006 	bnez	v0,80003880 <swNic_init+0x1dc>
80003868:	00002821 	move	a1,zero
8000386c:	3c048001 	lui	a0,0x8001
80003870:	0c001cc1 	jal	80007304 <dprintf>
80003874:	248405bc 	addiu	a0,a0,1468
80003878:	08000e1e 	j	80003878 <swNic_init+0x1d4>
8000387c:	00000000 	nop
	memset(rxMbufRing,0,userNeedRxMbufRingCnt * sizeof(uint32));
80003880:	0c0019d9 	jal	80006764 <memset>
80003884:	02e03021 	move	a2,s7
    /* Allocate pkthdr */
    pPkthdrList = (struct pktHdr *) UNCACHED_MALLOC(
80003888:	0254a021 	addu	s4,s2,s4
8000388c:	001410c0 	sll	v0,s4,0x3
80003890:	0014a140 	sll	s4,s4,0x5
80003894:	02828823 	subu	s1,s4,v0
80003898:	0c0018f1 	jal	800063c4 <malloc>
8000389c:	02202021 	move	a0,s1
800038a0:	3c10a000 	lui	s0,0xa000
800038a4:	00508025 	or	s0,v0,s0
                    (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));
    ASSERT_CSP( (uint32) pPkthdrList & 0x0fffffff );
800038a8:	3c020fff 	lui	v0,0xfff
800038ac:	3442ffff 	ori	v0,v0,0xffff
800038b0:	02021024 	and	v0,s0,v0
800038b4:	14400006 	bnez	v0,800038d0 <swNic_init+0x22c>
800038b8:	00002821 	move	a1,zero
800038bc:	3c048001 	lui	a0,0x8001
800038c0:	0c001cc1 	jal	80007304 <dprintf>
800038c4:	248405bc 	addiu	a0,a0,1468
800038c8:	08000e32 	j	800038c8 <swNic_init+0x224>
800038cc:	00000000 	nop
   memset(pPkthdrList,0, (totalRxPkthdrRingCnt + totalTxPkthdrRingCnt) * sizeof(struct pktHdr));                 
800038d0:	02002021 	move	a0,s0
800038d4:	0c0019d9 	jal	80006764 <memset>
800038d8:	02203021 	move	a2,s1
    /* Allocate mbufs */
    pMbufList = (struct mBuf *) UNCACHED_MALLOC(
800038dc:	3c028001 	lui	v0,0x8001
800038e0:	8c4231b8 	lw	v0,12728(v0)
800038e4:	02421021 	addu	v0,s2,v0
800038e8:	000218c0 	sll	v1,v0,0x3
800038ec:	00021140 	sll	v0,v0,0x5
800038f0:	0c0018f1 	jal	800063c4 <malloc>
800038f4:	00432023 	subu	a0,v0,v1
800038f8:	3c11a000 	lui	s1,0xa000
800038fc:	00518825 	or	s1,v0,s1
                    (rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf));
    ASSERT_CSP( (uint32) pMbufList & 0x0fffffff );
80003900:	3c020fff 	lui	v0,0xfff
80003904:	3442ffff 	ori	v0,v0,0xffff
80003908:	02221024 	and	v0,s1,v0
8000390c:	14400006 	bnez	v0,80003928 <swNic_init+0x284>
80003910:	3c148001 	lui	s4,0x8001
80003914:	3c048001 	lui	a0,0x8001
80003918:	0c001cc1 	jal	80007304 <dprintf>
8000391c:	248405bc 	addiu	a0,a0,1468
80003920:	08000e48 	j	80003920 <swNic_init+0x27c>
80003924:	00000000 	nop
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
80003928:	8e8631b8 	lw	a2,12728(s4)
8000392c:	02463021 	addu	a2,s2,a2
80003930:	000610c0 	sll	v0,a2,0x3
80003934:	00063140 	sll	a2,a2,0x5
80003938:	02202021 	move	a0,s1
8000393c:	00002821 	move	a1,zero
80003940:	0c0019d9 	jal	80006764 <memset>
80003944:	00c23023 	subu	a2,a2,v0
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
80003948:	3c028001 	lui	v0,0x8001
8000394c:	8c444094 	lw	a0,16532(v0)
80003950:	24840002 	addiu	a0,a0,2
80003954:	8e8231b8 	lw	v0,12728(s4)
80003958:	70822002 	mul	a0,a0,v0
8000395c:	0c0018f1 	jal	800063c4 <malloc>
80003960:	24840007 	addiu	a0,a0,7
80003964:	3c12a000 	lui	s2,0xa000
80003968:	00529025 	or	s2,v0,s2
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
8000396c:	3c020fff 	lui	v0,0xfff
80003970:	3442ffff 	ori	v0,v0,0xffff
80003974:	02421024 	and	v0,s2,v0
80003978:	14400006 	bnez	v0,80003994 <swNic_init+0x2f0>
8000397c:	3c028001 	lui	v0,0x8001
80003980:	3c048001 	lui	a0,0x8001
80003984:	0c001cc1 	jal	80007304 <dprintf>
80003988:	248405bc 	addiu	a0,a0,1468
8000398c:	08000e63 	j	8000398c <swNic_init+0x2e8>
80003990:	00000000 	nop
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
80003994:	8c464094 	lw	a2,16532(v0)
80003998:	24c60002 	addiu	a2,a2,2
8000399c:	3c028001 	lui	v0,0x8001
800039a0:	8c4231b8 	lw	v0,12728(v0)
800039a4:	70c23002 	mul	a2,a2,v0
800039a8:	02402021 	move	a0,s2
800039ac:	00002821 	move	a1,zero
800039b0:	0c0019d9 	jal	80006764 <memset>
800039b4:	24c60007 	addiu	a2,a2,7
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));

    /* Initialize interrupt statistics counter */
    rxPktCounter = txPktCounter = 0;
800039b8:	3c028001 	lui	v0,0x8001
800039bc:	ac4040ac 	sw	zero,16556(v0)
800039c0:	3c028001 	lui	v0,0x8001
800039c4:	ac4040a8 	sw	zero,16552(v0)

    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
800039c8:	3c028001 	lui	v0,0x8001
800039cc:	ac4040a0 	sw	zero,16544(v0)
    txPktDoneDescIndex=0;
800039d0:	3c028001 	lui	v0,0x8001
800039d4:	ac4040a4 	sw	zero,16548(v0)
800039d8:	3c048001 	lui	a0,0x8001
800039dc:	24844074 	addiu	a0,a0,16500
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
800039e0:	3c0a8001 	lui	t2,0x8001
800039e4:	254a4084 	addiu	t2,t2,16516
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
800039e8:	00004821 	move	t1,zero
         bzero((void *) pPkthdr, sizeof(struct pktHdr));
         bzero((void *) pMbuf, sizeof(struct mBuf));

			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
800039ec:	24088800 	li	t0,-30720
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;

			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
800039f0:	08000eae 	j	80003ab8 <swNic_init+0x414>
800039f4:	2407009c 	li	a3,156
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;
800039f8:	26230018 	addiu	v1,s1,24

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
800039fc:	ae000000 	sw	zero,0(s0)
80003a00:	ae000004 	sw	zero,4(s0)
80003a04:	ae000008 	sw	zero,8(s0)
80003a08:	ae00000c 	sw	zero,12(s0)
80003a0c:	ae000010 	sw	zero,16(s0)
80003a10:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
80003a14:	ae200000 	sw	zero,0(s1)
80003a18:	ae200004 	sw	zero,4(s1)
80003a1c:	ae200008 	sw	zero,8(s1)
80003a20:	ae20000c 	sw	zero,12(s1)
80003a24:	ae200010 	sw	zero,16(s1)
80003a28:	ae200014 	sw	zero,20(s1)

			pPkthdr->ph_mbuf = pMbuf;
80003a2c:	ac510000 	sw	s1,0(v0)
			pPkthdr->ph_len = 0;
80003a30:	a4400004 	sh	zero,4(v0)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_OUTGOING;
80003a34:	a448000c 	sh	t0,12(v0)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
80003a38:	8e060008 	lw	a2,8(s0)
80003a3c:	7c06ff44 	ins	a2,zero,0x1d,0x3
80003a40:	ae060008 	sw	a2,8(s0)
			pPkthdr->ph_portlist = 0;
80003a44:	a040000f 	sb	zero,15(v0)

			pMbuf->m_next = NULL;
80003a48:	ac60ffe8 	sw	zero,-24(v1)
			pMbuf->m_pkthdr = pPkthdr;
80003a4c:	ac70ffec 	sw	s0,-20(v1)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
80003a50:	a467fff2 	sh	a3,-14(v1)
			pMbuf->m_data = NULL;
80003a54:	ac60fff4 	sw	zero,-12(v1)
			pMbuf->m_extbuf = NULL;
80003a58:	ac60fff8 	sw	zero,-8(v1)
			pMbuf->m_extsize = 0;
80003a5c:	a460fffc 	sh	zero,-4(v1)

			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;
80003a60:	8c8b0000 	lw	t3,0(a0)
80003a64:	00053080 	sll	a2,a1,0x2
80003a68:	01663021 	addu	a2,t3,a2
80003a6c:	acc20000 	sw	v0,0(a2)
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < txPkthdrRingCnt[i]; j++)
80003a70:	24a50001 	addiu	a1,a1,1
80003a74:	24420018 	addiu	v0,v0,24
80003a78:	00608821 	move	s1,v1
80003a7c:	8e630000 	lw	v1,0(s3)
80003a80:	00a3302b 	sltu	a2,a1,v1
80003a84:	14c0ffdc 	bnez	a2,800039f8 <swNic_init+0x354>
80003a88:	00408021 	move	s0,v0
			txPkthdrRing[i][j] = (int32) pPkthdr | DESC_RISC_OWNED;

		}

		/* Set wrap bit of the last descriptor */
        if (txPkthdrRingCnt[i] != 0)
80003a8c:	10600007 	beqz	v1,80003aac <swNic_init+0x408>
80003a90:	2463ffff 	addiu	v1,v1,-1
{
            txPkthdrRing[i][txPkthdrRingCnt[i] - 1] |= DESC_WRAP;
80003a94:	00031880 	sll	v1,v1,0x2
80003a98:	8c820000 	lw	v0,0(a0)
80003a9c:	00431021 	addu	v0,v0,v1
80003aa0:	8c430000 	lw	v1,0(v0)
80003aa4:	34630002 	ori	v1,v1,0x2
80003aa8:	ac430000 	sw	v1,0(v0)
80003aac:	24840004 	addiu	a0,a0,4
    /* Initialize index of Tx pkthdr descriptor */
    currTxPkthdrDescIndex = 0;
    txPktDoneDescIndex=0;

    /* Initialize Tx packet header descriptors */
    for (i = 0; i < RTL865X_SWNIC_TXRING_MAX_PKTDESC; i++)
80003ab0:	108a0004 	beq	a0,t2,80003ac4 <swNic_init+0x420>
80003ab4:	26730004 	addiu	s3,s3,4
80003ab8:	02001021 	move	v0,s0
80003abc:	08000e9f 	j	80003a7c <swNic_init+0x3d8>
80003ac0:	01202821 	move	a1,t1
    memset(pMbufList,0,((rxMbufRingCnt + totalTxPkthdrRingCnt) * sizeof(struct mBuf)));                
    /* Allocate clusters */
    pClusterList = (uint8 *) UNCACHED_MALLOC(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt);
    ASSERT_CSP( (uint32) pClusterList & 0x0fffffff );
    memset(pClusterList,0,(rxMbufRingCnt * size_of_cluster + 8 - 1+2*rxMbufRingCnt));
    pClusterList = (uint8*)(((uint32) pClusterList + 8 - 1) & ~(8 - 1));
80003ac4:	26520007 	addiu	s2,s2,7
80003ac8:	2402fff8 	li	v0,-8
80003acc:	02429024 	and	s2,s2,v0
}

	}

    /* Fill Tx packet header FDP */
    REG32(CPUTPDCR0) = (uint32) txPkthdrRing[0];
80003ad0:	3c038001 	lui	v1,0x8001
80003ad4:	8c654074 	lw	a1,16500(v1)
80003ad8:	3c02b801 	lui	v0,0xb801
80003adc:	34440020 	ori	a0,v0,0x20
80003ae0:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR1) = (uint32) txPkthdrRing[1];
80003ae4:	24634074 	addiu	v1,v1,16500
80003ae8:	8c650004 	lw	a1,4(v1)
80003aec:	34440024 	ori	a0,v0,0x24
80003af0:	ac850000 	sw	a1,0(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    REG32(CPUTPDCR2) = (uint32) txPkthdrRing[2];
80003af4:	8c650008 	lw	a1,8(v1)
80003af8:	34440060 	ori	a0,v0,0x60
80003afc:	ac850000 	sw	a1,0(a0)
    REG32(CPUTPDCR3) = (uint32) txPkthdrRing[3];
80003b00:	8c63000c 	lw	v1,12(v1)
80003b04:	34420064 	ori	v0,v0,0x64
80003b08:	ac430000 	sw	v1,0(v0)
#endif

    /* Initialize index of current Rx pkthdr descriptor */
    currRxPkthdrDescIndex = 0;
80003b0c:	3c028001 	lui	v0,0x8001
80003b10:	ac404098 	sw	zero,16536(v0)

    /* Initialize index of current Rx Mbuf descriptor */
    currRxMbufDescIndex = 0;
80003b14:	3c028001 	lui	v0,0x8001
80003b18:	ac40409c 	sw	zero,16540(v0)
80003b1c:	3c048001 	lui	a0,0x8001
80003b20:	24844044 	addiu	a0,a0,16452
*                                                                         
*   OUTPUTS                                                               
*       Status.
*************************************************************************/

int32 swNic_init(uint32 userNeedRxPkthdrRingCnt[RTL865X_SWNIC_RXRING_MAX_PKTDESC],
80003b24:	3c0e8001 	lui	t6,0x8001
80003b28:	25ce405c 	addiu	t6,t6,16476
80003b2c:	00003021 	move	a2,zero
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
80003b30:	00006821 	move	t5,zero
         bzero((void *) pMbuf, sizeof(struct mBuf));

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
			pPkthdr->ph_len = 0;
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
80003b34:	240c9000 	li	t4,-28672
			pPkthdr->ph_type = PKTHDR_ETHERNET;
			pPkthdr->ph_portlist = 0;
			pMbuf->m_next = NULL;
			pMbuf->m_pkthdr = pPkthdr;
			pMbuf->m_len = 0;
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
80003b38:	240b009c 	li	t3,156
			pMbuf->m_data = NULL;
			pMbuf->m_extsize = size_of_cluster;
80003b3c:	3c098001 	lui	t1,0x8001
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
			pClusterList += size_of_cluster;
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
80003b40:	08000f10 	j	80003c40 <swNic_init+0x59c>
80003b44:	3c0a8001 	lui	t2,0x8001
		{
			/* Dequeue pkthdr and mbuf */
			pPkthdr = pPkthdrList++;
			pMbuf = pMbufList++;

         bzero((void *) pPkthdr, sizeof(struct pktHdr));
80003b48:	ae000000 	sw	zero,0(s0)
80003b4c:	ae000004 	sw	zero,4(s0)
80003b50:	ae000008 	sw	zero,8(s0)
80003b54:	ae00000c 	sw	zero,12(s0)
80003b58:	ae000010 	sw	zero,16(s0)
80003b5c:	ae000014 	sw	zero,20(s0)
         bzero((void *) pMbuf, sizeof(struct mBuf));
80003b60:	ae200000 	sw	zero,0(s1)
80003b64:	ae200004 	sw	zero,4(s1)
80003b68:	ae200008 	sw	zero,8(s1)
80003b6c:	ae20000c 	sw	zero,12(s1)
80003b70:	ae200010 	sw	zero,16(s1)
80003b74:	ae200014 	sw	zero,20(s1)

			/* Setup pkthdr and mbuf */
			pPkthdr->ph_mbuf = pMbuf;
80003b78:	ac710000 	sw	s1,0(v1)
			pPkthdr->ph_len = 0;
80003b7c:	a4600004 	sh	zero,4(v1)
			pPkthdr->ph_flags = PKTHDR_USED | PKT_INCOMING;
80003b80:	a46c000c 	sh	t4,12(v1)
			pPkthdr->ph_type = PKTHDR_ETHERNET;
80003b84:	8e080008 	lw	t0,8(s0)
80003b88:	7c08ff44 	ins	t0,zero,0x1d,0x3
80003b8c:	ae080008 	sw	t0,8(s0)
			pPkthdr->ph_portlist = 0;
80003b90:	a060000f 	sb	zero,15(v1)
			pMbuf->m_next = NULL;
80003b94:	ac400000 	sw	zero,0(v0)
			pMbuf->m_pkthdr = pPkthdr;
80003b98:	ac500004 	sw	s0,4(v0)
			pMbuf->m_len = 0;
80003b9c:	a4400008 	sh	zero,8(v0)
			pMbuf->m_flags = MBUF_USED | MBUF_EXT | MBUF_PKTHDR | MBUF_EOR;
80003ba0:	a44b000a 	sh	t3,10(v0)
			pMbuf->m_data = NULL;
80003ba4:	ac40000c 	sw	zero,12(v0)
			pMbuf->m_extsize = size_of_cluster;
80003ba8:	8d284094 	lw	t0,16532(t1)
80003bac:	a4480014 	sh	t0,20(v0)
			/*offset 2 bytes for 4 bytes align of ip packet*/
			pMbuf->m_data = pMbuf->m_extbuf = (pClusterList+2);
80003bb0:	26480002 	addiu	t0,s2,2
80003bb4:	ac480010 	sw	t0,16(v0)
80003bb8:	ac48000c 	sw	t0,12(v0)
			pClusterList += size_of_cluster;
80003bbc:	8d284094 	lw	t0,16532(t1)
80003bc0:	02489021 	addu	s2,s2,t0
			
			/* Setup descriptors */
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
80003bc4:	8c8f0000 	lw	t7,0(a0)
80003bc8:	00054080 	sll	t0,a1,0x2
80003bcc:	01e84021 	addu	t0,t7,t0
80003bd0:	346f0001 	ori	t7,v1,0x1
80003bd4:	ad0f0000 	sw	t7,0(t0)
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
80003bd8:	8d484040 	lw	t0,16448(t2)
80003bdc:	01074021 	addu	t0,t0,a3
80003be0:	344f0001 	ori	t7,v0,0x1
80003be4:	ad0f0000 	sw	t7,0(t0)
    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
	{
		for (j = 0; j < rxPkthdrRingCnt[i]; j++)
80003be8:	24a50001 	addiu	a1,a1,1
80003bec:	24630018 	addiu	v1,v1,24
80003bf0:	24420018 	addiu	v0,v0,24
80003bf4:	24e70004 	addiu	a3,a3,4
80003bf8:	00408821 	move	s1,v0
80003bfc:	00608021 	move	s0,v1
80003c00:	8ea80000 	lw	t0,0(s5)
80003c04:	00a8c02b 	sltu	t8,a1,t0
80003c08:	1700ffcf 	bnez	t8,80003b48 <swNic_init+0x4a4>
80003c0c:	00a67821 	addu	t7,a1,a2
			rxPkthdrRing[i][j] = (int32) pPkthdr | DESC_SWCORE_OWNED;
			rxMbufRing[k++] = (int32) pMbuf | DESC_SWCORE_OWNED;
		}

		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
80003c10:	11000007 	beqz	t0,80003c30 <swNic_init+0x58c>
80003c14:	2508ffff 	addiu	t0,t0,-1
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
80003c18:	00084080 	sll	t0,t0,0x2
80003c1c:	8c820000 	lw	v0,0(a0)
80003c20:	00481021 	addu	v0,v0,t0
80003c24:	8c430000 	lw	v1,0(v0)
80003c28:	34630002 	ori	v1,v1,0x2
80003c2c:	ac430000 	sw	v1,0(v0)
80003c30:	24840004 	addiu	a0,a0,4
    currRxMbufDescIndex = 0;

    /* Initialize Rx packet header descriptors */
	k = 0;

    for (i = 0; i < RTL865X_SWNIC_RXRING_MAX_PKTDESC; i++)
80003c34:	108e0007 	beq	a0,t6,80003c54 <swNic_init+0x5b0>
80003c38:	26b50004 	addiu	s5,s5,4
80003c3c:	01e03021 	move	a2,t7
80003c40:	02001821 	move	v1,s0
80003c44:	02201021 	move	v0,s1
80003c48:	00063880 	sll	a3,a2,0x2
80003c4c:	08000efe 	j	80003bf8 <swNic_init+0x554>
80003c50:	01a02821 	move	a1,t5
		/* Set wrap bit of the last descriptor */
        if (rxPkthdrRingCnt[i] != 0)
		    rxPkthdrRing[i][rxPkthdrRingCnt[i] - 1] |= DESC_WRAP;
	}

	rxMbufRing[rxMbufRingCnt - 1] |= DESC_WRAP;
80003c54:	3c048001 	lui	a0,0x8001
80003c58:	3c028001 	lui	v0,0x8001
80003c5c:	8c4231b8 	lw	v0,12728(v0)
80003c60:	2442ffff 	addiu	v0,v0,-1
80003c64:	00021080 	sll	v0,v0,0x2
80003c68:	8c834040 	lw	v1,16448(a0)
80003c6c:	00621021 	addu	v0,v1,v0
80003c70:	8c430000 	lw	v1,0(v0)
80003c74:	34630002 	ori	v1,v1,0x2
80003c78:	ac430000 	sw	v1,0(v0)

    /* Fill Rx packet header FDP */
    REG32(CPURPDCR0) = (uint32) rxPkthdrRing[0];
80003c7c:	3c038001 	lui	v1,0x8001
80003c80:	8c664044 	lw	a2,16452(v1)
80003c84:	3c02b801 	lui	v0,0xb801
80003c88:	34450004 	ori	a1,v0,0x4
80003c8c:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR1) = (uint32) rxPkthdrRing[1];
80003c90:	24634044 	addiu	v1,v1,16452
80003c94:	8c660004 	lw	a2,4(v1)
80003c98:	34450008 	ori	a1,v0,0x8
80003c9c:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR2) = (uint32) rxPkthdrRing[2];
80003ca0:	8c660008 	lw	a2,8(v1)
80003ca4:	3445000c 	ori	a1,v0,0xc
80003ca8:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR3) = (uint32) rxPkthdrRing[3];
80003cac:	8c66000c 	lw	a2,12(v1)
80003cb0:	34450010 	ori	a1,v0,0x10
80003cb4:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR4) = (uint32) rxPkthdrRing[4];
80003cb8:	8c660010 	lw	a2,16(v1)
80003cbc:	34450014 	ori	a1,v0,0x14
80003cc0:	aca60000 	sw	a2,0(a1)
    REG32(CPURPDCR5) = (uint32) rxPkthdrRing[5];
80003cc4:	8c650014 	lw	a1,20(v1)
80003cc8:	34430018 	ori	v1,v0,0x18
80003ccc:	ac650000 	sw	a1,0(v1)

    REG32(CPURMDCR0) = (uint32) rxMbufRing;
80003cd0:	8c844040 	lw	a0,16448(a0)
80003cd4:	3443001c 	ori	v1,v0,0x1c
80003cd8:	ac640000 	sw	a0,0(v1)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR	
	
    /* Enable Rx & Tx. Config bus burst size and mbuf size. */
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_256WORDS | icr_mbufsize;
    //REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES;	//8651c
	REG32(CPUICR) = TXCMD | RXCMD | BUSBURST_32WORDS | MBUF_2048BYTES; //wei test irq
80003cdc:	3c03c400 	lui	v1,0xc400
80003ce0:	ac430000 	sw	v1,0(v0)

	REG32(CPUIIMR) = RX_DONE_IE_ALL | TX_DONE_IE_ALL; 
80003ce4:	34420028 	ori	v0,v0,0x28
80003ce8:	240307f8 	li	v1,2040
80003cec:	ac430000 	sw	v1,0(v0)


	REG32(MDCIOCR)=0x96181441;      // enable Giga port 8211B LED
80003cf0:	3c039618 	lui	v1,0x9618
80003cf4:	34631441 	ori	v1,v1,0x1441
80003cf8:	3c02bb80 	lui	v0,0xbb80
80003cfc:	34424004 	ori	v0,v0,0x4004
80003d00:	ac430000 	sw	v1,0(v0)
	//dprintf("eth0 CPUIIMR status=%x\r\n", *(volatile unsigned int*)(0xb8010028));   //ISR
	
    return SUCCESS;
80003d04:	08000f44 	j	80003d10 <swNic_init+0x66c>
80003d08:	00001021 	move	v0,zero
80003d0c:	24020016 	li	v0,22
}
80003d10:	8fbf003c 	lw	ra,60(sp)
80003d14:	8fbe0038 	lw	s8,56(sp)
80003d18:	8fb70034 	lw	s7,52(sp)
80003d1c:	8fb60030 	lw	s6,48(sp)
80003d20:	8fb5002c 	lw	s5,44(sp)
80003d24:	8fb40028 	lw	s4,40(sp)
80003d28:	8fb30024 	lw	s3,36(sp)
80003d2c:	8fb20020 	lw	s2,32(sp)
80003d30:	8fb1001c 	lw	s1,28(sp)
80003d34:	8fb00018 	lw	s0,24(sp)
80003d38:	03e00008 	jr	ra
80003d3c:	27bd0040 	addiu	sp,sp,64

80003d40 <swNic_send>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_send(void * output, uint32 len)
{
80003d40:	27bdffe0 	addiu	sp,sp,-32
80003d44:	afbf001c 	sw	ra,28(sp)
80003d48:	afb20018 	sw	s2,24(sp)
80003d4c:	afb10014 	sw	s1,20(sp)
80003d50:	afb00010 	sw	s0,16(sp)
80003d54:	00801021 	move	v0,a0
    struct pktHdr * pPkthdr;
    //uint8 pktbuf[2048];
    uint8* pktbuf_alligned;

	int next_index;
	if ((currTxPkthdrDescIndex+1) == txPkthdrRingCnt[0])
80003d58:	3c038001 	lui	v1,0x8001
80003d5c:	8c7040a0 	lw	s0,16544(v1)
80003d60:	26100001 	addiu	s0,s0,1
80003d64:	3c038001 	lui	v1,0x8001
80003d68:	8c634084 	lw	v1,16516(v1)
80003d6c:	02031826 	xor	v1,s0,v1
80003d70:	0003800a 	movz	s0,zero,v1
		next_index = 0;
	else
		next_index = currTxPkthdrDescIndex+1;
	if (next_index == txPktDoneDescIndex) {
80003d74:	3c038001 	lui	v1,0x8001
80003d78:	8c6340a4 	lw	v1,16548(v1)
80003d7c:	16030006 	bne	s0,v1,80003d98 <swNic_send+0x58>
80003d80:	00a08821 	move	s1,a1
		dprintf("Tx Desc full!\n");
80003d84:	3c048001 	lui	a0,0x8001
80003d88:	0c001cc1 	jal	80007304 <dprintf>
80003d8c:	248405d4 	addiu	a0,a0,1492
		return -1;
80003d90:	08000fa9 	j	80003ea4 <swNic_send+0x164>
80003d94:	2402ffff 	li	v0,-1
	}		

#ifdef _FAST_TX
	pktbuf_alligned = (uint8 *)output;
#else
	pktbuf_alligned = (uint8 *) (( (uint32) pktbuf & 0xfffffffc) | 0xa0000000);
80003d98:	3c035fff 	lui	v1,0x5fff
80003d9c:	3463fffc 	ori	v1,v1,0xfffc
80003da0:	3c128001 	lui	s2,0x8001
80003da4:	26524a18 	addiu	s2,s2,18968
80003da8:	02439024 	and	s2,s2,v1
80003dac:	3c03a000 	lui	v1,0xa000
80003db0:	02439025 	or	s2,s2,v1
    /* Copy Packet Content */
    memcpy(pktbuf_alligned, output, len);
80003db4:	02402021 	move	a0,s2
80003db8:	00402821 	move	a1,v0
80003dbc:	0c0019e2 	jal	80006788 <memcpy>
80003dc0:	02203021 	move	a2,s1
			ddump(output, 32);
//		else
//			ddump(output, len);
	}
#endif
    ASSERT_CSP( ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED );
80003dc4:	3c028001 	lui	v0,0x8001
80003dc8:	8c4340a0 	lw	v1,16544(v0)
80003dcc:	00031880 	sll	v1,v1,0x2
80003dd0:	3c028001 	lui	v0,0x8001
80003dd4:	8c424074 	lw	v0,16500(v0)
80003dd8:	00431021 	addu	v0,v0,v1
80003ddc:	8c420000 	lw	v0,0(v0)
80003de0:	30440001 	andi	a0,v0,0x1
80003de4:	10800005 	beqz	a0,80003dfc <swNic_send+0xbc>
80003de8:	3c048001 	lui	a0,0x8001
80003dec:	0c001cc1 	jal	80007304 <dprintf>
80003df0:	248405bc 	addiu	a0,a0,1468
80003df4:	08000f7d 	j	80003df4 <swNic_send+0xb4>
80003df8:	00000000 	nop

    /* Fetch packet header from Tx ring */
    pPkthdr = (struct pktHdr *) ((int32) txPkthdrRing[0][currTxPkthdrDescIndex] 
80003dfc:	2404fffc 	li	a0,-4
80003e00:	00441024 	and	v0,v0,a0
                                                & ~(DESC_OWNED_BIT | DESC_WRAP));

    /* Pad small packets and add CRC */
    if ( len < 60 )
80003e04:	2e24003c 	sltiu	a0,s1,60
80003e08:	10800004 	beqz	a0,80003e1c <swNic_send+0xdc>
80003e0c:	26310004 	addiu	s1,s1,4
        pPkthdr->ph_len = 64;
80003e10:	24040040 	li	a0,64
80003e14:	08000f88 	j	80003e20 <swNic_send+0xe0>
80003e18:	a4440004 	sh	a0,4(v0)
    else
        pPkthdr->ph_len = len + 4;
80003e1c:	a4510004 	sh	s1,4(v0)
    pPkthdr->ph_mbuf->m_len       = pPkthdr->ph_len;
80003e20:	8c440000 	lw	a0,0(v0)
80003e24:	94450004 	lhu	a1,4(v0)
80003e28:	a4850008 	sh	a1,8(a0)
    pPkthdr->ph_mbuf->m_extsize = pPkthdr->ph_len;
80003e2c:	8c440000 	lw	a0,0(v0)
80003e30:	94450004 	lhu	a1,4(v0)
80003e34:	a4850014 	sh	a1,20(a0)

    /* Set cluster pointer to buffer */
    pPkthdr->ph_mbuf->m_data    = pktbuf_alligned;
80003e38:	8c440000 	lw	a0,0(v0)
80003e3c:	ac92000c 	sw	s2,12(a0)
    pPkthdr->ph_mbuf->m_extbuf = pktbuf_alligned;
80003e40:	8c440000 	lw	a0,0(v0)
80003e44:	ac920010 	sw	s2,16(a0)
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
    pPkthdr->ph_ptpPkt = 0;
80003e48:	8c440014 	lw	a0,20(v0)
80003e4c:	7c04c604 	ins	a0,zero,0x18,0x1
80003e50:	ac440014 	sw	a0,20(v0)
#endif

    /* Set destination port */
#if defined(CONFIG_RTL8198)
    pPkthdr->ph_portlist = ALL_PORT_MASK;
80003e54:	2404003f 	li	a0,63
80003e58:	a044000f 	sb	a0,15(v0)
        {
                pPkthdr->ph_portlist = AP_MODE_PORT_MASK;//Port 4 Only for AP Mode
        }
#endif		
    /* Give descriptor to switch core */
    txPkthdrRing[0][currTxPkthdrDescIndex] |= DESC_SWCORE_OWNED;
80003e5c:	3c028001 	lui	v0,0x8001
80003e60:	8c424074 	lw	v0,16500(v0)
80003e64:	00431021 	addu	v0,v0,v1
80003e68:	8c430000 	lw	v1,0(v0)
80003e6c:	34630001 	ori	v1,v1,0x1
80003e70:	ac430000 	sw	v1,0(v0)

    /* Set TXFD bit to start send */
    REG32(CPUICR) |= TXFD;
80003e74:	3c02b801 	lui	v0,0xb801
80003e78:	8c440000 	lw	a0,0(v0)
80003e7c:	3c030080 	lui	v1,0x80
80003e80:	00831825 	or	v1,a0,v1
80003e84:	ac430000 	sw	v1,0(v0)
    txPktCounter++;
80003e88:	3c028001 	lui	v0,0x8001
80003e8c:	8c4340ac 	lw	v1,16556(v0)
80003e90:	24630001 	addiu	v1,v1,1
80003e94:	ac4340ac 	sw	v1,16556(v0)

	currTxPkthdrDescIndex = next_index;
80003e98:	3c028001 	lui	v0,0x8001
80003e9c:	ac5040a0 	sw	s0,16544(v0)
80003ea0:	00001021 	move	v0,zero
    return 0;
}
80003ea4:	8fbf001c 	lw	ra,28(sp)
80003ea8:	8fb20018 	lw	s2,24(sp)
80003eac:	8fb10014 	lw	s1,20(sp)
80003eb0:	8fb00010 	lw	s0,16(sp)
80003eb4:	03e00008 	jr	ra
80003eb8:	27bd0020 	addiu	sp,sp,32

80003ebc <swNic_receive>:
*                                                                         
*   OUTPUTS                                                               
*       None
*************************************************************************/
int32 swNic_receive(void** input, uint32* pLen)
{
80003ebc:	27bdffd8 	addiu	sp,sp,-40
80003ec0:	afbf0024 	sw	ra,36(sp)
80003ec4:	afb30020 	sw	s3,32(sp)
80003ec8:	afb2001c 	sw	s2,28(sp)
80003ecc:	afb10018 	sw	s1,24(sp)
80003ed0:	afb00014 	sw	s0,20(sp)
80003ed4:	00808021 	move	s0,a0
80003ed8:	00a08821 	move	s1,a1
    static int32 firstTime = 1;
    char	*data;
    int	ret=-1;

    /* Check OWN bit of descriptors */
    if ( (rxPkthdrRing[0][currRxPkthdrDescIndex] & DESC_OWNED_BIT) == DESC_RISC_OWNED )
80003edc:	3c028001 	lui	v0,0x8001
80003ee0:	8c424098 	lw	v0,16536(v0)
80003ee4:	3c038001 	lui	v1,0x8001
80003ee8:	8c634044 	lw	v1,16452(v1)
80003eec:	00021080 	sll	v0,v0,0x2
80003ef0:	00621021 	addu	v0,v1,v0
80003ef4:	8c420000 	lw	v0,0(v0)
80003ef8:	30440001 	andi	a0,v0,0x1
80003efc:	14800069 	bnez	a0,800040a4 <swNic_receive+0x1e8>
80003f00:	2403ffff 	li	v1,-1
    {
        //ASSERT_ISR(currRxPkthdrDescIndex < rxPkthdrRingCnt[0]);
        
        /* Fetch pkthdr */
        pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][currRxPkthdrDescIndex] & 
80003f04:	2413fffc 	li	s3,-4
80003f08:	00539824 	and	s3,v0,s3
        //ASSERT_ISR(pPkthdr->ph_len); /* Not allow zero packet length */
        //ASSERT_ISR(pPkthdr->ph_len >= 64);
        //ASSERT_ISR(pPkthdr->ph_len <= 1522);

        /* Increment counter */
        rxPktCounter++;
80003f0c:	3c028001 	lui	v0,0x8001
80003f10:	8c4340a8 	lw	v1,16552(v0)
80003f14:	24630001 	addiu	v1,v1,1
80003f18:	ac4340a8 	sw	v1,16552(v0)

	data = pPkthdr->ph_mbuf->m_data;
80003f1c:	8e620000 	lw	v0,0(s3)
80003f20:	8c52000c 	lw	s2,12(v0)
 		extern char eth0_mac[6]; 
	if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )

#else
		extern char eth0_mac[6];
		if ( (data[0]&0x1)||!memcmp(data, eth0_mac, 6) )
80003f24:	92420000 	lbu	v0,0(s2)
80003f28:	30420001 	andi	v0,v0,0x1
80003f2c:	14400007 	bnez	v0,80003f4c <swNic_receive+0x90>
80003f30:	02402021 	move	a0,s2
80003f34:	3c058001 	lui	a1,0x8001
80003f38:	24a529e0 	addiu	a1,a1,10720
80003f3c:	0c0019ed 	jal	800067b4 <memcmp>
80003f40:	24060006 	li	a2,6
80003f44:	1440000e 	bnez	v0,80003f80 <swNic_receive+0xc4>
80003f48:	2403ffff 	li	v1,-1
#endif
		{

		
        /* Output packet */
		        *input = data;
80003f4c:	ae120000 	sw	s2,0(s0)
        *pLen = pPkthdr->ph_len - 4;
80003f50:	96660004 	lhu	a2,4(s3)
80003f54:	24c6fffc 	addiu	a2,a2,-4
80003f58:	ae260000 	sw	a2,0(s1)
			ret = 0;


#if 1 //joey patch for inic
	   // for iNic & 8306 board, the received packet will has VLAN tag
	   if (*(unsigned short *)&(data[12]) == 0x8100)
80003f5c:	9644000c 	lhu	a0,12(s2)
80003f60:	34028100 	li	v0,0x8100
80003f64:	14820006 	bne	a0,v0,80003f80 <swNic_receive+0xc4>
80003f68:	00001821 	move	v1,zero
	   {
		    memcpy(&(data[12]), &(data[16]), *pLen - 16);
80003f6c:	2644000c 	addiu	a0,s2,12
80003f70:	26450010 	addiu	a1,s2,16
80003f74:	0c0019e2 	jal	80006788 <memcpy>
80003f78:	24c6fff0 	addiu	a2,a2,-16
80003f7c:	00001821 	move	v1,zero
			ddump(*input, 64);
//		else
//			ddump(*input, *pLen);
	}
#endif
        if ( !firstTime )
80003f80:	3c028001 	lui	v0,0x8001
80003f84:	8c422a00 	lw	v0,10752(v0)
80003f88:	14400024 	bnez	v0,8000401c <swNic_receive+0x160>
80003f8c:	3c028001 	lui	v0,0x8001
        {
            /* Calculate previous pkthdr and mbuf index */
            pkthdr_index = currRxPkthdrDescIndex;
80003f90:	3c028001 	lui	v0,0x8001
80003f94:	8c444098 	lw	a0,16536(v0)
            if ( --pkthdr_index < 0 )
80003f98:	2484ffff 	addiu	a0,a0,-1
80003f9c:	04810005 	bgez	a0,80003fb4 <swNic_receive+0xf8>
80003fa0:	00042080 	sll	a0,a0,0x2
                pkthdr_index = rxPkthdrRingCnt[0] - 1;
80003fa4:	3c028001 	lui	v0,0x8001
80003fa8:	8c44405c 	lw	a0,16476(v0)
80003fac:	2484ffff 	addiu	a0,a0,-1
#if defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)
            // for rx descriptor runout
            pPkthdr = (struct pktHdr *) (rxPkthdrRing[0][pkthdr_index] & ~(DESC_OWNED_BIT | DESC_WRAP));
80003fb0:	00042080 	sll	a0,a0,0x2
80003fb4:	3c028001 	lui	v0,0x8001
80003fb8:	8c424044 	lw	v0,16452(v0)
80003fbc:	00442021 	addu	a0,v0,a0
80003fc0:	8c850000 	lw	a1,0(a0)
            mbuf_index = ((uint32)(pPkthdr->ph_mbuf) - (rxMbufRing[0] & ~(DESC_OWNED_BIT | DESC_WRAP))) /
80003fc4:	2406fffc 	li	a2,-4
80003fc8:	00a63824 	and	a3,a1,a2
80003fcc:	3c028001 	lui	v0,0x8001
80003fd0:	8c484040 	lw	t0,16448(v0)
80003fd4:	8d080000 	lw	t0,0(t0)
80003fd8:	01063024 	and	a2,t0,a2
80003fdc:	8ce70000 	lw	a3,0(a3)
80003fe0:	00e63023 	subu	a2,a3,a2
80003fe4:	3c07aaaa 	lui	a3,0xaaaa
80003fe8:	34e7aaab 	ori	a3,a3,0xaaab
80003fec:	00c70019 	multu	a2,a3
80003ff0:	00003010 	mfhi	a2
80003ff4:	00063102 	srl	a2,a2,0x4
            if ( --mbuf_index < 0 )
                mbuf_index = rxPkthdrRingCnt[0] - 1;
#endif
        
            /* Reset OWN bit */
            rxPkthdrRing[0][pkthdr_index] |= DESC_SWCORE_OWNED;
80003ff8:	34a50001 	ori	a1,a1,0x1
80003ffc:	ac850000 	sw	a1,0(a0)
            rxMbufRing[mbuf_index] |= DESC_SWCORE_OWNED;
80004000:	00063080 	sll	a2,a2,0x2
80004004:	8c424040 	lw	v0,16448(v0)
80004008:	00463021 	addu	a2,v0,a2
8000400c:	8cc20000 	lw	v0,0(a2)
80004010:	34420001 	ori	v0,v0,0x1
80004014:	08001008 	j	80004020 <swNic_receive+0x164>
80004018:	acc20000 	sw	v0,0(a2)
        }
        else
            firstTime = 0;
8000401c:	ac402a00 	sw	zero,10752(v0)
        
        /* Increment index */
        if ( ++currRxPkthdrDescIndex == rxPkthdrRingCnt[0] )
80004020:	3c048001 	lui	a0,0x8001
80004024:	8c824098 	lw	v0,16536(a0)
80004028:	24420001 	addiu	v0,v0,1
8000402c:	ac824098 	sw	v0,16536(a0)
80004030:	3c048001 	lui	a0,0x8001
80004034:	8c84405c 	lw	a0,16476(a0)
80004038:	14440003 	bne	v0,a0,80004048 <swNic_receive+0x18c>
8000403c:	3c048001 	lui	a0,0x8001
            currRxPkthdrDescIndex = 0;
80004040:	3c028001 	lui	v0,0x8001
80004044:	ac404098 	sw	zero,16536(v0)
        if ( ++currRxMbufDescIndex == rxMbufRingCnt )
80004048:	8c82409c 	lw	v0,16540(a0)
8000404c:	24420001 	addiu	v0,v0,1
80004050:	ac82409c 	sw	v0,16540(a0)
80004054:	3c048001 	lui	a0,0x8001
80004058:	8c8431b8 	lw	a0,12728(a0)
8000405c:	14440004 	bne	v0,a0,80004070 <swNic_receive+0x1b4>
80004060:	3c02b801 	lui	v0,0xb801
            currRxMbufDescIndex = 0;
80004064:	3c028001 	lui	v0,0x8001
80004068:	ac40409c 	sw	zero,16540(v0)

        if ( REG32(CPUIISR) & PKTHDR_DESC_RUNOUT_IP_ALL )
8000406c:	3c02b801 	lui	v0,0xb801
80004070:	3442002c 	ori	v0,v0,0x2c
80004074:	8c440000 	lw	a0,0(v0)
80004078:	3c02007e 	lui	v0,0x7e
8000407c:	00821024 	and	v0,a0,v0
80004080:	10400008 	beqz	v0,800040a4 <swNic_receive+0x1e8>
80004084:	3c04b801 	lui	a0,0xb801
        {
            /* Enable and clear interrupt for continue reception */
            REG32(CPUIIMR) |= PKTHDR_DESC_RUNOUT_IE_ALL;
80004088:	34850028 	ori	a1,a0,0x28
8000408c:	8ca60000 	lw	a2,0(a1)
80004090:	3c02007e 	lui	v0,0x7e
80004094:	00c23025 	or	a2,a2,v0
80004098:	aca60000 	sw	a2,0(a1)
            REG32(CPUIISR) = PKTHDR_DESC_RUNOUT_IP_ALL;
8000409c:	3484002c 	ori	a0,a0,0x2c
800040a0:	ac820000 	sw	v0,0(a0)
        }
        return ret;
    }
    else
        return -1;
}
800040a4:	00601021 	move	v0,v1
800040a8:	8fbf0024 	lw	ra,36(sp)
800040ac:	8fb30020 	lw	s3,32(sp)
800040b0:	8fb2001c 	lw	s2,28(sp)
800040b4:	8fb10018 	lw	s1,24(sp)
800040b8:	8fb00014 	lw	s0,20(sp)
800040bc:	03e00008 	jr	ra
800040c0:	27bd0028 	addiu	sp,sp,40
	...

800040d0 <swTable_readEntry>:



#ifdef CONFIG_RTL865XC
int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
800040d0:	27bdffe8 	addiu	sp,sp,-24
800040d4:	afbf0014 	sw	ra,20(sp)
    uint32 *    entryAddr;

    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
800040d8:	3c02bb80 	lui	v0,0xbb80
800040dc:	34424418 	ori	v0,v0,0x4418
800040e0:	8c470000 	lw	a3,0(v0)
800040e4:	3c030004 	lui	v1,0x4
800040e8:	00e31825 	or	v1,a3,v1
800040ec:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
800040f0:	00403821 	move	a3,v0
800040f4:	3c030008 	lui	v1,0x8
800040f8:	8ce20000 	lw	v0,0(a3)
800040fc:	00431024 	and	v0,v0,v1
80004100:	1040fffd 	beqz	v0,800040f8 <swTable_readEntry+0x28>
80004104:	00000000 	nop

    ASSERT_CSP(entryContent_P);
80004108:	14c00006 	bnez	a2,80004124 <swTable_readEntry+0x54>
8000410c:	3402bb00 	li	v0,0xbb00
80004110:	3c048001 	lui	a0,0x8001
80004114:	0c001cc1 	jal	80007304 <dprintf>
80004118:	248405bc 	addiu	a0,a0,1468
8000411c:	08001047 	j	8000411c <swTable_readEntry+0x4c>
80004120:	00000000 	nop
    
    entryAddr = (uint32 *) (table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE);
80004124:	00822021 	addu	a0,a0,v0
80004128:	000422c0 	sll	a0,a0,0xb
8000412c:	00852821 	addu	a1,a0,a1
80004130:	00052940 	sll	a1,a1,0x5
    
    /* Wait for command ready */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
80004134:	3c03bb80 	lui	v1,0xbb80
80004138:	34634d00 	ori	v1,v1,0x4d00
8000413c:	8c620000 	lw	v0,0(v1)
80004140:	30420001 	andi	v0,v0,0x1
80004144:	1440fffd 	bnez	v0,8000413c <swTable_readEntry+0x6c>
80004148:	00000000 	nop
    
    /* Read registers according to entry width of each table */
    *((uint32 *)entryContent_P + 7) = *(entryAddr + 7);
8000414c:	8ca2001c 	lw	v0,28(a1)
80004150:	acc2001c 	sw	v0,28(a2)
    *((uint32 *)entryContent_P + 6) = *(entryAddr + 6);
80004154:	8ca20018 	lw	v0,24(a1)
80004158:	acc20018 	sw	v0,24(a2)
    *((uint32 *)entryContent_P + 5) = *(entryAddr + 5);
8000415c:	8ca20014 	lw	v0,20(a1)
80004160:	acc20014 	sw	v0,20(a2)
    *((uint32 *)entryContent_P + 4) = *(entryAddr + 4);
80004164:	8ca20010 	lw	v0,16(a1)
80004168:	acc20010 	sw	v0,16(a2)
    *((uint32 *)entryContent_P + 3) = *(entryAddr + 3);
8000416c:	8ca2000c 	lw	v0,12(a1)
80004170:	acc2000c 	sw	v0,12(a2)
    *((uint32 *)entryContent_P + 2) = *(entryAddr + 2);
80004174:	8ca20008 	lw	v0,8(a1)
80004178:	acc20008 	sw	v0,8(a2)
    *((uint32 *)entryContent_P + 1) = *(entryAddr + 1);
8000417c:	8ca20004 	lw	v0,4(a1)
80004180:	acc20004 	sw	v0,4(a2)
    *((uint32 *)entryContent_P + 0) = *(entryAddr + 0);
80004184:	8ca20000 	lw	v0,0(a1)
80004188:	acc20000 	sw	v0,0(a2)

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
8000418c:	3c02bb80 	lui	v0,0xbb80
80004190:	34424418 	ori	v0,v0,0x4418
80004194:	8c440000 	lw	a0,0(v0)
80004198:	3c03fffb 	lui	v1,0xfffb
8000419c:	3463ffff 	ori	v1,v1,0xffff
800041a0:	00831824 	and	v1,a0,v1
800041a4:	ac430000 	sw	v1,0(v0)

    return 0;
}
800041a8:	00001021 	move	v0,zero
800041ac:	8fbf0014 	lw	ra,20(sp)
800041b0:	03e00008 	jr	ra
800041b4:	27bd0018 	addiu	sp,sp,24

800041b8 <swTable_addEntry>:
 */
RTL_STATIC_INLINE void tableAccessForeword(uint32, uint32, void *);

#ifdef CONFIG_RTL865XC
int32 swTable_addEntry(uint32 tableType, uint32 eidx, void *entryContent_P)
{
800041b8:	27bdffe8 	addiu	sp,sp,-24
800041bc:	afbf0014 	sw	ra,20(sp)
    REG32(SWTCR0) = REG32(SWTCR0) | EN_STOP_TLU;
800041c0:	3c02bb80 	lui	v0,0xbb80
800041c4:	34424418 	ori	v0,v0,0x4418
800041c8:	8c470000 	lw	a3,0(v0)
800041cc:	3c030004 	lui	v1,0x4
800041d0:	00e31825 	or	v1,a3,v1
800041d4:	ac430000 	sw	v1,0(v0)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);
800041d8:	00403821 	move	a3,v0
800041dc:	3c030008 	lui	v1,0x8
800041e0:	8ce20000 	lw	v0,0(a3)
800041e4:	00431024 	and	v0,v0,v1
800041e8:	1040fffd 	beqz	v0,800041e0 <swTable_addEntry+0x28>
800041ec:	00000000 	nop


//RTL_STATIC_INLINE void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
void tableAccessForeword(uint32 tableType, uint32 eidx,     void *entryContent_P)
{
    ASSERT_CSP(entryContent_P);
800041f0:	14c00006 	bnez	a2,8000420c <swTable_addEntry+0x54>
800041f4:	3c03bb80 	lui	v1,0xbb80
800041f8:	3c048001 	lui	a0,0x8001
800041fc:	0c001cc1 	jal	80007304 <dprintf>
80004200:	248405bc 	addiu	a0,a0,1468
80004204:	08001081 	j	80004204 <swTable_addEntry+0x4c>
80004208:	00000000 	nop

    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
8000420c:	34634d00 	ori	v1,v1,0x4d00
80004210:	8c620000 	lw	v0,0(v1)
80004214:	30420001 	andi	v0,v0,0x1
80004218:	1440fffd 	bnez	v0,80004210 <swTable_addEntry+0x58>
8000421c:	3c02bb80 	lui	v0,0xbb80
    
    /* Write registers according to entry width of each table */
    REG32(TCR7) = *((uint32 *)entryContent_P + 7);
80004220:	8cc7001c 	lw	a3,28(a2)
80004224:	34434d3c 	ori	v1,v0,0x4d3c
80004228:	ac670000 	sw	a3,0(v1)
    REG32(TCR6) = *((uint32 *)entryContent_P + 6);
8000422c:	8cc70018 	lw	a3,24(a2)
80004230:	34434d38 	ori	v1,v0,0x4d38
80004234:	ac670000 	sw	a3,0(v1)
    REG32(TCR5) = *((uint32 *)entryContent_P + 5);
80004238:	8cc70014 	lw	a3,20(a2)
8000423c:	34434d34 	ori	v1,v0,0x4d34
80004240:	ac670000 	sw	a3,0(v1)
    REG32(TCR4) = *((uint32 *)entryContent_P + 4);
80004244:	8cc70010 	lw	a3,16(a2)
80004248:	34434d30 	ori	v1,v0,0x4d30
8000424c:	ac670000 	sw	a3,0(v1)
    REG32(TCR3) = *((uint32 *)entryContent_P + 3);
80004250:	8cc7000c 	lw	a3,12(a2)
80004254:	34434d2c 	ori	v1,v0,0x4d2c
80004258:	ac670000 	sw	a3,0(v1)
    REG32(TCR2) = *((uint32 *)entryContent_P + 2);
8000425c:	8cc70008 	lw	a3,8(a2)
80004260:	34434d28 	ori	v1,v0,0x4d28
80004264:	ac670000 	sw	a3,0(v1)
    REG32(TCR1) = *((uint32 *)entryContent_P + 1);
80004268:	8cc70004 	lw	a3,4(a2)
8000426c:	34434d24 	ori	v1,v0,0x4d24
80004270:	ac670000 	sw	a3,0(v1)
    REG32(TCR0) = *(uint32 *)entryContent_P;
80004274:	8cc60000 	lw	a2,0(a2)
80004278:	34434d20 	ori	v1,v0,0x4d20
8000427c:	ac660000 	sw	a2,0(v1)
    
    /* Fill address */
    REG32(SWTAA) = table_access_addr_base(tableType) + eidx * TABLE_ENTRY_DISTANCE;
80004280:	3403bb00 	li	v1,0xbb00
80004284:	00832021 	addu	a0,a0,v1
80004288:	000422c0 	sll	a0,a0,0xb
8000428c:	00852821 	addu	a1,a0,a1
80004290:	00052940 	sll	a1,a1,0x5
80004294:	34434d08 	ori	v1,v0,0x4d08
80004298:	ac650000 	sw	a1,0(v1)
    while ((REG32(SWTCR0) & STOP_TLU_READY) == 0);

    tableAccessForeword(tableType, eidx, entryContent_P);
        
    /* Activate add command */
    REG32(SWTACR) = ACTION_START | CMD_ADD;
8000429c:	34424d00 	ori	v0,v0,0x4d00
800042a0:	24030003 	li	v1,3
800042a4:	ac430000 	sw	v1,0(v0)
    
    /* Wait for command done */
    while ( (REG32(SWTACR) & ACTION_MASK) != ACTION_DONE );
800042a8:	00401821 	move	v1,v0
800042ac:	8c620000 	lw	v0,0(v1)
800042b0:	30420001 	andi	v0,v0,0x1
800042b4:	1440fffd 	bnez	v0,800042ac <swTable_addEntry+0xf4>
800042b8:	3c02bb80 	lui	v0,0xbb80

    REG32(SWTCR0) = REG32(SWTCR0) & ~EN_STOP_TLU;
800042bc:	34434418 	ori	v1,v0,0x4418
800042c0:	8c650000 	lw	a1,0(v1)
800042c4:	3c04fffb 	lui	a0,0xfffb
800042c8:	3484ffff 	ori	a0,a0,0xffff
800042cc:	00a42024 	and	a0,a1,a0
800042d0:	ac640000 	sw	a0,0(v1)

    /* Check status */
    if ( (REG32(SWTASR) & TABSTS_MASK) != TABSTS_SUCCESS )
800042d4:	34424d04 	ori	v0,v0,0x4d04
800042d8:	8c430000 	lw	v1,0(v0)
800042dc:	30630001 	andi	v1,v1,0x1
        return ECOLLISION;
    else
        return 0;
}
800042e0:	24020058 	li	v0,88
800042e4:	0003100a 	movz	v0,zero,v1
800042e8:	8fbf0014 	lw	ra,20(sp)
800042ec:	03e00008 	jr	ra
800042f0:	27bd0018 	addiu	sp,sp,24
	...

80004300 <lx4180_ReadStatus>:
extern int32 swTable_readEntry(uint32 tableType, uint32 eidx, void *entryContent_P);

#include <asm/mipsregs.h>
//wei add
int lx4180_ReadStatus()
{
80004300:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg;
	reg= read_32bit_cp0_register(CP0_STATUS);
80004304:	40026000 	mfc0	v0,c0_status
80004308:	afa20000 	sw	v0,0(sp)
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return reg;
80004314:	8fa20000 	lw	v0,0(sp)

}
80004318:	03e00008 	jr	ra
8000431c:	27bd0008 	addiu	sp,sp,8

80004320 <lx4180_WriteStatus>:
void lx4180_WriteStatus(int s)
{
80004320:	27bdfff8 	addiu	sp,sp,-8
   volatile unsigned int reg=s;
80004324:	afa40000 	sw	a0,0(sp)
	write_32bit_cp0_register(CP0_STATUS, reg);
80004328:	8fa20000 	lw	v0,0(sp)
8000432c:	40826000 	mtc0	v0,c0_status
80004330:	00000040 	ssnop
80004334:	00000040 	ssnop
80004338:	00000040 	ssnop
8000433c:	00000040 	ssnop
	...
	__asm__ volatile("nop");	// david
   	__asm__ volatile("nop");   
	return ;

}
80004348:	03e00008 	jr	ra
8000434c:	27bd0008 	addiu	sp,sp,8

80004350 <vlanTable_setStpStatusOfAllPorts>:


int32 vlanTable_setStpStatusOfAllPorts(uint32 vid, uint32 STPStatus)
{

}
80004350:	03e00008 	jr	ra
80004354:	00000000 	nop

80004358 <vlanTable_create>:




int32 vlanTable_create(uint32 vid, rtl_vlan_param_t * param)
{
80004358:	27bdffc0 	addiu	sp,sp,-64
8000435c:	afbf003c 	sw	ra,60(sp)
80004360:	afb20038 	sw	s2,56(sp)
80004364:	afb10034 	sw	s1,52(sp)
80004368:	afb00030 	sw	s0,48(sp)
8000436c:	00809021 	move	s2,a0
    vlan_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
80004370:	14a00006 	bnez	a1,8000438c <vlanTable_create+0x34>
80004374:	00a08021 	move	s0,a1
80004378:	3c048001 	lui	a0,0x8001
8000437c:	0c001cc1 	jal	80007304 <dprintf>
80004380:	248405bc 	addiu	a0,a0,1468
80004384:	080010e1 	j	80004384 <vlanTable_create+0x2c>
80004388:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
8000438c:	0c0010c0 	jal	80004300 <lx4180_ReadStatus>
80004390:	00000000 	nop
    if (0!=temp&0x1) {
80004394:	1040000c 	beqz	v0,800043c8 <vlanTable_create+0x70>
80004398:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
8000439c:	2402fffe 	li	v0,-2
800043a0:	0c0010c8 	jal	80004320 <lx4180_WriteStatus>
800043a4:	02222024 	and	a0,s1,v0
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
800043a8:	24040006 	li	a0,6
800043ac:	02402821 	move	a1,s2
800043b0:	0c001034 	jal	800040d0 <swTable_readEntry>
800043b4:	27a60010 	addiu	a2,sp,16
    
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
800043b8:	0c0010c8 	jal	80004320 <lx4180_WriteStatus>
800043bc:	02202021 	move	a0,s1
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
800043c0:	080010f7 	j	800043dc <vlanTable_create+0x84>
800043c4:	27b10010 	addiu	s1,sp,16
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }
    
    swTable_readEntry(TYPE_VLAN_TABLE, vid, &entryContent);
800043c8:	24040006 	li	a0,6
800043cc:	02402821 	move	a1,s2
800043d0:	0c001034 	jal	800040d0 <swTable_readEntry>
800043d4:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
800043d8:	27b10010 	addiu	s1,sp,16
800043dc:	02202021 	move	a0,s1
800043e0:	00002821 	move	a1,zero
800043e4:	0c0019d9 	jal	80006764 <memset>
800043e8:	24060020 	li	a2,32
    entryContent.memberPort = param->memberPort & ALL_PORT_MASK;
800043ec:	92020003 	lbu	v0,3(s0)
    entryContent.egressUntag = param->egressUntag;
800043f0:	8e030004 	lw	v1,4(s0)
800043f4:	3042003f 	andi	v0,v0,0x3f
800043f8:	7c627244 	ins	v0,v1,0x9,0x6
    entryContent.fid = param->fid;
800043fc:	8e030008 	lw	v1,8(s0)
80004400:	7c630f80 	ext	v1,v1,0x1e,0x2
80004404:	7c629c84 	ins	v0,v1,0x12,0x2
80004408:	afa20010 	sw	v0,16(sp)
#if (defined(CONFIG_RTL8196D) || defined(CONFIG_RTL8196E)||defined(CONFIG_RTL8881A)) && !defined(CONFIG_RTL8198C)
    entryContent.vid = vid;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
8000440c:	24040006 	li	a0,6
80004410:	02402821 	move	a1,s2
80004414:	0c00106e 	jal	800041b8 <swTable_addEntry>
80004418:	02203021 	move	a2,s1
8000441c:	14400006 	bnez	v0,80004438 <vlanTable_create+0xe0>
80004420:	8fbf003c 	lw	ra,60(sp)
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
}
80004424:	8fb20038 	lw	s2,56(sp)
80004428:	8fb10034 	lw	s1,52(sp)
8000442c:	8fb00030 	lw	s0,48(sp)
80004430:	03e00008 	jr	ra
80004434:	27bd0040 	addiu	sp,sp,64
    /* Write into hardware */
    if ( swTable_addEntry(TYPE_VLAN_TABLE, vid, &entryContent) == 0 )
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
80004438:	3c048001 	lui	a0,0x8001
8000443c:	0c001cc1 	jal	80007304 <dprintf>
80004440:	248405bc 	addiu	a0,a0,1468
80004444:	08001111 	j	80004444 <vlanTable_create+0xec>
80004448:	00000000 	nop

8000444c <swCore_netifCreate>:
        ASSERT_CSP( 0 );
}
#endif

int32 swCore_netifCreate(uint32 idx, rtl_netif_param_t * param)
{
8000444c:	27bdffc0 	addiu	sp,sp,-64
80004450:	afbf003c 	sw	ra,60(sp)
80004454:	afb20038 	sw	s2,56(sp)
80004458:	afb10034 	sw	s1,52(sp)
8000445c:	afb00030 	sw	s0,48(sp)
80004460:	00809021 	move	s2,a0
    netif_table_t    entryContent;
    uint32	temp,temp2;
    
    ASSERT_CSP(param);
80004464:	14a00006 	bnez	a1,80004480 <swCore_netifCreate+0x34>
80004468:	00a08021 	move	s0,a1
8000446c:	3c048001 	lui	a0,0x8001
80004470:	0c001cc1 	jal	80007304 <dprintf>
80004474:	248405bc 	addiu	a0,a0,1468
80004478:	0800111e 	j	80004478 <swCore_netifCreate+0x2c>
8000447c:	00000000 	nop
    
    // disable interrupt
    // I don't know the reason but if you want to use "-O" flag, must disalbe interrupt before swTable_readEntry();
    temp = lx4180_ReadStatus();
80004480:	0c0010c0 	jal	80004300 <lx4180_ReadStatus>
80004484:	00000000 	nop
    if (0!=temp&0x1) {
80004488:	1040000c 	beqz	v0,800044bc <swCore_netifCreate+0x70>
8000448c:	00408821 	move	s1,v0
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
80004490:	2402fffe 	li	v0,-2
80004494:	0c0010c8 	jal	80004320 <lx4180_WriteStatus>
80004498:	02222024 	and	a0,s1,v0
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
8000449c:	24040004 	li	a0,4
800044a0:	02402821 	move	a1,s2
800044a4:	0c001034 	jal	800040d0 <swTable_readEntry>
800044a8:	27a60010 	addiu	a2,sp,16

    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
800044ac:	0c0010c8 	jal	80004320 <lx4180_WriteStatus>
800044b0:	02202021 	move	a0,s1
    }
    
    if ( entryContent.valid )
800044b4:	08001134 	j	800044d0 <swCore_netifCreate+0x84>
800044b8:	8fa20010 	lw	v0,16(sp)
    if (0!=temp&0x1) {
	    temp2 = temp&0xfffffffe;
	    lx4180_WriteStatus(temp2);
    }

    swTable_readEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent);
800044bc:	24040004 	li	a0,4
800044c0:	02402821 	move	a1,s2
800044c4:	0c001034 	jal	800040d0 <swTable_readEntry>
800044c8:	27a60010 	addiu	a2,sp,16
    // restore status register
    if (0!=temp&0x1) {
	    lx4180_WriteStatus(temp);
    }
    
    if ( entryContent.valid )
800044cc:	8fa20010 	lw	v0,16(sp)
800044d0:	30420001 	andi	v0,v0,0x1
800044d4:	14400066 	bnez	v0,80004670 <swCore_netifCreate+0x224>
800044d8:	24030011 	li	v1,17
    {
       return EEXIST;
    }

    bzero( (void *) &entryContent, sizeof(entryContent) );
800044dc:	27a40010 	addiu	a0,sp,16
800044e0:	00002821 	move	a1,zero
800044e4:	0c0019d9 	jal	80006764 <memset>
800044e8:	24060020 	li	a2,32
    entryContent.valid = param->valid;
800044ec:	8e030020 	lw	v1,32(s0)
800044f0:	7c620780 	ext	v0,v1,0x1e,0x1
800044f4:	8fa40010 	lw	a0,16(sp)
800044f8:	7c440004 	ins	a0,v0,0x0,0x1
    entryContent.vid = param->vid;
800044fc:	9602000a 	lhu	v0,10(s0)
80004500:	7c446044 	ins	a0,v0,0x1,0xc

    entryContent.mac47_19 = ((param->gMac.mac47_32 << 13) | (param->gMac.mac31_16 >> 3)) & 0x1FFFFFFF;
80004504:	96050002 	lhu	a1,2(s0)
80004508:	000530c2 	srl	a2,a1,0x3
8000450c:	96020000 	lhu	v0,0(s0)
80004510:	00021340 	sll	v0,v0,0xd
80004514:	00c23025 	or	a2,a2,v0
80004518:	8fa20014 	lw	v0,20(sp)
8000451c:	7cc2e004 	ins	v0,a2,0x0,0x1d
    entryContent.mac18_0 = ((param->gMac.mac31_16 << 16) | param->gMac.mac15_0) & 0x7FFFF;
80004520:	00052c00 	sll	a1,a1,0x10
80004524:	96060004 	lhu	a2,4(s0)
80004528:	00a62825 	or	a1,a1,a2
8000452c:	3c060007 	lui	a2,0x7
80004530:	34c6ffff 	ori	a2,a2,0xffff
80004534:	00a62824 	and	a1,a1,a2
80004538:	7ca4fb44 	ins	a0,a1,0xd,0x13
8000453c:	afa40010 	sw	a0,16(sp)

#if defined(CONFIG_RTL8198C)
	entryContent.inACLStartH = (param->inAclStart >>1)&0x7f;
80004540:	8e05000c 	lw	a1,12(s0)
80004544:	7ca63040 	ext	a2,a1,0x1,0x7
80004548:	8fa40018 	lw	a0,24(sp)
8000454c:	7cc43004 	ins	a0,a2,0x0,0x7
	entryContent.inACLStartL = param->inAclStart&0x1;
80004550:	7ca2ffc4 	ins	v0,a1,0x1f,0x1
	entryContent.inACLEnd    = param->inAclEnd;
80004554:	8e050010 	lw	a1,16(s0)
80004558:	7ca471c4 	ins	a0,a1,0x7,0x8
	entryContent.outACLStart = param->outAclStart;
8000455c:	8e050014 	lw	a1,20(s0)
80004560:	7ca4b3c4 	ins	a0,a1,0xf,0x8
	entryContent.outACLEnd   = param->outAclEnd;
80004564:	8e050018 	lw	a1,24(s0)
80004568:	7ca4f5c4 	ins	a0,a1,0x17,0x8
8000456c:	afa40018 	sw	a0,24(sp)
	entryContent.enHWRouteV6 = 0;
80004570:	7c02f784 	ins	v0,zero,0x1e,0x1
	entryContent.enHWRoute   = param->enableRoute;
80004574:	7c6307c0 	ext	v1,v1,0x1f,0x1
80004578:	7c62ef44 	ins	v0,v1,0x1d,0x1
8000457c:	afa20014 	sw	v0,20(sp)
	switch(param->macAddrNumber) {
80004580:	96020008 	lhu	v0,8(s0)
80004584:	2c420009 	sltiu	v0,v0,9
80004588:	10400039 	beqz	v0,80004670 <swCore_netifCreate+0x224>
8000458c:	24030011 	li	v1,17
80004590:	96030008 	lhu	v1,8(s0)
80004594:	00031880 	sll	v1,v1,0x2
80004598:	3c028001 	lui	v0,0x8001
8000459c:	2442eae0 	addiu	v0,v0,-5408
800045a0:	00431021 	addu	v0,v0,v1
800045a4:	8c420000 	lw	v0,0(v0)
800045a8:	00400008 	jr	v0
800045ac:	00000000 	nop
		case 0:
		case 1:
		    entryContent.macMaskL = 1;
800045b0:	8fa20018 	lw	v0,24(sp)
800045b4:	24030001 	li	v1,1
800045b8:	7c62ffc4 	ins	v0,v1,0x1f,0x1
800045bc:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
800045c0:	8fa2001c 	lw	v0,28(sp)
800045c4:	24030003 	li	v1,3
800045c8:	7c620804 	ins	v0,v1,0x0,0x2
		break;
800045cc:	0800118b 	j	8000462c <swCore_netifCreate+0x1e0>
800045d0:	afa2001c 	sw	v0,28(sp)
		case 2:
		    entryContent.macMaskL = 0;
800045d4:	8fa20018 	lw	v0,24(sp)
800045d8:	7c02ffc4 	ins	v0,zero,0x1f,0x1
800045dc:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 3;
800045e0:	8fa2001c 	lw	v0,28(sp)
800045e4:	24030003 	li	v1,3
800045e8:	7c620804 	ins	v0,v1,0x0,0x2
		break;
800045ec:	0800118b 	j	8000462c <swCore_netifCreate+0x1e0>
800045f0:	afa2001c 	sw	v0,28(sp)
		case 4:
		    entryContent.macMaskL = 0;
800045f4:	8fa20018 	lw	v0,24(sp)
800045f8:	7c02ffc4 	ins	v0,zero,0x1f,0x1
800045fc:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 2;
80004600:	8fa2001c 	lw	v0,28(sp)
80004604:	24030002 	li	v1,2
80004608:	7c620804 	ins	v0,v1,0x0,0x2
		break;
8000460c:	0800118b 	j	8000462c <swCore_netifCreate+0x1e0>
80004610:	afa2001c 	sw	v0,28(sp)
		case 8:
		    entryContent.macMaskL = 0;
80004614:	8fa20018 	lw	v0,24(sp)
80004618:	7c02ffc4 	ins	v0,zero,0x1f,0x1
8000461c:	afa20018 	sw	v0,24(sp)
		    entryContent.macMaskH = 0;
80004620:	8fa2001c 	lw	v0,28(sp)
80004624:	7c020804 	ins	v0,zero,0x0,0x2
80004628:	afa2001c 	sw	v0,28(sp)
			break;
		default:
		    return EEXIST;//Not permitted macNumber value
	}

	entryContent.mtu   = param->mtu;
8000462c:	8e03001c 	lw	v1,28(s0)
80004630:	8fa2001c 	lw	v0,28(sp)
80004634:	7c628084 	ins	v0,v1,0x2,0xf
	entryContent.mtuv6 = param->mtu;
80004638:	7c62fc44 	ins	v0,v1,0x11,0xf
8000463c:	afa2001c 	sw	v0,28(sp)
    entryContent.mtuH = param->mtu >> 3;
    entryContent.mtuL = param->mtu & 0x7;
#endif

    /* Write into hardware */
    if ( swTable_addEntry(TYPE_NETINTERFACE_TABLE, idx, &entryContent) == 0 )
80004640:	24040004 	li	a0,4
80004644:	02402821 	move	a1,s2
80004648:	0c00106e 	jal	800041b8 <swTable_addEntry>
8000464c:	27a60010 	addiu	a2,sp,16
80004650:	10400007 	beqz	v0,80004670 <swCore_netifCreate+0x224>
80004654:	00001821 	move	v1,zero
        return 0;
    else
        /* There might be something wrong */
        ASSERT_CSP( 0 );
80004658:	3c048001 	lui	a0,0x8001
8000465c:	0c001cc1 	jal	80007304 <dprintf>
80004660:	248405bc 	addiu	a0,a0,1468
80004664:	08001199 	j	80004664 <swCore_netifCreate+0x218>
80004668:	00000000 	nop
8000466c:	24030011 	li	v1,17
}
80004670:	00601021 	move	v0,v1
80004674:	8fbf003c 	lw	ra,60(sp)
80004678:	8fb20038 	lw	s2,56(sp)
8000467c:	8fb10034 	lw	s1,52(sp)
80004680:	8fb00030 	lw	s0,48(sp)
80004684:	03e00008 	jr	ra
80004688:	27bd0040 	addiu	sp,sp,64
8000468c:	00000000 	nop

80004690 <spi_sector_erase>:
	}
}

//SPI Flash Erase Sector
unsigned int spi_sector_erase(unsigned int uiChip, unsigned int uiAddr)
{
80004690:	27bdffe8 	addiu	sp,sp,-24
80004694:	afbf0014 	sw	ra,20(sp)
	KDEBUG("spi_sector_erase: uiChip=%x; uiAddr=%x\n", uiChip, uiAddr);
	return spi_flash_info[uiChip].pfErase(uiChip, uiAddr);
80004698:	000418c0 	sll	v1,a0,0x3
8000469c:	00041180 	sll	v0,a0,0x6
800046a0:	00621821 	addu	v1,v1,v0
800046a4:	3c028001 	lui	v0,0x8001
800046a8:	24425218 	addiu	v0,v0,21016
800046ac:	00431021 	addu	v0,v0,v1
800046b0:	8c420034 	lw	v0,52(v0)
800046b4:	0040f809 	jalr	v0
800046b8:	308400ff 	andi	a0,a0,0xff
}
800046bc:	8fbf0014 	lw	ra,20(sp)
800046c0:	03e00008 	jr	ra
800046c4:	27bd0018 	addiu	sp,sp,24

800046c8 <spi_read>:
	NDEBUG("\n");
}
*/
/************************************ for old interface ************************************/
unsigned int spi_read(unsigned int uiChip, unsigned int uiAddr, unsigned int* puiDataOut)
{
800046c8:	27bdffe8 	addiu	sp,sp,-24
800046cc:	afbf0014 	sw	ra,20(sp)
800046d0:	00c03821 	move	a3,a2
	KDEBUG("spi_read: uiChip=%x; uiAddr=%x; uiLen=4; puiDataOut=%x\n", uiChip, uiAddr, (unsigned long)puiDataOut);
	return spi_flash_info[uiChip].pfRead(uiChip, uiAddr, 4, (unsigned char*)puiDataOut);
800046d4:	000418c0 	sll	v1,a0,0x3
800046d8:	00041180 	sll	v0,a0,0x6
800046dc:	00621821 	addu	v1,v1,v0
800046e0:	3c028001 	lui	v0,0x8001
800046e4:	24425218 	addiu	v0,v0,21016
800046e8:	00431021 	addu	v0,v0,v1
800046ec:	8c42003c 	lw	v0,60(v0)
800046f0:	308400ff 	andi	a0,a0,0xff
800046f4:	0040f809 	jalr	v0
800046f8:	24060004 	li	a2,4
}
800046fc:	8fbf0014 	lw	ra,20(sp)
80004700:	03e00008 	jr	ra
80004704:	27bd0018 	addiu	sp,sp,24

80004708 <flashread>:

int flashread (unsigned long dst, unsigned int src, unsigned long length)
{
80004708:	27bdffe8 	addiu	sp,sp,-24
8000470c:	afbf0014 	sw	ra,20(sp)
80004710:	00803821 	move	a3,a0

	KDEBUG("flashread: chip(uiChip)=%d; dst(pucBuffer)=%x; src(uiAddr)=%x; length=%x\n", 0, dst, src, length);
	return spi_flash_info[0].pfRead(0, src, length, (unsigned char*)dst);
80004714:	3c028001 	lui	v0,0x8001
80004718:	8c425254 	lw	v0,21076(v0)
8000471c:	0040f809 	jalr	v0
80004720:	00002021 	move	a0,zero
}
80004724:	8fbf0014 	lw	ra,20(sp)
80004728:	03e00008 	jr	ra
8000472c:	27bd0018 	addiu	sp,sp,24

80004730 <flashwrite>:

int flashwrite(unsigned long dst, unsigned long src, unsigned long length)
{
80004730:	27bdffe8 	addiu	sp,sp,-24
80004734:	afbf0014 	sw	ra,20(sp)
80004738:	00801821 	move	v1,a0
8000473c:	00a03821 	move	a3,a1

	KDEBUG("flashwrite: dst(uiAddr)=%x; src(pucBuffer)=%x; length=%x; \n", dst, src, length);
	return spi_flash_info[0].pfWrite(0, dst, length, (unsigned char*)src);
80004740:	3c028001 	lui	v0,0x8001
80004744:	8c425250 	lw	v0,21072(v0)
80004748:	00002021 	move	a0,zero
8000474c:	0040f809 	jalr	v0
80004750:	00602821 	move	a1,v1
}
80004754:	8fbf0014 	lw	ra,20(sp)
80004758:	03e00008 	jr	ra
8000475c:	27bd0018 	addiu	sp,sp,24

80004760 <spi_flw_image>:

int spi_flw_image(unsigned int chip, unsigned int flash_addr_offset ,unsigned char *image_addr, unsigned int image_size)
{
80004760:	27bdffe8 	addiu	sp,sp,-24
80004764:	afbf0014 	sw	ra,20(sp)
80004768:	00c01821 	move	v1,a2
	KDEBUG("spi_flw_image: chip=%x; flash_addr_offset=%x; image_addr=%x; image_size=%x\n", chip, flash_addr_offset, (unsigned int)image_addr, image_size);
	return spi_flash_info[chip].pfWrite(chip, flash_addr_offset, image_size, image_addr);
8000476c:	000430c0 	sll	a2,a0,0x3
80004770:	00041180 	sll	v0,a0,0x6
80004774:	00c21021 	addu	v0,a2,v0
80004778:	3c068001 	lui	a2,0x8001
8000477c:	24c65218 	addiu	a2,a2,21016
80004780:	00461021 	addu	v0,v0,a2
80004784:	8c420038 	lw	v0,56(v0)
80004788:	308400ff 	andi	a0,a0,0xff
8000478c:	00e03021 	move	a2,a3
80004790:	0040f809 	jalr	v0
80004794:	00603821 	move	a3,v1
}
80004798:	8fbf0014 	lw	ra,20(sp)
8000479c:	03e00008 	jr	ra
800047a0:	27bd0018 	addiu	sp,sp,24

800047a4 <spi_flw_image_mio_8198>:
int spi_flw_image_mio_8198(unsigned int cnt, unsigned int flash_addr_offset , unsigned char *image_addr, unsigned int image_size)
{
800047a4:	27bdffe8 	addiu	sp,sp,-24
800047a8:	afbf0014 	sw	ra,20(sp)
800047ac:	00c01821 	move	v1,a2
	/*RTL8198C:Makes image size to align by 0x1000*/
	#ifdef CONFIG_RTL8198C 
 
	if(image_size%0x1000!=0)
800047b0:	30e20fff 	andi	v0,a3,0xfff
800047b4:	10400004 	beqz	v0,800047c8 <spi_flw_image_mio_8198+0x24>
800047b8:	00e03021 	move	a2,a3
	{
		image_size=image_size+(0x1000-(image_size%0x1000));
800047bc:	2402f000 	li	v0,-4096
800047c0:	00e23024 	and	a2,a3,v0
800047c4:	24c61000 	addiu	a2,a2,4096
	}
	#endif 

	KDEBUG("spi_flw_image_mio_8198: cnt=%x; flash_addr_offset=%x; image_addr=%x; image_size=%x\n", cnt, flash_addr_offset, (unsigned int)image_addr, 	image_size);
	return spi_flash_info[cnt].pfWrite(cnt, flash_addr_offset, image_size, image_addr);
800047c8:	000438c0 	sll	a3,a0,0x3
800047cc:	00041180 	sll	v0,a0,0x6
800047d0:	00e21021 	addu	v0,a3,v0
800047d4:	3c078001 	lui	a3,0x8001
800047d8:	24e75218 	addiu	a3,a3,21016
800047dc:	00471021 	addu	v0,v0,a3
800047e0:	8c420038 	lw	v0,56(v0)
800047e4:	308400ff 	andi	a0,a0,0xff
800047e8:	0040f809 	jalr	v0
800047ec:	00603821 	move	a3,v1
}
800047f0:	8fbf0014 	lw	ra,20(sp)
800047f4:	03e00008 	jr	ra
800047f8:	27bd0018 	addiu	sp,sp,24

800047fc <spi_erase_chip>:
	return uiRet;
}

// Erase whole chip
unsigned int spi_erase_chip(unsigned int uiChip)
{
800047fc:	27bdffe8 	addiu	sp,sp,-24
80004800:	afbf0014 	sw	ra,20(sp)
	unsigned int uiRet;
	// Spansion
	KDEBUG("spi_erase_chip: uiChip=%x\n", uiChip);
	uiRet = ComSrlCmd_CE(uiChip);
80004804:	0c001765 	jal	80005d94 <ComSrlCmd_CE>
80004808:	308400ff 	andi	a0,a0,0xff
	return uiRet;
}
8000480c:	8fbf0014 	lw	ra,20(sp)
80004810:	03e00008 	jr	ra
80004814:	27bd0018 	addiu	sp,sp,24

80004818 <spi_block_erase>:
	return spi_flash_info[uiChip].pfErase(uiChip, uiAddr);
}

// SPI Flash Erase Block
unsigned int spi_block_erase(unsigned int uiChip, unsigned int uiAddr)
{
80004818:	27bdffe8 	addiu	sp,sp,-24
8000481c:	afbf0014 	sw	ra,20(sp)
	KDEBUG("spi_block_erase: uiChip=%x; uiAddr=%x\n", uiChip, uiAddr);
	unsigned int uiRet;
	uiRet = ComSrlCmd_BE(uiChip, uiAddr);
80004820:	0c001777 	jal	80005ddc <ComSrlCmd_BE>
80004824:	308400ff 	andi	a0,a0,0xff
	return uiRet;
}
80004828:	8fbf0014 	lw	ra,20(sp)
8000482c:	03e00008 	jr	ra
80004830:	27bd0018 	addiu	sp,sp,24

80004834 <spi_probe>:
	rstSPIFlash(0);
}

// SPI Flash Probe
void spi_probe()
{
80004834:	27bdffe8 	addiu	sp,sp,-24
80004838:	afbf0014 	sw	ra,20(sp)
//	unsigned int uiCount;
//	uiCount = sizeof(spi_flash_registed) / sizeof(struct spi_flash_known);
	KDEBUG("spi_probe: spi_regist(0, 1)\n");
	for(i=0;i<CONFIG_FLASH_NUMBER;i++)
	{
		spi_regist(i);
8000483c:	0c001626 	jal	80005898 <spi_regist>
80004840:	00002021 	move	a0,zero
	}
}
80004844:	8fbf0014 	lw	ra,20(sp)
80004848:	03e00008 	jr	ra
8000484c:	27bd0018 	addiu	sp,sp,24

80004850 <spi_pio_init>:
{
	KDEBUG("spi_pio_init: rstSPIFlash(0)");
	rstSPIFlash(0);
}
void spi_pio_init(void)
{
80004850:	27bdffe8 	addiu	sp,sp,-24
80004854:	afbf0014 	sw	ra,20(sp)
	KDEBUG("spi_pio_init: rstSPIFlash(0)");
	rstSPIFlash(0);
80004858:	0c0015da 	jal	80005768 <rstSPIFlash>
8000485c:	00002021 	move	a0,zero
}
80004860:	8fbf0014 	lw	ra,20(sp)
80004864:	03e00008 	jr	ra
80004868:	27bd0018 	addiu	sp,sp,24

8000486c <spi_pio_init_8198>:
extern struct spi_flash_type	spi_flash_info[2];
//extern struct spi_flash_known spi_flash_registed[];

// SPI Flash Init
void spi_pio_init_8198(void)
{
8000486c:	27bdffe8 	addiu	sp,sp,-24
80004870:	afbf0014 	sw	ra,20(sp)
	KDEBUG("spi_pio_init: rstSPIFlash(0)");
	rstSPIFlash(0);
80004874:	0c0015da 	jal	80005768 <rstSPIFlash>
80004878:	00002021 	move	a0,zero
}
8000487c:	8fbf0014 	lw	ra,20(sp)
80004880:	03e00008 	jr	ra
80004884:	27bd0018 	addiu	sp,sp,24
	...

80004890 <CheckDramFreq>:
	//SPI_REG_LOAD(SFCR2, 0x0bb08000);
	LDEBUG("set_flash_info: ucChip=%x; chip_id=%x; device_cap=%x; block_size=%x; sector_size=%x; page_size=%x; chip_name=%s\n", ucChip, chip_id, device_cap, block_size, sector_size, page_size, chip_name);
}

unsigned int CheckDramFreq(void)                       //JSW:For 8196C
{
80004890:	27bdffc0 	addiu	sp,sp,-64
	//unsigned short usFreqVal[] = {65, 181, 150, 125, 156, 168, 237, 193};
	//unsigned short usFreqVal[] = {156, 193, 181, 231, 214, 125, 237, 168}; //8196D

	//unsigned short usFreqVal[] ={ 250,290,	330, 370, 410,  450,  490,  530,  390,  595, 625, 655, 685,  720,  755,  785};//8198C

	unsigned short usFreqVal[]={ 250,270,290,310,330,350,370,565, 410,430,450,470,490,510 ,530,550 , 390, 580, 595,610, 625, 640,655,670, \
80004894:	3c028001 	lui	v0,0x8001
80004898:	2442eb10 	addiu	v0,v0,-5360
8000489c:	03a01821 	move	v1,sp
800048a0:	24440040 	addiu	a0,v0,64
800048a4:	8c480000 	lw	t0,0(v0)
800048a8:	8c470004 	lw	a3,4(v0)
800048ac:	8c460008 	lw	a2,8(v0)
800048b0:	8c45000c 	lw	a1,12(v0)
800048b4:	ac680000 	sw	t0,0(v1)
800048b8:	ac670004 	sw	a3,4(v1)
800048bc:	ac660008 	sw	a2,8(v1)
800048c0:	ac65000c 	sw	a1,12(v1)
800048c4:	24420010 	addiu	v0,v0,16
800048c8:	1444fff6 	bne	v0,a0,800048a4 <CheckDramFreq+0x14>
800048cc:	24630010 	addiu	v1,v1,16
	685,700, 720,  740 ,755, 770 ,785,800};//[bit14:10] //RTL8198C

#else
	unsigned short usFreqVal[] = {65, 78, 125, 150, 156, 168, 193, 193};
#endif
	usFreqBit = (0x00007C00 & (*(unsigned int*)0xb8000008)) >> 10 ;
800048d0:	3c02b800 	lui	v0,0xb800
800048d4:	34420008 	ori	v0,v0,0x8
800048d8:	8c420000 	lw	v0,0(v0)
800048dc:	7c422280 	ext	v0,v0,0xa,0x5
800048e0:	00021040 	sll	v0,v0,0x1
800048e4:	03a21021 	addu	v0,sp,v0
	//LDEBUG("CheckDramFreq:usFreqVal=%dMHZ; usFreqBit=%x; B8000008=%x;\n", usFreqVal[usFreqBit], usFreqBit, (*(unsigned int*)0xb8000008));
#ifdef _verbose
	printf("spi_common.c: DRAM CLOCK=%dMHZ\n", usFreqVal[usFreqBit]);
#endif
	return usFreqVal[usFreqBit];
}// Set FSCR register
800048e8:	94420000 	lhu	v0,0(v0)
800048ec:	27bd0040 	addiu	sp,sp,64
800048f0:	03e00008 	jr	ra
800048f4:	00000000 	nop

800048f8 <setFSCR>:
// Set FSCR register
void setFSCR(unsigned char ucChip, unsigned int uiClkMhz, unsigned int uiRBO, unsigned int uiWBO, unsigned int uiTCS)
{
800048f8:	27bdffd8 	addiu	sp,sp,-40
800048fc:	afbf0024 	sw	ra,36(sp)
80004900:	afb30020 	sw	s3,32(sp)
80004904:	afb2001c 	sw	s2,28(sp)
80004908:	afb10018 	sw	s1,24(sp)
8000490c:	afb00014 	sw	s0,20(sp)
80004910:	00a08021 	move	s0,a1
80004914:	00c09821 	move	s3,a2
80004918:	00e09021 	move	s2,a3
	unsigned int ui, uiClk;
	uiClk = CheckDramFreq();
8000491c:	0c001224 	jal	80004890 <CheckDramFreq>
80004920:	309100ff 	andi	s1,a0,0xff
	ui = uiClk / uiClkMhz;
80004924:	0050001b 	divu	zero,v0,s0
80004928:	020001f4 	teq	s0,zero,0x7
8000492c:	00008010 	mfhi	s0
80004930:	00001812 	mflo	v1
	if((uiClk % uiClkMhz) > 0)
	{
		ui = ui + 1;
80004934:	0010802b 	sltu	s0,zero,s0
80004938:	00701821 	addu	v1,v1,s0
	}
	if((ui % 2) > 0)
	{
		ui = ui + 1;
8000493c:	30640001 	andi	a0,v1,0x1
80004940:	00641821 	addu	v1,v1,a0
	}
	spi_flash_info[ucChip].chip_clk = uiClk / ui;
80004944:	001120c0 	sll	a0,s1,0x3
80004948:	00118980 	sll	s1,s1,0x6
8000494c:	00918821 	addu	s1,a0,s1
80004950:	3c048001 	lui	a0,0x8001
80004954:	24845218 	addiu	a0,a0,21016
80004958:	02248821 	addu	s1,s1,a0
8000495c:	0043001b 	divu	zero,v0,v1
80004960:	006001f4 	teq	v1,zero,0x7
80004964:	00001012 	mflo	v0
80004968:	ae220028 	sw	v0,40(s1)
	SPI_REG_LOAD(SFCR, SFCR_SPI_CLK_DIV((ui-2)/2) | SFCR_RBO(uiRBO) | SFCR_WBO(uiWBO) | SFCR_SPI_TCS(uiTCS));
8000496c:	3c05b800 	lui	a1,0xb800
80004970:	34a51208 	ori	a1,a1,0x1208
80004974:	3c040800 	lui	a0,0x800
80004978:	8ca20000 	lw	v0,0(a1)
8000497c:	00441024 	and	v0,v0,a0
80004980:	1040fffd 	beqz	v0,80004978 <setFSCR+0x80>
80004984:	8fa20038 	lw	v0,56(sp)
80004988:	001296c0 	sll	s2,s2,0x1b
8000498c:	00139f00 	sll	s3,s3,0x1c
80004990:	02539025 	or	s2,s2,s3
80004994:	00021580 	sll	v0,v0,0x16
80004998:	02429025 	or	s2,s2,v0
8000499c:	2470fffe 	addiu	s0,v1,-2
800049a0:	00108042 	srl	s0,s0,0x1
800049a4:	00108740 	sll	s0,s0,0x1d
800049a8:	02501825 	or	v1,s2,s0
800049ac:	3c02b800 	lui	v0,0xb800
800049b0:	34421200 	ori	v0,v0,0x1200
800049b4:	ac430000 	sw	v1,0(v0)
	//SPI_REG_LOAD(SFCR, SFCR_SPI_CLK_DIV(7) | SFCR_RBO(uiRBO) | SFCR_WBO(uiWBO) | SFCR_SPI_TCS(uiTCS));
#ifdef _verbose
	printf("spi_common.c: setFSCR=>uiClkMhz=%d, uiRBO=%d, uiWBO=%d, uiTCS=%d, resMhz=%d, vale=%8x\n", uiClkMhz, uiRBO, uiWBO, uiTCS, spi_flash_info[ucChip].chip_clk, SPI_REG_READ(SFCR));
#endif

}
800049b8:	8fbf0024 	lw	ra,36(sp)
800049bc:	8fb30020 	lw	s3,32(sp)
800049c0:	8fb2001c 	lw	s2,28(sp)
800049c4:	8fb10018 	lw	s1,24(sp)
800049c8:	8fb00014 	lw	s0,20(sp)
800049cc:	03e00008 	jr	ra
800049d0:	27bd0028 	addiu	sp,sp,40

800049d4 <calAddr>:
// Calculate write address group
void calAddr(unsigned int uiStart, unsigned int uiLenth, unsigned int uiSectorSize, unsigned int* uiStartAddr, unsigned int*  uiStartLen, unsigned int* uiSectorAddr, unsigned int* uiSectorCount, unsigned int* uiEndAddr, unsigned int* uiEndLen)
{
800049d4:	8faa0010 	lw	t2,16(sp)
800049d8:	8fa20014 	lw	v0,20(sp)
800049dc:	8fa90018 	lw	t1,24(sp)
800049e0:	8fa8001c 	lw	t0,28(sp)
	unsigned int ui;
	// only one sector
	if ((uiStart + uiLenth) < ((uiStart / uiSectorSize + 1) * uiSectorSize))
800049e4:	00a45821 	addu	t3,a1,a0
800049e8:	0086001b 	divu	zero,a0,a2
800049ec:	00c001f4 	teq	a2,zero,0x7
800049f0:	00006812 	mflo	t5
800049f4:	25ac0001 	addiu	t4,t5,1
800049f8:	71866002 	mul	t4,t4,a2
800049fc:	016c582b 	sltu	t3,t3,t4
80004a00:	11600008 	beqz	t3,80004a24 <calAddr+0x50>
80004a04:	8fa30020 	lw	v1,32(sp)
	{	// start	
		*uiStartAddr = uiStart;
80004a08:	ace40000 	sw	a0,0(a3)
		*uiStartLen = uiLenth;
80004a0c:	ad450000 	sw	a1,0(t2)
		//middle
		*uiSectorAddr = 0x00;
80004a10:	ac400000 	sw	zero,0(v0)
		*uiSectorCount = 0x00;
80004a14:	ad200000 	sw	zero,0(t1)
		// end
		*uiEndAddr = 0x00;
80004a18:	ad000000 	sw	zero,0(t0)
		*uiEndLen = 0x00;
80004a1c:	03e00008 	jr	ra
80004a20:	ac600000 	sw	zero,0(v1)
	}
	//more then one sector
	else
	{
		// start
		*uiStartAddr = uiStart;
80004a24:	ace40000 	sw	a0,0(a3)
		*uiStartLen = uiSectorSize - (uiStart % uiSectorSize);
80004a28:	0086001b 	divu	zero,a0,a2
80004a2c:	00c001f4 	teq	a2,zero,0x7
80004a30:	00002010 	mfhi	a0
80004a34:	00c42023 	subu	a0,a2,a0
		if(*uiStartLen == uiSectorSize)
80004a38:	00c45826 	xor	t3,a2,a0
80004a3c:	000b200a 	movz	a0,zero,t3
80004a40:	ad440000 	sw	a0,0(t2)
		{
			*uiStartLen = 0x00;
		}
		// middle
		ui = uiLenth - *uiStartLen;
80004a44:	00a42823 	subu	a1,a1,a0
		*uiSectorAddr = *uiStartAddr + *uiStartLen;
80004a48:	8ce70000 	lw	a3,0(a3)
80004a4c:	00872021 	addu	a0,a0,a3
80004a50:	ac440000 	sw	a0,0(v0)
		*uiSectorCount = ui / uiSectorSize;
80004a54:	00a6001b 	divu	zero,a1,a2
80004a58:	00c001f4 	teq	a2,zero,0x7
80004a5c:	00002010 	mfhi	a0
80004a60:	00002812 	mflo	a1
80004a64:	ad250000 	sw	a1,0(t1)
		//end
		*uiEndAddr = *uiSectorAddr + (*uiSectorCount * uiSectorSize);
80004a68:	8c420000 	lw	v0,0(v0)
80004a6c:	70a63802 	mul	a3,a1,a2
80004a70:	00e22821 	addu	a1,a3,v0
80004a74:	ad050000 	sw	a1,0(t0)
		*uiEndLen = ui % uiSectorSize;
80004a78:	03e00008 	jr	ra
80004a7c:	ac640000 	sw	a0,0(v1)

80004a80 <calShift>:
	}
	LDEBUG("calAddr:uiStart=%x; uiSectorSize=%x; uiLenth=%x;-> uiStartAddr=%x; uiStartLen=%x; uiSectorAddr=%x; uiSectorCount=%x; uiEndAddr=%x; uiEndLen=%x;\n",uiStart, uiSectorSize, uiLenth, *uiStartAddr, *uiStartLen, *uiSectorAddr, *uiSectorCount, *uiEndAddr, *uiEndLen);	
}
// Calculate chip capacity shift bit 
unsigned char calShift(unsigned char ucCapacityId, unsigned char ucChipSize)
{
80004a80:	308400ff 	andi	a0,a0,0xff
80004a84:	30a500ff 	andi	a1,a1,0xff
	unsigned int ui;
	if(ucChipSize > ucCapacityId)
80004a88:	0085182b 	sltu	v1,a0,a1
80004a8c:	14600002 	bnez	v1,80004a98 <calShift+0x18>
80004a90:	00a41023 	subu	v0,a1,a0
	{
		ui = ucChipSize - ucCapacityId;
	}
	else
	{
		ui = ucChipSize + 0x100 -ucCapacityId;
80004a94:	24420100 	addiu	v0,v0,256
	LDEBUG("calShift: ucCapacityId=%x; ucChipSize=%x; ucReturnVal=%x\n", ucCapacityId, ucChipSize, ui);
	#ifdef CONFIG_SPI_3to4BYTES_ADDRESS_SUPPORT
	ui=ui*4;
	#endif
	return (unsigned char)ui;	
}
80004a98:	03e00008 	jr	ra
80004a9c:	304200ff 	andi	v0,v0,0xff

80004aa0 <set_flash_info>:
}

unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer);
// set spi_flash_info struction content
void set_flash_info(unsigned char ucChip, unsigned int chip_id, unsigned int device_cap, unsigned int block_size, unsigned int sector_size, unsigned int page_size, char* chip_name, FUNC_ERASE pfErase, FUNC_READ pfRead, FUNC_SETQEBIT pfQeBit, FUNC_PAGEWRITE pfPageWrite)
{
80004aa0:	27bdffc8 	addiu	sp,sp,-56
80004aa4:	afbf0034 	sw	ra,52(sp)
80004aa8:	afbe0030 	sw	s8,48(sp)
80004aac:	afb7002c 	sw	s7,44(sp)
80004ab0:	afb60028 	sw	s6,40(sp)
80004ab4:	afb50024 	sw	s5,36(sp)
80004ab8:	afb40020 	sw	s4,32(sp)
80004abc:	afb3001c 	sw	s3,28(sp)
80004ac0:	afb20018 	sw	s2,24(sp)
80004ac4:	afb10014 	sw	s1,20(sp)
80004ac8:	afb00010 	sw	s0,16(sp)
80004acc:	00e09021 	move	s2,a3
80004ad0:	8fb70048 	lw	s7,72(sp)
80004ad4:	8fbe004c 	lw	s8,76(sp)
80004ad8:	309100ff 	andi	s1,a0,0xff
	unsigned int ui = 1 << device_cap;
80004adc:	24130001 	li	s3,1
80004ae0:	00d39804 	sllv	s3,s3,a2
	spi_flash_info[ucChip].chip_id = chip_id;
80004ae4:	0011a0c0 	sll	s4,s1,0x3
80004ae8:	00118180 	sll	s0,s1,0x6
80004aec:	02908021 	addu	s0,s4,s0
80004af0:	3c158001 	lui	s5,0x8001
80004af4:	26b55218 	addiu	s5,s5,21016
80004af8:	02158021 	addu	s0,s0,s5
80004afc:	ae050000 	sw	a1,0(s0)
	spi_flash_info[ucChip].mfr_id = (chip_id >> 16) & 0xff;
80004b00:	00051402 	srl	v0,a1,0x10
80004b04:	a2020004 	sb	v0,4(s0)
	spi_flash_info[ucChip].dev_id = (chip_id >> 8) & 0xff;
80004b08:	00051202 	srl	v0,a1,0x8
80004b0c:	a2020005 	sb	v0,5(s0)
	spi_flash_info[ucChip].capacity_id = (chip_id) & 0xff;
80004b10:	30a400ff 	andi	a0,a1,0xff
80004b14:	a2040006 	sb	a0,6(s0)
	 #ifdef CONFIG_SPI_3to4BYTES_ADDRESS_SUPPORT
	
	spi_flash_info[ucChip].size_shift = calShift(spi_flash_info[ucChip].capacity_id, device_cap);
	#else
	spi_flash_info[ucChip].size_shift = calShift(spi_flash_info[ucChip].capacity_id, device_cap);
80004b18:	30d600ff 	andi	s6,a2,0xff
80004b1c:	0c0012a0 	jal	80004a80 <calShift>
80004b20:	02c02821 	move	a1,s6
80004b24:	a2020007 	sb	v0,7(s0)
	#endif
	spi_flash_info[ucChip].device_size = device_cap;			// 2 ^ N (bytes)
80004b28:	02918821 	addu	s1,s4,s1
80004b2c:	26310001 	addiu	s1,s1,1
80004b30:	001188c0 	sll	s1,s1,0x3
80004b34:	0235a821 	addu	s5,s1,s5
80004b38:	a2b60000 	sb	s6,0(s5)
	 #ifdef CONFIG_SPI_3to4BYTES_ADDRESS_SUPPORT
	spi_flash_info[ucChip].chip_size =  ui*4;
	#else
	spi_flash_info[ucChip].chip_size =  ui;
80004b3c:	aeb30004 	sw	s3,4(s5)
	#endif
	spi_flash_info[ucChip].block_size = block_size;
80004b40:	ae120010 	sw	s2,16(s0)
	spi_flash_info[ucChip].block_cnt = ui / block_size;
80004b44:	0272001b 	divu	zero,s3,s2
80004b48:	024001f4 	teq	s2,zero,0x7
80004b4c:	00009012 	mflo	s2
80004b50:	ae120014 	sw	s2,20(s0)
	spi_flash_info[ucChip].sector_size = sector_size;
80004b54:	ae170018 	sw	s7,24(s0)
	spi_flash_info[ucChip].sector_cnt = ui / sector_size;
80004b58:	0277001b 	divu	zero,s3,s7
80004b5c:	02e001f4 	teq	s7,zero,0x7
80004b60:	00009812 	mflo	s3
80004b64:	ae13001c 	sw	s3,28(s0)
	spi_flash_info[ucChip].page_size = page_size;
80004b68:	ae1e0020 	sw	s8,32(s0)
	spi_flash_info[ucChip].page_cnt = sector_size / page_size;
80004b6c:	02fe001b 	divu	zero,s7,s8
80004b70:	03c001f4 	teq	s8,zero,0x7
80004b74:	0000b812 	mflo	s7
80004b78:	ae170024 	sw	s7,36(s0)
	spi_flash_info[ucChip].chip_name = chip_name;
80004b7c:	8fa20050 	lw	v0,80(sp)
80004b80:	ae02002c 	sw	v0,44(s0)
	spi_flash_info[ucChip].pfErase = pfErase;
80004b84:	8fa20054 	lw	v0,84(sp)
80004b88:	ae020034 	sw	v0,52(s0)
	spi_flash_info[ucChip].pfWrite = ComSrlCmd_ComWriteData;
80004b8c:	3c028000 	lui	v0,0x8000
80004b90:	24425474 	addiu	v0,v0,21620
80004b94:	ae020038 	sw	v0,56(s0)
	spi_flash_info[ucChip].pfRead = pfRead;
80004b98:	8fa20058 	lw	v0,88(sp)
80004b9c:	ae02003c 	sw	v0,60(s0)
	spi_flash_info[ucChip].pfQeBit = pfQeBit;
80004ba0:	8fa2005c 	lw	v0,92(sp)
80004ba4:	ae020040 	sw	v0,64(s0)
	spi_flash_info[ucChip].pfPageWrite = pfPageWrite;
80004ba8:	8fa20060 	lw	v0,96(sp)
80004bac:	ae020044 	sw	v0,68(s0)
	//SPI_REG_LOAD(SFCR2, 0x0bb08000);
	LDEBUG("set_flash_info: ucChip=%x; chip_id=%x; device_cap=%x; block_size=%x; sector_size=%x; page_size=%x; chip_name=%s\n", ucChip, chip_id, device_cap, block_size, sector_size, page_size, chip_name);
}
80004bb0:	8fbf0034 	lw	ra,52(sp)
80004bb4:	8fbe0030 	lw	s8,48(sp)
80004bb8:	8fb7002c 	lw	s7,44(sp)
80004bbc:	8fb60028 	lw	s6,40(sp)
80004bc0:	8fb50024 	lw	s5,36(sp)
80004bc4:	8fb40020 	lw	s4,32(sp)
80004bc8:	8fb3001c 	lw	s3,28(sp)
80004bcc:	8fb20018 	lw	s2,24(sp)
80004bd0:	8fb10014 	lw	s1,20(sp)
80004bd4:	8fb00010 	lw	s0,16(sp)
80004bd8:	03e00008 	jr	ra
80004bdc:	27bd0038 	addiu	sp,sp,56

80004be0 <SFCSR_CS_L>:
}

/****************************** Layer 1 ******************************/
// set cs high
void SFCSR_CS_L(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
{
80004be0:	308400ff 	andi	a0,a0,0xff
80004be4:	30a500ff 	andi	a1,a1,0xff
80004be8:	30c600ff 	andi	a2,a2,0xff
#define REG32(reg)	(*(volatile unsigned int *)(reg))

	LDEBUG("SFCSR_CS_L: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0) 
80004bec:	3c07b800 	lui	a3,0xb800
80004bf0:	34e71208 	ori	a3,a3,0x1208
80004bf4:	3c030800 	lui	v1,0x800
80004bf8:	8ce20000 	lw	v0,0(a3)
80004bfc:	00431024 	and	v0,v0,v1
80004c00:	1040fffd 	beqz	v0,80004bf8 <SFCSR_CS_L+0x18>
80004c04:	3c020805 	lui	v0,0x805
	{	//REG32(SFCSR)=REG32(SFCSR);
		//printf("L SFCSR=%x\n", REG32(SFCSR));
	};
	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(5);
80004c08:	24840001 	addiu	a0,a0,1
80004c0c:	00042780 	sll	a0,a0,0x1e
80004c10:	00052f00 	sll	a1,a1,0x1c
80004c14:	00852825 	or	a1,a0,a1
80004c18:	00a22825 	or	a1,a1,v0
80004c1c:	00063640 	sll	a2,a2,0x19
80004c20:	00a62825 	or	a1,a1,a2
80004c24:	3c02b800 	lui	v0,0xb800
80004c28:	34421208 	ori	v0,v0,0x1208
80004c2c:	ac450000 	sw	a1,0(v0)
	
#if 0	
	printf("ew %x %x\n", SFCSR, SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(5));
#endif
	//20101215 *((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(1 + (ucChip)) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
}
80004c30:	03e00008 	jr	ra
80004c34:	00000000 	nop

80004c38 <SFCSR_CS_H>:
// set cs low
void SFCSR_CS_H(unsigned char ucChip, unsigned char ucLen, unsigned char ucIOWidth)
{
80004c38:	30a500ff 	andi	a1,a1,0xff
80004c3c:	30c600ff 	andi	a2,a2,0xff
#define REG32(reg)	(*(volatile unsigned int *)(reg))

	LDEBUG("SFCSR_CS_H: ucChip=%x; uiLen=%x; ucIOWidth=%x;\n", ucChip, ucLen, ucIOWidth);
	if(ucLen == 0) ucLen = 1;
80004c40:	24020001 	li	v0,1
80004c44:	0045280a 	movz	a1,v0,a1
	while((*((volatile unsigned int *)SFCSR) & (SFCSR_SPI_RDY(1))) == 0)
80004c48:	3c04b800 	lui	a0,0xb800
80004c4c:	34841208 	ori	a0,a0,0x1208
80004c50:	3c030800 	lui	v1,0x800
80004c54:	8c820000 	lw	v0,0(a0)
80004c58:	00431024 	and	v0,v0,v1
80004c5c:	1040fffd 	beqz	v0,80004c54 <SFCSR_CS_H+0x1c>
80004c60:	00061640 	sll	v0,a2,0x19
	{	//printf("H SFCSR=%x\n", REG32(SFCSR));
	};
	*((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(5);
80004c64:	3c03c805 	lui	v1,0xc805
80004c68:	00431025 	or	v0,v0,v1
80004c6c:	00052f00 	sll	a1,a1,0x1c
80004c70:	00452825 	or	a1,v0,a1
80004c74:	3c02b800 	lui	v0,0xb800
80004c78:	34421208 	ori	v0,v0,0x1208
80004c7c:	ac450000 	sw	a1,0(v0)
	
#if 0	
	printf("ew %x %x\n", SFCSR, SFCSR_SPI_CSB(3) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth) | SFCSR_CHIP_SEL(0) | SFCSR_CMD_BYTE(5));
#endif
	//20101215 *((volatile unsigned int *)(SFCSR)) = SFCSR_SPI_CSB(3) | SFCSR_LEN(ucLen) | SFCSR_SPI_RDY(1) |  SFCSR_IO_WIDTH(ucIOWidth);	
}
80004c80:	03e00008 	jr	ra
80004c84:	00000000 	nop

80004c88 <SeqCmd_Order>:


#endif

void SeqCmd_Order(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd)
{
80004c88:	27bdffe0 	addiu	sp,sp,-32
80004c8c:	afbf001c 	sw	ra,28(sp)
80004c90:	afb20018 	sw	s2,24(sp)
80004c94:	afb10014 	sw	s1,20(sp)
80004c98:	afb00010 	sw	s0,16(sp)
80004c9c:	00c09021 	move	s2,a2
	LDEBUG("SeqCmd_Type1: ucChip=%x; ucIOWidth=%x; SPICMD=%x;\n", ucChip, ucIOWidth, uiCmd);
	SFCSR_CS_L(ucChip, ucIOWidth, IOWIDTH_SINGLE);
80004ca0:	309000ff 	andi	s0,a0,0xff
80004ca4:	30b100ff 	andi	s1,a1,0xff
80004ca8:	02002021 	move	a0,s0
80004cac:	02202821 	move	a1,s1
80004cb0:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004cb4:	00003021 	move	a2,zero
	SPI_REG_LOAD(SFDR, uiCmd);
80004cb8:	3c04b800 	lui	a0,0xb800
80004cbc:	34841208 	ori	a0,a0,0x1208
80004cc0:	3c030800 	lui	v1,0x800
80004cc4:	8c820000 	lw	v0,0(a0)
80004cc8:	00431024 	and	v0,v0,v1
80004ccc:	1040fffd 	beqz	v0,80004cc4 <SeqCmd_Order+0x3c>
80004cd0:	3c02b800 	lui	v0,0xb800
80004cd4:	3442120c 	ori	v0,v0,0x120c
80004cd8:	ac520000 	sw	s2,0(v0)
	SFCSR_CS_H(ucChip, ucIOWidth, IOWIDTH_SINGLE);
80004cdc:	02002021 	move	a0,s0
80004ce0:	02202821 	move	a1,s1
80004ce4:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80004ce8:	00003021 	move	a2,zero
}
80004cec:	8fbf001c 	lw	ra,28(sp)
80004cf0:	8fb20018 	lw	s2,24(sp)
80004cf4:	8fb10014 	lw	s1,20(sp)
80004cf8:	8fb00010 	lw	s0,16(sp)
80004cfc:	03e00008 	jr	ra
80004d00:	27bd0020 	addiu	sp,sp,32

80004d04 <SeqCmd_Write>:
// One byte Command Write
void SeqCmd_Write(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned int uiValue, unsigned char ucValueLen)
{
80004d04:	27bdffd8 	addiu	sp,sp,-40
80004d08:	afbf0024 	sw	ra,36(sp)
80004d0c:	afb40020 	sw	s4,32(sp)
80004d10:	afb3001c 	sw	s3,28(sp)
80004d14:	afb20018 	sw	s2,24(sp)
80004d18:	afb10014 	sw	s1,20(sp)
80004d1c:	afb00010 	sw	s0,16(sp)
80004d20:	00c09021 	move	s2,a2
80004d24:	00e0a021 	move	s4,a3
80004d28:	93b3003b 	lbu	s3,59(sp)
	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
80004d2c:	309000ff 	andi	s0,a0,0xff
80004d30:	30b100ff 	andi	s1,a1,0xff
80004d34:	02002021 	move	a0,s0
80004d38:	00002821 	move	a1,zero
80004d3c:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004d40:	02203021 	move	a2,s1
	SPI_REG_LOAD(SFDR, uiCmd);
80004d44:	3c04b800 	lui	a0,0xb800
80004d48:	34841208 	ori	a0,a0,0x1208
80004d4c:	3c030800 	lui	v1,0x800
80004d50:	8c820000 	lw	v0,0(a0)
80004d54:	00431024 	and	v0,v0,v1
80004d58:	1040fffd 	beqz	v0,80004d50 <SeqCmd_Write+0x4c>
80004d5c:	3c02b800 	lui	v0,0xb800
80004d60:	3442120c 	ori	v0,v0,0x120c
80004d64:	ac520000 	sw	s2,0(v0)
	SFCSR_CS_L(ucChip, ucValueLen - 1, ucIOWidth);
80004d68:	2665ffff 	addiu	a1,s3,-1
80004d6c:	02002021 	move	a0,s0
80004d70:	30a500ff 	andi	a1,a1,0xff
80004d74:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004d78:	02203021 	move	a2,s1
	SPI_REG_LOAD(SFDR, (uiValue << ((4 - ucValueLen) * 8)));
80004d7c:	3c04b800 	lui	a0,0xb800
80004d80:	34841208 	ori	a0,a0,0x1208
80004d84:	3c030800 	lui	v1,0x800
80004d88:	8c820000 	lw	v0,0(a0)
80004d8c:	00431024 	and	v0,v0,v1
80004d90:	1040fffd 	beqz	v0,80004d88 <SeqCmd_Write+0x84>
80004d94:	24020004 	li	v0,4
80004d98:	00539823 	subu	s3,v0,s3
80004d9c:	001398c0 	sll	s3,s3,0x3
80004da0:	0274a004 	sllv	s4,s4,s3
80004da4:	3c02b800 	lui	v0,0xb800
80004da8:	3442120c 	ori	v0,v0,0x120c
80004dac:	ac540000 	sw	s4,0(v0)
	SFCSR_CS_H(ucChip, DATA_LENTH1, IOWIDTH_SINGLE);
80004db0:	02002021 	move	a0,s0
80004db4:	00002821 	move	a1,zero
80004db8:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80004dbc:	00003021 	move	a2,zero
	LDEBUG("SeqCmd_Write: ucChip=%x; ucIOWidth=%x; uiCmd=%x; uiValue=%x; ucValueLen=%x;\n", ucChip, ucIOWidth, uiCmd, uiValue, ucValueLen);
}
80004dc0:	8fbf0024 	lw	ra,36(sp)
80004dc4:	8fb40020 	lw	s4,32(sp)
80004dc8:	8fb3001c 	lw	s3,28(sp)
80004dcc:	8fb20018 	lw	s2,24(sp)
80004dd0:	8fb10014 	lw	s1,20(sp)
80004dd4:	8fb00010 	lw	s0,16(sp)
80004dd8:	03e00008 	jr	ra
80004ddc:	27bd0028 	addiu	sp,sp,40

80004de0 <SeqCmd_Read>:
// One byte Command Read
unsigned int SeqCmd_Read(unsigned char ucChip,  unsigned char ucIOWidth, unsigned int uiCmd, unsigned char ucRDLen)
{
80004de0:	27bdffd8 	addiu	sp,sp,-40
80004de4:	afbf0024 	sw	ra,36(sp)
80004de8:	afb40020 	sw	s4,32(sp)
80004dec:	afb3001c 	sw	s3,28(sp)
80004df0:	afb20018 	sw	s2,24(sp)
80004df4:	afb10014 	sw	s1,20(sp)
80004df8:	afb00010 	sw	s0,16(sp)
80004dfc:	00c09021 	move	s2,a2
80004e00:	30f400ff 	andi	s4,a3,0xff
	unsigned int ui;	
	SFCSR_CS_L(ucChip, DATA_LENTH1, ucIOWidth);
80004e04:	309000ff 	andi	s0,a0,0xff
80004e08:	30b100ff 	andi	s1,a1,0xff
80004e0c:	02002021 	move	a0,s0
80004e10:	00002821 	move	a1,zero
80004e14:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004e18:	02203021 	move	a2,s1
	SPI_REG_LOAD(SFDR, uiCmd);
80004e1c:	3c04b800 	lui	a0,0xb800
80004e20:	34841208 	ori	a0,a0,0x1208
80004e24:	3c030800 	lui	v1,0x800
80004e28:	8c820000 	lw	v0,0(a0)
80004e2c:	00431024 	and	v0,v0,v1
80004e30:	1040fffd 	beqz	v0,80004e28 <SeqCmd_Read+0x48>
80004e34:	3c13b800 	lui	s3,0xb800
80004e38:	3673120c 	ori	s3,s3,0x120c
80004e3c:	ae720000 	sw	s2,0(s3)
	SFCSR_CS_L(ucChip, ucRDLen-1, ucIOWidth);
80004e40:	2685ffff 	addiu	a1,s4,-1
80004e44:	02002021 	move	a0,s0
80004e48:	30a500ff 	andi	a1,a1,0xff
80004e4c:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004e50:	02203021 	move	a2,s1
	ui = SPI_REG_READ(SFDR);
80004e54:	8e720000 	lw	s2,0(s3)
	SFCSR_CS_H(ucChip, DATA_LENTH1, ucIOWidth);
80004e58:	02002021 	move	a0,s0
80004e5c:	00002821 	move	a1,zero
80004e60:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80004e64:	02203021 	move	a2,s1
80004e68:	24020004 	li	v0,4
80004e6c:	0054a023 	subu	s4,v0,s4
80004e70:	001410c0 	sll	v0,s4,0x3
	ui = ui >> ((4 - ucRDLen) * 8);	
	LDEBUG("SeqCmd_Read: ucChip=%x; ucIOWidth=%x; uiCmd=%x; ucRDLen=%x; RetVal=%x\n", ucChip, ucIOWidth, uiCmd, ucRDLen, ui);
	return ui;
}
80004e74:	00521006 	srlv	v0,s2,v0
80004e78:	8fbf0024 	lw	ra,36(sp)
80004e7c:	8fb40020 	lw	s4,32(sp)
80004e80:	8fb3001c 	lw	s3,28(sp)
80004e84:	8fb20018 	lw	s2,24(sp)
80004e88:	8fb10014 	lw	s1,20(sp)
80004e8c:	8fb00010 	lw	s0,16(sp)
80004e90:	03e00008 	jr	ra
80004e94:	27bd0028 	addiu	sp,sp,40

80004e98 <ComSrlCmd_NoneQeBit>:
// without QE bit
unsigned int ComSrlCmd_NoneQeBit(unsigned char ucChip)
{
	KDEBUG("ComSrlCmd_NoneQeBit: ucChip=%x;\n", ucChip);
	return 0;
}
80004e98:	03e00008 	jr	ra
80004e9c:	00001021 	move	v0,zero

80004ea0 <ComSrlCmd_InputCommand>:
// ucIsFast: = 0 cmd, address, dummy single IO ; =1 cmd single IO, address and dummy multi IO; =2 cmd, address and dummy multi IO;
void ComSrlCmd_InputCommand(unsigned char ucChip, unsigned int uiAddr, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
{
80004ea0:	27bdffd0 	addiu	sp,sp,-48
80004ea4:	afbf002c 	sw	ra,44(sp)
80004ea8:	afb50028 	sw	s5,40(sp)
80004eac:	afb40024 	sw	s4,36(sp)
80004eb0:	afb30020 	sw	s3,32(sp)
80004eb4:	afb2001c 	sw	s2,28(sp)
80004eb8:	afb10018 	sw	s1,24(sp)
80004ebc:	afb00014 	sw	s0,20(sp)
80004ec0:	00a08821 	move	s1,a1
80004ec4:	00c09021 	move	s2,a2
80004ec8:	309000ff 	andi	s0,a0,0xff
80004ecc:	30f300ff 	andi	s3,a3,0xff
80004ed0:	93b40043 	lbu	s4,67(sp)
	int i;
	LDEBUG("ComSrlCmd_InputCommand: ucChip=%x; uiAddr=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);

	// input command
	if(ucIsFast == ISFAST_ALL)
80004ed4:	24020002 	li	v0,2
80004ed8:	16620007 	bne	s3,v0,80004ef8 <ComSrlCmd_InputCommand+0x58>
80004edc:	93b50047 	lbu	s5,71(sp)
	{
		SFCSR_CS_L(ucChip, 0, ucIOWidth);
80004ee0:	02002021 	move	a0,s0
80004ee4:	00002821 	move	a1,zero
80004ee8:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004eec:	02803021 	move	a2,s4
	}
	else
	{
		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
	}
	SPI_REG_LOAD(SFDR, uiCmd);				// Read Command
80004ef0:	080013c3 	j	80004f0c <ComSrlCmd_InputCommand+0x6c>
80004ef4:	3c04b800 	lui	a0,0xb800
	{
		SFCSR_CS_L(ucChip, 0, ucIOWidth);
	}
	else
	{
		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
80004ef8:	02002021 	move	a0,s0
80004efc:	00002821 	move	a1,zero
80004f00:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004f04:	00003021 	move	a2,zero
	}
	SPI_REG_LOAD(SFDR, uiCmd);				// Read Command
80004f08:	3c04b800 	lui	a0,0xb800
80004f0c:	34841208 	ori	a0,a0,0x1208
80004f10:	3c030800 	lui	v1,0x800
80004f14:	8c820000 	lw	v0,0(a0)
80004f18:	00431024 	and	v0,v0,v1
80004f1c:	1040fffd 	beqz	v0,80004f14 <ComSrlCmd_InputCommand+0x74>
80004f20:	3c02b800 	lui	v0,0xb800
80004f24:	3442120c 	ori	v0,v0,0x120c
80004f28:	ac520000 	sw	s2,0(v0)

	// input 3 bytes address
	if(ucIsFast == ISFAST_NO)
80004f2c:	16600006 	bnez	s3,80004f48 <ComSrlCmd_InputCommand+0xa8>
80004f30:	02002021 	move	a0,s0
	{
		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
80004f34:	00002821 	move	a1,zero
80004f38:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004f3c:	00003021 	move	a2,zero
	{
		SFCSR_CS_L(ucChip, 0, ucIOWidth);
	}

	
	if(REG32(0xb8000008)&0x1)
80004f40:	080013d6 	j	80004f58 <ComSrlCmd_InputCommand+0xb8>
80004f44:	3c02b800 	lui	v0,0xb800
	{
		SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
	}
	else
	{
		SFCSR_CS_L(ucChip, 0, ucIOWidth);
80004f48:	00002821 	move	a1,zero
80004f4c:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80004f50:	02803021 	move	a2,s4
	}

	
	if(REG32(0xb8000008)&0x1)
80004f54:	3c02b800 	lui	v0,0xb800
80004f58:	34420008 	ori	v0,v0,0x8
80004f5c:	8c420000 	lw	v0,0(v0)
80004f60:	30420001 	andi	v0,v0,0x1
80004f64:	1040000a 	beqz	v0,80004f90 <ComSrlCmd_InputCommand+0xf0>
80004f68:	3c04b800 	lui	a0,0xb800
	{
		SPI_REG_LOAD(SFDR,(uiAddr << 0));//JSW for 4-Byte addressing for all read
80004f6c:	34841208 	ori	a0,a0,0x1208
80004f70:	3c030800 	lui	v1,0x800
80004f74:	8c820000 	lw	v0,0(a0)
80004f78:	00431024 	and	v0,v0,v1
80004f7c:	1040fffd 	beqz	v0,80004f74 <ComSrlCmd_InputCommand+0xd4>
80004f80:	3c02b800 	lui	v0,0xb800
80004f84:	3442120c 	ori	v0,v0,0x120c
80004f88:	ac510000 	sw	s1,0(v0)
	}
		
	
	SPI_REG_LOAD(SFDR,(uiAddr << 8));
80004f8c:	3c04b800 	lui	a0,0xb800
80004f90:	34841208 	ori	a0,a0,0x1208
80004f94:	3c030800 	lui	v1,0x800
80004f98:	8c820000 	lw	v0,0(a0)
80004f9c:	00431024 	and	v0,v0,v1
80004fa0:	1040fffd 	beqz	v0,80004f98 <ComSrlCmd_InputCommand+0xf8>
80004fa4:	3c02b800 	lui	v0,0xb800
80004fa8:	00111a00 	sll	v1,s1,0x8
80004fac:	3442120c 	ori	v0,v0,0x120c
80004fb0:	ac430000 	sw	v1,0(v0)
	SPI_REG_LOAD(SFDR,(uiAddr << 16));
80004fb4:	3c04b800 	lui	a0,0xb800
80004fb8:	34841208 	ori	a0,a0,0x1208
80004fbc:	3c030800 	lui	v1,0x800
80004fc0:	8c820000 	lw	v0,0(a0)
80004fc4:	00431024 	and	v0,v0,v1
80004fc8:	1040fffd 	beqz	v0,80004fc0 <ComSrlCmd_InputCommand+0x120>
80004fcc:	3c02b800 	lui	v0,0xb800
80004fd0:	00111c00 	sll	v1,s1,0x10
80004fd4:	3442120c 	ori	v0,v0,0x120c
80004fd8:	ac430000 	sw	v1,0(v0)
	SPI_REG_LOAD(SFDR,(uiAddr << 24));
80004fdc:	3c04b800 	lui	a0,0xb800
80004fe0:	34841208 	ori	a0,a0,0x1208
80004fe4:	3c030800 	lui	v1,0x800
80004fe8:	8c820000 	lw	v0,0(a0)
80004fec:	00431024 	and	v0,v0,v1
80004ff0:	1040fffd 	beqz	v0,80004fe8 <ComSrlCmd_InputCommand+0x148>
80004ff4:	3c02b800 	lui	v0,0xb800
80004ff8:	00118e00 	sll	s1,s1,0x18
80004ffc:	3442120c 	ori	v0,v0,0x120c
80005000:	ac510000 	sw	s1,0(v0)

	//input dummy cycle
	for (i = 0; i < ucDummyCount; i++)
80005004:	1aa0000e 	blez	s5,80005040 <ComSrlCmd_InputCommand+0x1a0>
80005008:	00002821 	move	a1,zero
	{
		SPI_REG_LOAD(SFDR, 0);
8000500c:	3c06b800 	lui	a2,0xb800
80005010:	34c41208 	ori	a0,a2,0x1208
80005014:	3c030800 	lui	v1,0x800
80005018:	00403021 	move	a2,v0
8000501c:	8c820000 	lw	v0,0(a0)
80005020:	00431024 	and	v0,v0,v1
80005024:	1040fffd 	beqz	v0,8000501c <ComSrlCmd_InputCommand+0x17c>
80005028:	00000000 	nop
8000502c:	acc00000 	sw	zero,0(a2)
	SPI_REG_LOAD(SFDR,(uiAddr << 8));
	SPI_REG_LOAD(SFDR,(uiAddr << 16));
	SPI_REG_LOAD(SFDR,(uiAddr << 24));

	//input dummy cycle
	for (i = 0; i < ucDummyCount; i++)
80005030:	24a50001 	addiu	a1,a1,1
80005034:	00b5102a 	slt	v0,a1,s5
80005038:	1440fff8 	bnez	v0,8000501c <ComSrlCmd_InputCommand+0x17c>
8000503c:	00000000 	nop
	{
		SPI_REG_LOAD(SFDR, 0);
	}
	
	SFCSR_CS_L(ucChip, 3, ucIOWidth);
80005040:	02002021 	move	a0,s0
80005044:	24050003 	li	a1,3
80005048:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
8000504c:	02803021 	move	a2,s4
}
80005050:	8fbf002c 	lw	ra,44(sp)
80005054:	8fb50028 	lw	s5,40(sp)
80005058:	8fb40024 	lw	s4,36(sp)
8000505c:	8fb30020 	lw	s3,32(sp)
80005060:	8fb2001c 	lw	s2,28(sp)
80005064:	8fb10018 	lw	s1,24(sp)
80005068:	8fb00014 	lw	s0,20(sp)
8000506c:	03e00008 	jr	ra
80005070:	27bd0030 	addiu	sp,sp,48

80005074 <SetSFCR2>:
// Set SFCR2 for memery map read
unsigned int SetSFCR2(unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
{
80005074:	30a500ff 	andi	a1,a1,0xff
80005078:	30c600ff 	andi	a2,a2,0xff
8000507c:	30e700ff 	andi	a3,a3,0xff
	unsigned int ui, uiDy;
	ucSFCR2 = 0;
80005080:	3c028001 	lui	v0,0x8001
80005084:	a0402a10 	sb	zero,10768(v0)
	ui = SFCR2_SFCMD(uiCmd) | SFCR2_SFSIZE(spi_flash_info[0].device_size - 17) | SFCR2_RD_OPT(0) | SFCR2_HOLD_TILL_SFDR2(0);
80005088:	3c028001 	lui	v0,0x8001
8000508c:	90425220 	lbu	v0,21024(v0)
80005090:	2442ffef 	addiu	v0,v0,-17
80005094:	00021540 	sll	v0,v0,0x15
80005098:	00042600 	sll	a0,a0,0x18
	switch (ucIsFast)
8000509c:	24030001 	li	v1,1
800050a0:	10a3000a 	beq	a1,v1,800050cc <SetSFCR2+0x58>
800050a4:	00441025 	or	v0,v0,a0
800050a8:	10a00005 	beqz	a1,800050c0 <SetSFCR2+0x4c>
800050ac:	24030002 	li	v1,2
800050b0:	14a30012 	bne	a1,v1,800050fc <SetSFCR2+0x88>
800050b4:	00062480 	sll	a0,a2,0x12
			uiDy = ucIOWidth * 2;
			break;
		}
		case ISFAST_ALL:
		{
			ui = ui | SFCR2_CMD_IO(ucIOWidth) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
800050b8:	08001439 	j	800050e4 <SetSFCR2+0x70>
800050bc:	00061c00 	sll	v1,a2,0x10
	ui = SFCR2_SFCMD(uiCmd) | SFCR2_SFSIZE(spi_flash_info[0].device_size - 17) | SFCR2_RD_OPT(0) | SFCR2_HOLD_TILL_SFDR2(0);
	switch (ucIsFast)
	{
		case ISFAST_NO:
		{
			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
800050c0:	000632c0 	sll	a2,a2,0xb
			uiDy = 1;
			break;
800050c4:	08001444 	j	80005110 <SetSFCR2+0x9c>
800050c8:	00c21025 	or	v0,a2,v0
		}
		case ISFAST_YES:
		{
			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
800050cc:	00062400 	sll	a0,a2,0x10
800050d0:	00061ac0 	sll	v1,a2,0xb
800050d4:	00831825 	or	v1,a0,v1
800050d8:	00621025 	or	v0,v1,v0
			uiDy = ucIOWidth * 2;
			break;
800050dc:	08001442 	j	80005108 <SetSFCR2+0x94>
800050e0:	00063040 	sll	a2,a2,0x1
		}
		case ISFAST_ALL:
		{
			ui = ui | SFCR2_CMD_IO(ucIOWidth) | SFCR2_ADDR_IO(ucIOWidth) | SFCR2_DATA_IO(ucIOWidth);
800050e4:	00831825 	or	v1,a0,v1
800050e8:	00621025 	or	v0,v1,v0
800050ec:	00061ac0 	sll	v1,a2,0xb
800050f0:	00431025 	or	v0,v0,v1
			uiDy = ucIOWidth * 2;
			break;
800050f4:	08001442 	j	80005108 <SetSFCR2+0x94>
800050f8:	00063040 	sll	a2,a2,0x1
		}
		default:
		{
			ui = ui | SFCR2_CMD_IO(IOWIDTH_SINGLE) | SFCR2_ADDR_IO(IOWIDTH_SINGLE) | SFCR2_DATA_IO(ucIOWidth);
800050fc:	000632c0 	sll	a2,a2,0xb
80005100:	08001444 	j	80005110 <SetSFCR2+0x9c>
80005104:	00c21025 	or	v0,a2,v0
			uiDy = 1;
			break;
		}
	}
	if (uiDy == 0)
80005108:	14c00002 	bnez	a2,80005114 <SetSFCR2+0xa0>
8000510c:	00000000 	nop
80005110:	24060001 	li	a2,1
	{
		uiDy = 1;
	}
	ui = ui | SFCR2_DUMMY_CYCLE((ucDummyCount * 4 / uiDy));		// ucDummyCount is Byte Count ucDummyCount*8 / (uiDy*2)
80005114:	00073880 	sll	a3,a3,0x2
80005118:	00e6001b 	divu	zero,a3,a2
8000511c:	00c001f4 	teq	a2,zero,0x7
80005120:	00003012 	mflo	a2
80005124:	00063340 	sll	a2,a2,0xd
80005128:	00c21025 	or	v0,a2,v0
	SPI_REG_LOAD(SFCR2, ui);
8000512c:	3c08b800 	lui	t0,0xb800
80005130:	35081208 	ori	t0,t0,0x1208
80005134:	3c050800 	lui	a1,0x800
80005138:	8d040000 	lw	a0,0(t0)
8000513c:	00852024 	and	a0,a0,a1
80005140:	1080fffd 	beqz	a0,80005138 <SetSFCR2+0xc4>
80005144:	3c03b800 	lui	v1,0xb800
80005148:	34631204 	ori	v1,v1,0x1204
8000514c:	ac620000 	sw	v0,0(v1)
	LDEBUG("SetSFCR2: uiCmd=%x; ucIsFast=%; ucIOWidth=%x; ucDummyCount=%x; ucSFCR2=%x; SFCR2=%x\n;", uiCmd, ucIsFast, ucIOWidth, ucDummyCount, ucSFCR2, ui);
	return ui;	
}
80005150:	03e00008 	jr	ra
80005154:	00000000 	nop

80005158 <ComSrlCmd_ComRead>:
// read template
unsigned int ComSrlCmd_ComRead(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer,unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
{
80005158:	27bdffc0 	addiu	sp,sp,-64
8000515c:	afbf003c 	sw	ra,60(sp)
80005160:	afb60038 	sw	s6,56(sp)
80005164:	afb50034 	sw	s5,52(sp)
80005168:	afb40030 	sw	s4,48(sp)
8000516c:	afb3002c 	sw	s3,44(sp)
80005170:	afb20028 	sw	s2,40(sp)
80005174:	afb10024 	sw	s1,36(sp)
80005178:	afb00020 	sw	s0,32(sp)
8000517c:	00c09021 	move	s2,a2
80005180:	00e08821 	move	s1,a3
80005184:	8fb60050 	lw	s6,80(sp)

	unsigned int ui, uiCount, i;
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComRead: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
80005188:	309000ff 	andi	s0,a0,0xff
8000518c:	93b30057 	lbu	s3,87(sp)
80005190:	93b4005b 	lbu	s4,91(sp)
80005194:	93b5005f 	lbu	s5,95(sp)
80005198:	afb40010 	sw	s4,16(sp)
8000519c:	afb50014 	sw	s5,20(sp)
800051a0:	02002021 	move	a0,s0
800051a4:	02c03021 	move	a2,s6
800051a8:	0c0013a8 	jal	80004ea0 <ComSrlCmd_InputCommand>
800051ac:	02603821 	move	a3,s3
	if(ucSFCR2 != 0)	// set SFCR2
800051b0:	3c028001 	lui	v0,0x8001
800051b4:	90422a10 	lbu	v0,10768(v0)
800051b8:	10400008 	beqz	v0,800051dc <ComSrlCmd_ComRead+0x84>
800051bc:	00123082 	srl	a2,s2,0x2
	{
		ui = SetSFCR2((uiCmd >> 24), ucIsFast, ucIOWidth, ucDummyCount);
800051c0:	00162602 	srl	a0,s6,0x18
800051c4:	02602821 	move	a1,s3
800051c8:	02803021 	move	a2,s4
800051cc:	0c00141d 	jal	80005074 <SetSFCR2>
800051d0:	02a03821 	move	a3,s5
800051d4:	afa20018 	sw	v0,24(sp)
	}

	uiCount = uiLen / 4;							
800051d8:	00123082 	srl	a2,s2,0x2
	for( i = 0; i< uiCount; i++)					// Read 4 bytes every time.
800051dc:	10c0000f 	beqz	a2,8000521c <ComSrlCmd_ComRead+0xc4>
800051e0:	02202021 	move	a0,s1
800051e4:	02201021 	move	v0,s1
800051e8:	00002821 	move	a1,zero
	{
		ui = SPI_REG_READ(SFDR);
800051ec:	3c04b800 	lui	a0,0xb800
800051f0:	3484120c 	ori	a0,a0,0x120c
800051f4:	8c830000 	lw	v1,0(a0)
800051f8:	afa30018 	sw	v1,24(sp)
		memcpy(puc, &ui, 4);
800051fc:	a8430000 	swl	v1,0(v0)
80005200:	b8430003 	swr	v1,3(v0)
	{
		ui = SetSFCR2((uiCmd >> 24), ucIsFast, ucIOWidth, ucDummyCount);
	}

	uiCount = uiLen / 4;							
	for( i = 0; i< uiCount; i++)					// Read 4 bytes every time.
80005204:	24a50001 	addiu	a1,a1,1
80005208:	00a6182b 	sltu	v1,a1,a2
8000520c:	1460fff9 	bnez	v1,800051f4 <ComSrlCmd_ComRead+0x9c>
80005210:	24420004 	addiu	v0,v0,4
80005214:	00063080 	sll	a2,a2,0x2
80005218:	02262021 	addu	a0,s1,a2
		ui = SPI_REG_READ(SFDR);
		memcpy(puc, &ui, 4);
		puc += 4;
	}

	i = uiLen % 4;
8000521c:	32460003 	andi	a2,s2,0x3
	if(i > 0)
80005220:	10c00006 	beqz	a2,8000523c <ComSrlCmd_ComRead+0xe4>
80005224:	3c02b800 	lui	v0,0xb800
	{
		ui = SPI_REG_READ(SFDR);					// another bytes.
80005228:	3442120c 	ori	v0,v0,0x120c
8000522c:	8c420000 	lw	v0,0(v0)
80005230:	afa20018 	sw	v0,24(sp)
		memcpy(puc, &ui, i);
80005234:	0c0019e2 	jal	80006788 <memcpy>
80005238:	27a50018 	addiu	a1,sp,24
		puc += i;
	}
	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
8000523c:	02002021 	move	a0,s0
80005240:	00002821 	move	a1,zero
80005244:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80005248:	00003021 	move	a2,zero
	return uiLen;
	
}
8000524c:	02401021 	move	v0,s2
80005250:	8fbf003c 	lw	ra,60(sp)
80005254:	8fb60038 	lw	s6,56(sp)
80005258:	8fb50034 	lw	s5,52(sp)
8000525c:	8fb40030 	lw	s4,48(sp)
80005260:	8fb3002c 	lw	s3,44(sp)
80005264:	8fb20028 	lw	s2,40(sp)
80005268:	8fb10024 	lw	s1,36(sp)
8000526c:	8fb00020 	lw	s0,32(sp)
80005270:	03e00008 	jr	ra
80005274:	27bd0040 	addiu	sp,sp,64

80005278 <mxic_cmd_read_s1>:
	return ui;
}
#endif
// MX25L1605 MX25L3205 Read at High Speed (FAST_READ) Sequence (Command 0B)
unsigned int mxic_cmd_read_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
{
80005278:	27bdffd8 	addiu	sp,sp,-40
8000527c:	afbf0024 	sw	ra,36(sp)
	KDEBUG("mxic_cmd_read_s1: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_FASTREAD=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_FASTREAD);
	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_FASTREAD, ISFAST_YES, IOWIDTH_SINGLE, DUMMYCOUNT_1);
80005280:	3c020b00 	lui	v0,0xb00
80005284:	afa20010 	sw	v0,16(sp)
80005288:	24020001 	li	v0,1
8000528c:	afa20014 	sw	v0,20(sp)
80005290:	afa00018 	sw	zero,24(sp)
80005294:	afa2001c 	sw	v0,28(sp)
80005298:	0c001456 	jal	80005158 <ComSrlCmd_ComRead>
8000529c:	308400ff 	andi	a0,a0,0xff
}
800052a0:	8fbf0024 	lw	ra,36(sp)
800052a4:	03e00008 	jr	ra
800052a8:	27bd0028 	addiu	sp,sp,40

800052ac <ComSrlCmd_ComWriteSector>:
	ui = spiFlashReady(ucChip);
	return uiLen;
}
// write a whole sector once
unsigned int ComSrlCmd_ComWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned char* pucBuffer)
{
800052ac:	27bdffd8 	addiu	sp,sp,-40
800052b0:	afbf0024 	sw	ra,36(sp)
800052b4:	afb40020 	sw	s4,32(sp)
800052b8:	afb3001c 	sw	s3,28(sp)
800052bc:	afb20018 	sw	s2,24(sp)
800052c0:	afb10014 	sw	s1,20(sp)
800052c4:	afb00010 	sw	s0,16(sp)
800052c8:	00a08821 	move	s1,a1
800052cc:	00c09021 	move	s2,a2
800052d0:	309400ff 	andi	s4,a0,0xff
	unsigned int i, ui;
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComWriteSector: ucChip=%x; uiAddr=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, (unsigned int)pucBuffer, spi_flash_info[ucChip].sector_size);
	//prnDispAddr(uiAddr);
	NDEBUG(".");
800052d4:	3c048001 	lui	a0,0x8001
800052d8:	0c001cc1 	jal	80007304 <dprintf>
800052dc:	248423c0 	addiu	a0,a0,9152
	ui = spi_flash_info[ucChip].pfErase(ucChip, uiAddr);
800052e0:	001480c0 	sll	s0,s4,0x3
800052e4:	00141180 	sll	v0,s4,0x6
800052e8:	02021021 	addu	v0,s0,v0
800052ec:	3c108001 	lui	s0,0x8001
800052f0:	26105218 	addiu	s0,s0,21016
800052f4:	02028021 	addu	s0,s0,v0
800052f8:	8e020034 	lw	v0,52(s0)
800052fc:	02802021 	move	a0,s4
80005300:	0040f809 	jalr	v0
80005304:	02202821 	move	a1,s1
	for (i = 0; i < spi_flash_info[ucChip].page_cnt; i++)
80005308:	8e020024 	lw	v0,36(s0)
8000530c:	10400015 	beqz	v0,80005364 <ComSrlCmd_ComWriteSector+0xb8>
80005310:	00009821 	move	s3,zero
	{
		ui = spi_flash_info[ucChip].pfPageWrite(ucChip, uiAddr, spi_flash_info[ucChip].page_size, puc);
80005314:	001480c0 	sll	s0,s4,0x3
80005318:	00141180 	sll	v0,s4,0x6
8000531c:	02021021 	addu	v0,s0,v0
80005320:	3c108001 	lui	s0,0x8001
80005324:	26105218 	addiu	s0,s0,21016
80005328:	02028021 	addu	s0,s0,v0
8000532c:	8e020044 	lw	v0,68(s0)
80005330:	02802021 	move	a0,s4
80005334:	02202821 	move	a1,s1
80005338:	8e060020 	lw	a2,32(s0)
8000533c:	0040f809 	jalr	v0
80005340:	02403821 	move	a3,s2
		uiAddr += spi_flash_info[ucChip].page_size;
80005344:	8e020020 	lw	v0,32(s0)
80005348:	02228821 	addu	s1,s1,v0
		puc += spi_flash_info[ucChip].page_size;
8000534c:	02429021 	addu	s2,s2,v0
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComWriteSector: ucChip=%x; uiAddr=%x; pucBuffer=%x; returnValue=%x;\n", ucChip, uiAddr, (unsigned int)pucBuffer, spi_flash_info[ucChip].sector_size);
	//prnDispAddr(uiAddr);
	NDEBUG(".");
	ui = spi_flash_info[ucChip].pfErase(ucChip, uiAddr);
	for (i = 0; i < spi_flash_info[ucChip].page_cnt; i++)
80005350:	26730001 	addiu	s3,s3,1
80005354:	8e020024 	lw	v0,36(s0)
80005358:	0262102b 	sltu	v0,s3,v0
8000535c:	1440fff3 	bnez	v0,8000532c <ComSrlCmd_ComWriteSector+0x80>
80005360:	00000000 	nop
80005364:	001410c0 	sll	v0,s4,0x3
80005368:	0014a180 	sll	s4,s4,0x6
8000536c:	0054a021 	addu	s4,v0,s4
80005370:	3c028001 	lui	v0,0x8001
80005374:	24425218 	addiu	v0,v0,21016
80005378:	0282a021 	addu	s4,s4,v0
		ui = spi_flash_info[ucChip].pfPageWrite(ucChip, uiAddr, spi_flash_info[ucChip].page_size, puc);
		uiAddr += spi_flash_info[ucChip].page_size;
		puc += spi_flash_info[ucChip].page_size;
	}
	return spi_flash_info[ucChip].sector_size;
}
8000537c:	8e820018 	lw	v0,24(s4)
80005380:	8fbf0024 	lw	ra,36(sp)
80005384:	8fb40020 	lw	s4,32(sp)
80005388:	8fb3001c 	lw	s3,28(sp)
8000538c:	8fb20018 	lw	s2,24(sp)
80005390:	8fb10014 	lw	s1,20(sp)
80005394:	8fb00010 	lw	s0,16(sp)
80005398:	03e00008 	jr	ra
8000539c:	27bd0028 	addiu	sp,sp,40

800053a0 <ComSrlCmd_BufWriteSector>:

// write sector use malloc buffer
unsigned int ComSrlCmd_BufWriteSector(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
{
800053a0:	27bdffd0 	addiu	sp,sp,-48
800053a4:	afbf002c 	sw	ra,44(sp)
800053a8:	afbe0028 	sw	s8,40(sp)
800053ac:	afb50024 	sw	s5,36(sp)
800053b0:	afb40020 	sw	s4,32(sp)
800053b4:	afb3001c 	sw	s3,28(sp)
800053b8:	afb20018 	sw	s2,24(sp)
800053bc:	afb10014 	sw	s1,20(sp)
800053c0:	afb00010 	sw	s0,16(sp)
800053c4:	03a0f021 	move	s8,sp
800053c8:	00c08821 	move	s1,a2
800053cc:	00e0a821 	move	s5,a3
800053d0:	309000ff 	andi	s0,a0,0xff
	unsigned char pucSector[spi_flash_info[ucChip].sector_size];
800053d4:	001018c0 	sll	v1,s0,0x3
800053d8:	00101180 	sll	v0,s0,0x6
800053dc:	00621021 	addu	v0,v1,v0
800053e0:	3c038001 	lui	v1,0x8001
800053e4:	24635218 	addiu	v1,v1,21016
800053e8:	00431021 	addu	v0,v0,v1
800053ec:	8c460018 	lw	a2,24(v0)
800053f0:	24c3000e 	addiu	v1,a2,14
800053f4:	000318c2 	srl	v1,v1,0x3
800053f8:	000318c0 	sll	v1,v1,0x3
800053fc:	03a3e823 	subu	sp,sp,v1
80005400:	27b30010 	addiu	s3,sp,16
	unsigned int ui, uiStartAddr, uiOffset;
	LDEBUG("ComSrlCmd_BufWriteSector:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x;\n", ucChip, uiAddr, uiLen, pucBuffer);
	uiOffset = uiAddr % spi_flash_info[ucChip].sector_size;
80005404:	00a6001b 	divu	zero,a1,a2
80005408:	00c001f4 	teq	a2,zero,0x7
8000540c:	0000a010 	mfhi	s4
	uiStartAddr = uiAddr - uiOffset;
80005410:	00b49023 	subu	s2,a1,s4
	// get
	ui = spi_flash_info[ucChip].pfRead(ucChip, uiStartAddr, spi_flash_info[ucChip].sector_size, pucSector);
80005414:	8c42003c 	lw	v0,60(v0)
80005418:	02002021 	move	a0,s0
8000541c:	02402821 	move	a1,s2
80005420:	0040f809 	jalr	v0
80005424:	02603821 	move	a3,s3
	// modify
	memcpy(pucSector + uiOffset, pucBuffer, uiLen);
80005428:	02742021 	addu	a0,s3,s4
8000542c:	02a02821 	move	a1,s5
80005430:	0c0019e2 	jal	80006788 <memcpy>
80005434:	02203021 	move	a2,s1
	//write back
	ui = ComSrlCmd_ComWriteSector(ucChip, uiStartAddr, pucSector);
80005438:	02002021 	move	a0,s0
8000543c:	02402821 	move	a1,s2
80005440:	0c0014ab 	jal	800052ac <ComSrlCmd_ComWriteSector>
80005444:	02603021 	move	a2,s3
	return ui;
}
80005448:	03c0e821 	move	sp,s8
8000544c:	8fbf002c 	lw	ra,44(sp)
80005450:	8fbe0028 	lw	s8,40(sp)
80005454:	8fb50024 	lw	s5,36(sp)
80005458:	8fb40020 	lw	s4,32(sp)
8000545c:	8fb3001c 	lw	s3,28(sp)
80005460:	8fb20018 	lw	s2,24(sp)
80005464:	8fb10014 	lw	s1,20(sp)
80005468:	8fb00010 	lw	s0,16(sp)
8000546c:	03e00008 	jr	ra
80005470:	27bd0030 	addiu	sp,sp,48

80005474 <ComSrlCmd_ComWriteData>:

// write data, any address any lenth
unsigned int ComSrlCmd_ComWriteData(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
{
80005474:	27bdffa8 	addiu	sp,sp,-88
80005478:	afbf0054 	sw	ra,84(sp)
8000547c:	afb40050 	sw	s4,80(sp)
80005480:	afb3004c 	sw	s3,76(sp)
80005484:	afb20048 	sw	s2,72(sp)
80005488:	afb10044 	sw	s1,68(sp)
8000548c:	afb00040 	sw	s0,64(sp)
80005490:	00c0a021 	move	s4,a2
80005494:	00e08821 	move	s1,a3
80005498:	309300ff 	andi	s3,a0,0xff
	unsigned int uiStartAddr, uiStartLen, uiSectorAddr, uiSectorCount, uiEndAddr, uiEndLen, i;
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComWriteData:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer);
	calAddr(uiAddr, uiLen, spi_flash_info[ucChip].sector_size, &uiStartAddr, &uiStartLen, &uiSectorAddr, &uiSectorCount, &uiEndAddr, &uiEndLen);
8000549c:	001318c0 	sll	v1,s3,0x3
800054a0:	00131180 	sll	v0,s3,0x6
800054a4:	00621021 	addu	v0,v1,v0
800054a8:	3c038001 	lui	v1,0x8001
800054ac:	24635218 	addiu	v1,v1,21016
800054b0:	00431021 	addu	v0,v0,v1
800054b4:	8c460018 	lw	a2,24(v0)
800054b8:	27a2002c 	addiu	v0,sp,44
800054bc:	afa20010 	sw	v0,16(sp)
800054c0:	27a20030 	addiu	v0,sp,48
800054c4:	afa20014 	sw	v0,20(sp)
800054c8:	27a20034 	addiu	v0,sp,52
800054cc:	afa20018 	sw	v0,24(sp)
800054d0:	27a20038 	addiu	v0,sp,56
800054d4:	afa2001c 	sw	v0,28(sp)
800054d8:	27a2003c 	addiu	v0,sp,60
800054dc:	afa20020 	sw	v0,32(sp)
800054e0:	00a02021 	move	a0,a1
800054e4:	02802821 	move	a1,s4
800054e8:	0c001275 	jal	800049d4 <calAddr>
800054ec:	27a70028 	addiu	a3,sp,40
	if((uiSectorCount == 0x00) && (uiEndLen == 0x00))	// all data in the same sector
800054f0:	8fa20034 	lw	v0,52(sp)
800054f4:	1440000a 	bnez	v0,80005520 <ComSrlCmd_ComWriteData+0xac>
800054f8:	8fa6002c 	lw	a2,44(sp)
800054fc:	8fa2003c 	lw	v0,60(sp)
80005500:	14400007 	bnez	v0,80005520 <ComSrlCmd_ComWriteData+0xac>
80005504:	02602021 	move	a0,s3
	{
		ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
80005508:	8fa50028 	lw	a1,40(sp)
8000550c:	8fa6002c 	lw	a2,44(sp)
80005510:	0c0014e8 	jal	800053a0 <ComSrlCmd_BufWriteSector>
80005514:	02203821 	move	a3,s1
{
	unsigned int uiStartAddr, uiStartLen, uiSectorAddr, uiSectorCount, uiEndAddr, uiEndLen, i;
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComWriteData:ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer);
	calAddr(uiAddr, uiLen, spi_flash_info[ucChip].sector_size, &uiStartAddr, &uiStartLen, &uiSectorAddr, &uiSectorCount, &uiEndAddr, &uiEndLen);
	if((uiSectorCount == 0x00) && (uiEndLen == 0x00))	// all data in the same sector
80005518:	0800156e 	j	800055b8 <ComSrlCmd_ComWriteData+0x144>
8000551c:	02602021 	move	a0,s3
	{
		ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
	}
	else
	{
		if(uiStartLen > 0)
80005520:	10c00007 	beqz	a2,80005540 <ComSrlCmd_ComWriteData+0xcc>
80005524:	02208021 	move	s0,s1
		{
			ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
80005528:	02602021 	move	a0,s3
8000552c:	8fa50028 	lw	a1,40(sp)
80005530:	0c0014e8 	jal	800053a0 <ComSrlCmd_BufWriteSector>
80005534:	02203821 	move	a3,s1
			puc += uiStartLen;
80005538:	8fb0002c 	lw	s0,44(sp)
8000553c:	02308021 	addu	s0,s1,s0
		}
		for(i = 0; i < uiSectorCount; i++)
80005540:	8fa20034 	lw	v0,52(sp)
80005544:	10400015 	beqz	v0,8000559c <ComSrlCmd_ComWriteData+0x128>
80005548:	00008821 	move	s1,zero
		{
			ComSrlCmd_ComWriteSector(ucChip, uiSectorAddr, puc);
			puc += spi_flash_info[ucChip].sector_size;
8000554c:	001390c0 	sll	s2,s3,0x3
80005550:	00131180 	sll	v0,s3,0x6
80005554:	02429021 	addu	s2,s2,v0
80005558:	3c028001 	lui	v0,0x8001
8000555c:	24425218 	addiu	v0,v0,21016
80005560:	02429021 	addu	s2,s2,v0
			ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
			puc += uiStartLen;
		}
		for(i = 0; i < uiSectorCount; i++)
		{
			ComSrlCmd_ComWriteSector(ucChip, uiSectorAddr, puc);
80005564:	02602021 	move	a0,s3
80005568:	8fa50030 	lw	a1,48(sp)
8000556c:	0c0014ab 	jal	800052ac <ComSrlCmd_ComWriteSector>
80005570:	02003021 	move	a2,s0
			puc += spi_flash_info[ucChip].sector_size;
80005574:	8e420018 	lw	v0,24(s2)
80005578:	02028021 	addu	s0,s0,v0
			uiSectorAddr += spi_flash_info[ucChip].sector_size;
8000557c:	8fa30030 	lw	v1,48(sp)
80005580:	00621021 	addu	v0,v1,v0
80005584:	afa20030 	sw	v0,48(sp)
		if(uiStartLen > 0)
		{
			ComSrlCmd_BufWriteSector(ucChip, uiStartAddr, uiStartLen, puc);
			puc += uiStartLen;
		}
		for(i = 0; i < uiSectorCount; i++)
80005588:	26310001 	addiu	s1,s1,1
8000558c:	8fa20034 	lw	v0,52(sp)
80005590:	0222102b 	sltu	v0,s1,v0
80005594:	1440fff4 	bnez	v0,80005568 <ComSrlCmd_ComWriteData+0xf4>
80005598:	02602021 	move	a0,s3
		{
			ComSrlCmd_ComWriteSector(ucChip, uiSectorAddr, puc);
			puc += spi_flash_info[ucChip].sector_size;
			uiSectorAddr += spi_flash_info[ucChip].sector_size;
		}
		if(uiEndLen > 0)
8000559c:	8fa6003c 	lw	a2,60(sp)
800055a0:	10c00005 	beqz	a2,800055b8 <ComSrlCmd_ComWriteData+0x144>
800055a4:	02602021 	move	a0,s3
		{
			ComSrlCmd_BufWriteSector(ucChip, uiEndAddr, uiEndLen, puc);
800055a8:	8fa50038 	lw	a1,56(sp)
800055ac:	0c0014e8 	jal	800053a0 <ComSrlCmd_BufWriteSector>
800055b0:	02003821 	move	a3,s0
		}
	}
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WRDI);
800055b4:	02602021 	move	a0,s3
800055b8:	00002821 	move	a1,zero
800055bc:	0c001322 	jal	80004c88 <SeqCmd_Order>
800055c0:	3c060400 	lui	a2,0x400
	return uiLen;
}
800055c4:	02801021 	move	v0,s4
800055c8:	8fbf0054 	lw	ra,84(sp)
800055cc:	8fb40050 	lw	s4,80(sp)
800055d0:	8fb3004c 	lw	s3,76(sp)
800055d4:	8fb20048 	lw	s2,72(sp)
800055d8:	8fb10044 	lw	s1,68(sp)
800055dc:	8fb00040 	lw	s0,64(sp)
800055e0:	03e00008 	jr	ra
800055e4:	27bd0058 	addiu	sp,sp,88

800055e8 <prnFlashInfo>:
	#endif
	return (unsigned char)ui;	
}
// Print spi_flash_type
void prnFlashInfo(unsigned char ucChip, struct spi_flash_type sftInfo)
{
800055e8:	27bdff90 	addiu	sp,sp,-112
800055ec:	afbf006c 	sw	ra,108(sp)
800055f0:	afbe0068 	sw	s8,104(sp)
800055f4:	afb70064 	sw	s7,100(sp)
800055f8:	afb60060 	sw	s6,96(sp)
800055fc:	afb5005c 	sw	s5,92(sp)
80005600:	afb40058 	sw	s4,88(sp)
80005604:	afb30054 	sw	s3,84(sp)
80005608:	afb20050 	sw	s2,80(sp)
8000560c:	afb1004c 	sw	s1,76(sp)
80005610:	afb00048 	sw	s0,72(sp)
80005614:	afa50074 	sw	a1,116(sp)
80005618:	afa60078 	sw	a2,120(sp)
8000561c:	afa7007c 	sw	a3,124(sp)
80005620:	309000ff 	andi	s0,a0,0xff
80005624:	00a08821 	move	s1,a1
80005628:	00069602 	srl	s2,a2,0x18
8000562c:	7cd63c00 	ext	s6,a2,0x10,0x8
80005630:	7cd73a00 	ext	s7,a2,0x8,0x8
80005634:	30de00ff 	andi	s8,a2,0xff
80005638:	00073e02 	srl	a3,a3,0x18
8000563c:	afa70040 	sw	a3,64(sp)
80005640:	8fa20080 	lw	v0,128(sp)
80005644:	afa2003c 	sw	v0,60(sp)
80005648:	8fb30084 	lw	s3,132(sp)
8000564c:	8fb40088 	lw	s4,136(sp)
80005650:	8fb5008c 	lw	s5,140(sp)
80005654:	8fa20090 	lw	v0,144(sp)
80005658:	afa20038 	sw	v0,56(sp)
8000565c:	8fa20094 	lw	v0,148(sp)
80005660:	afa20034 	sw	v0,52(sp)
80005664:	8fa20098 	lw	v0,152(sp)
80005668:	afa20030 	sw	v0,48(sp)
8000566c:	8fa2009c 	lw	v0,156(sp)
80005670:	afa2002c 	sw	v0,44(sp)
80005674:	8fa200a0 	lw	v0,160(sp)
80005678:	afa20028 	sw	v0,40(sp)
	NDEBUG("* blk_size blk__cnt sec_size sec__cnt pageSize page_cnt chip_clk chipName\n");
	NDEBUG("* %7xh %7xh %7xh %7xh %7xh %7xh %7xh %s\n", sftInfo.block_size, sftInfo.block_cnt, sftInfo.sector_size, sftInfo.sector_cnt, sftInfo.page_size, sftInfo.page_cnt, sftInfo.chip_clk, sftInfo.chip_name);
	NDEBUG("* \n");
	NDEBUG("********************************************************************************\n");
#else
	NDEBUG("\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
8000567c:	3c048001 	lui	a0,0x8001
80005680:	0c001cc1 	jal	80007304 <dprintf>
80005684:	248405e4 	addiu	a0,a0,1508
	NDEBUG("@\n");
80005688:	3c048001 	lui	a0,0x8001
8000568c:	0c001cc1 	jal	80007304 <dprintf>
80005690:	24840634 	addiu	a0,a0,1588
	NDEBUG("@ chip__no chip__id mfr___id dev___id cap___id size_sft dev_size chipSize\n");
80005694:	3c048001 	lui	a0,0x8001
80005698:	0c001cc1 	jal	80007304 <dprintf>
8000569c:	24840638 	addiu	a0,a0,1592
	NDEBUG("@ %7xh %7xh %7xh %7xh %7xh %7xh %7xh %7xh\n", ucChip, sftInfo.chip_id, sftInfo.mfr_id, sftInfo.dev_id, sftInfo.capacity_id, sftInfo.size_shift, sftInfo.device_size, sftInfo.chip_size);
800056a0:	afb60010 	sw	s6,16(sp)
800056a4:	afb70014 	sw	s7,20(sp)
800056a8:	afbe0018 	sw	s8,24(sp)
800056ac:	8fa20040 	lw	v0,64(sp)
800056b0:	afa2001c 	sw	v0,28(sp)
800056b4:	8fa2003c 	lw	v0,60(sp)
800056b8:	afa20020 	sw	v0,32(sp)
800056bc:	3c048001 	lui	a0,0x8001
800056c0:	24840684 	addiu	a0,a0,1668
800056c4:	02002821 	move	a1,s0
800056c8:	02203021 	move	a2,s1
800056cc:	0c001cc1 	jal	80007304 <dprintf>
800056d0:	02403821 	move	a3,s2
	NDEBUG("@ blk_size blk__cnt sec_size sec__cnt pageSize page_cnt chip_clk chipName\n");
800056d4:	3c048001 	lui	a0,0x8001
800056d8:	0c001cc1 	jal	80007304 <dprintf>
800056dc:	248406b0 	addiu	a0,a0,1712
	NDEBUG("@ %7xh %7xh %7xh %7xh %7xh %7xh %7xh %s\n", sftInfo.block_size, sftInfo.block_cnt, sftInfo.sector_size, sftInfo.sector_cnt, sftInfo.page_size, sftInfo.page_cnt, sftInfo.chip_clk, sftInfo.chip_name);
800056e0:	8fa20038 	lw	v0,56(sp)
800056e4:	afa20010 	sw	v0,16(sp)
800056e8:	8fa20034 	lw	v0,52(sp)
800056ec:	afa20014 	sw	v0,20(sp)
800056f0:	8fa20030 	lw	v0,48(sp)
800056f4:	afa20018 	sw	v0,24(sp)
800056f8:	8fa2002c 	lw	v0,44(sp)
800056fc:	afa2001c 	sw	v0,28(sp)
80005700:	8fa20028 	lw	v0,40(sp)
80005704:	afa20020 	sw	v0,32(sp)
80005708:	3c048001 	lui	a0,0x8001
8000570c:	248406fc 	addiu	a0,a0,1788
80005710:	02602821 	move	a1,s3
80005714:	02803021 	move	a2,s4
80005718:	0c001cc1 	jal	80007304 <dprintf>
8000571c:	02a03821 	move	a3,s5
	NDEBUG("@ \n");
80005720:	3c048001 	lui	a0,0x8001
80005724:	0c001cc1 	jal	80007304 <dprintf>
80005728:	24840728 	addiu	a0,a0,1832
	NDEBUG("@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
8000572c:	3c048001 	lui	a0,0x8001
80005730:	0c001cc1 	jal	80007304 <dprintf>
80005734:	2484072c 	addiu	a0,a0,1836
#endif
}
80005738:	8fbf006c 	lw	ra,108(sp)
8000573c:	8fbe0068 	lw	s8,104(sp)
80005740:	8fb70064 	lw	s7,100(sp)
80005744:	8fb60060 	lw	s6,96(sp)
80005748:	8fb5005c 	lw	s5,92(sp)
8000574c:	8fb40058 	lw	s4,88(sp)
80005750:	8fb30054 	lw	s3,84(sp)
80005754:	8fb20050 	lw	s2,80(sp)
80005758:	8fb1004c 	lw	s1,76(sp)
8000575c:	8fb00048 	lw	s0,72(sp)
80005760:	03e00008 	jr	ra
80005764:	27bd0070 	addiu	sp,sp,112

80005768 <rstSPIFlash>:
	KDEBUG("spiFlashReady: uiCount=%x\n", uiCount);	
	return uiCount;
}
//toggle CS
void rstSPIFlash(unsigned char ucChip)
{
80005768:	27bdffe8 	addiu	sp,sp,-24
8000576c:	afbf0014 	sw	ra,20(sp)
80005770:	afb00010 	sw	s0,16(sp)
80005774:	309000ff 	andi	s0,a0,0xff
#if 1
delay_ms(1);
80005778:	0c001bb5 	jal	80006ed4 <delay_ms>
8000577c:	24040001 	li	a0,1
	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
80005780:	02002021 	move	a0,s0
80005784:	00002821 	move	a1,zero
80005788:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
8000578c:	00003021 	move	a2,zero
	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
80005790:	02002021 	move	a0,s0
80005794:	00002821 	move	a1,zero
80005798:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
8000579c:	00003021 	move	a2,zero
	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
800057a0:	02002021 	move	a0,s0
800057a4:	00002821 	move	a1,zero
800057a8:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
800057ac:	00003021 	move	a2,zero
	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
800057b0:	02002021 	move	a0,s0
800057b4:	00002821 	move	a1,zero
800057b8:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
800057bc:	00003021 	move	a2,zero
	LDEBUG("rstFPIFlash: ucChip=%x;\n", ucChip);	
#endif	
}
800057c0:	8fbf0014 	lw	ra,20(sp)
800057c4:	8fb00010 	lw	s0,16(sp)
800057c8:	03e00008 	jr	ra
800057cc:	27bd0018 	addiu	sp,sp,24

800057d0 <ComSrlCmd_RDID>:
}


// Read Identification (RDID) Sequence (Command 9F)
unsigned int ComSrlCmd_RDID(unsigned char ucChip, unsigned int uiLen)
{
800057d0:	27bdffe0 	addiu	sp,sp,-32
800057d4:	afbf001c 	sw	ra,28(sp)
800057d8:	afb20018 	sw	s2,24(sp)
800057dc:	afb10014 	sw	s1,20(sp)
800057e0:	afb00010 	sw	s0,16(sp)
800057e4:	00a08821 	move	s1,a1
800057e8:	309000ff 	andi	s0,a0,0xff
	unsigned int ui;
	SPI_REG_LOAD(SFCR, (SFCR_SPI_CLK_DIV(7) | SFCR_RBO(1) | SFCR_WBO(1) | SFCR_SPI_TCS(31)));		//SFCR default setting
800057ec:	3c05b800 	lui	a1,0xb800
800057f0:	34a51208 	ori	a1,a1,0x1208
800057f4:	3c030800 	lui	v1,0x800
800057f8:	8ca20000 	lw	v0,0(a1)
800057fc:	00431024 	and	v0,v0,v1
80005800:	1040fffd 	beqz	v0,800057f8 <ComSrlCmd_RDID+0x28>
80005804:	3c02b800 	lui	v0,0xb800
80005808:	3c03ffc0 	lui	v1,0xffc0
8000580c:	34421200 	ori	v0,v0,0x1200
80005810:	ac430000 	sw	v1,0(v0)
	//SPI_REG_LOAD(SFCR, (SFCR_SPI_CLK_DIV(0) | SFCR_RBO(1) | SFCR_WBO(1) | SFCR_SPI_TCS(31)));		//SFCR default setting
	
	rstSPIFlash(ucChip);
80005814:	0c0015da 	jal	80005768 <rstSPIFlash>
80005818:	02002021 	move	a0,s0
	SFCSR_CS_L(ucChip, 0, IOWIDTH_SINGLE);
8000581c:	02002021 	move	a0,s0
80005820:	00002821 	move	a1,zero
80005824:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80005828:	00003021 	move	a2,zero
	SPI_REG_LOAD(SFDR, SPICMD_RDID);
8000582c:	3c04b800 	lui	a0,0xb800
80005830:	34841208 	ori	a0,a0,0x1208
80005834:	3c030800 	lui	v1,0x800
80005838:	8c820000 	lw	v0,0(a0)
8000583c:	00431024 	and	v0,v0,v1
80005840:	1040fffd 	beqz	v0,80005838 <ComSrlCmd_RDID+0x68>
80005844:	3c12b800 	lui	s2,0xb800
80005848:	3652120c 	ori	s2,s2,0x120c
8000584c:	3c029f00 	lui	v0,0x9f00
80005850:	ae420000 	sw	v0,0(s2)
	SFCSR_CS_L(ucChip, (uiLen - 1), IOWIDTH_SINGLE);
80005854:	2625ffff 	addiu	a1,s1,-1
80005858:	02002021 	move	a0,s0
8000585c:	30a500ff 	andi	a1,a1,0xff
80005860:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80005864:	00003021 	move	a2,zero
	ui = SPI_REG_READ(SFDR);
80005868:	8e510000 	lw	s1,0(s2)
	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
8000586c:	02002021 	move	a0,s0
80005870:	00002821 	move	a1,zero
80005874:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80005878:	00003021 	move	a2,zero
	LDEBUG("ComSrlCmd_RDID: ucChip=%x; uiLen=%x; returnValue=%x; SPICMD_RDID=%x;\n", ucChip, uiLen, ui, SPICMD_RDID);
	return ui;
}
8000587c:	02201021 	move	v0,s1
80005880:	8fbf001c 	lw	ra,28(sp)
80005884:	8fb20018 	lw	s2,24(sp)
80005888:	8fb10014 	lw	s1,20(sp)
8000588c:	8fb00010 	lw	s0,16(sp)
80005890:	03e00008 	jr	ra
80005894:	27bd0020 	addiu	sp,sp,32

80005898 <spi_regist>:
#endif
},
};
// spi flash probe
void spi_regist(unsigned char ucChip)
{
80005898:	27bdff98 	addiu	sp,sp,-104
8000589c:	afbf0064 	sw	ra,100(sp)
800058a0:	afb20060 	sw	s2,96(sp)
800058a4:	afb1005c 	sw	s1,92(sp)
800058a8:	afb00058 	sw	s0,88(sp)
800058ac:	309200ff 	andi	s2,a0,0xff
	unsigned int ui, i, uiCount;
	unsigned char pucBuffer[4];

	ui = ComSrlCmd_RDID(ucChip, 4);
800058b0:	02402021 	move	a0,s2
800058b4:	0c0015f4 	jal	800057d0 <ComSrlCmd_RDID>
800058b8:	24050004 	li	a1,4
				ComSrlCmd_EN4B(ucChip, 4);//for SPI CS#0 , send "EN4B" command
	}	
	#endif
	
	
	ui = ui >> 8;
800058bc:	00028a02 	srl	s1,v0,0x8
800058c0:	3c028001 	lui	v0,0x8001
800058c4:	24422a14 	addiu	v0,v0,10772
800058c8:	00008021 	move	s0,zero

	uiCount = sizeof(spi_flash_registed) / sizeof(struct spi_flash_known);

	for (i = 0; i < uiCount; i++)
800058cc:	2404001e 	li	a0,30
	{
		if((spi_flash_registed[i].uiChipId == ui) && (spi_flash_registed[i].uiDistinguish == 0x00))
800058d0:	8c430000 	lw	v1,0(v0)
800058d4:	14710004 	bne	v1,s1,800058e8 <spi_regist+0x50>
800058d8:	00000000 	nop
800058dc:	8c430004 	lw	v1,4(v0)
800058e0:	10600006 	beqz	v1,800058fc <spi_regist+0x64>
800058e4:	00000000 	nop
	
	ui = ui >> 8;

	uiCount = sizeof(spi_flash_registed) / sizeof(struct spi_flash_known);

	for (i = 0; i < uiCount; i++)
800058e8:	26100001 	addiu	s0,s0,1
800058ec:	1604fff8 	bne	s0,a0,800058d0 <spi_regist+0x38>
800058f0:	24420020 	addiu	v0,v0,32
		}
	}
	if(i == uiCount)
	{
		// default setting
		setFSCR(ucChip, 40, 1, 1, 31);
800058f4:	08001643 	j	8000590c <spi_regist+0x74>
800058f8:	2402001f 	li	v0,31
		if((spi_flash_registed[i].uiChipId == ui) && (spi_flash_registed[i].uiDistinguish == 0x00))
		{
			break;
		}
	}
	if(i == uiCount)
800058fc:	2402001e 	li	v0,30
80005900:	16020022 	bne	s0,v0,8000598c <spi_regist+0xf4>
80005904:	3c028001 	lui	v0,0x8001
	{
		// default setting
		setFSCR(ucChip, 40, 1, 1, 31);
80005908:	2402001f 	li	v0,31
8000590c:	afa20010 	sw	v0,16(sp)
80005910:	02402021 	move	a0,s2
80005914:	24050028 	li	a1,40
80005918:	24060001 	li	a2,1
8000591c:	0c00123e 	jal	800048f8 <setFSCR>
80005920:	24070001 	li	a3,1
		set_flash_info(ucChip, ui, SIZEN_16M, SIZE_064K, SIZE_004K, SIZE_256B, "UNKNOWN", ComSrlCmd_SE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
80005924:	24021000 	li	v0,4096
80005928:	afa20010 	sw	v0,16(sp)
8000592c:	24020100 	li	v0,256
80005930:	afa20014 	sw	v0,20(sp)
80005934:	3c028001 	lui	v0,0x8001
80005938:	24420780 	addiu	v0,v0,1920
8000593c:	afa20018 	sw	v0,24(sp)
80005940:	3c028000 	lui	v0,0x8000
80005944:	24425e74 	addiu	v0,v0,24180
80005948:	afa2001c 	sw	v0,28(sp)
8000594c:	3c028000 	lui	v0,0x8000
80005950:	24425278 	addiu	v0,v0,21112
80005954:	afa20020 	sw	v0,32(sp)
80005958:	3c028000 	lui	v0,0x8000
8000595c:	24424e98 	addiu	v0,v0,20120
80005960:	afa20024 	sw	v0,36(sp)
80005964:	3c028000 	lui	v0,0x8000
80005968:	24425d64 	addiu	v0,v0,23908
8000596c:	afa20028 	sw	v0,40(sp)
80005970:	02402021 	move	a0,s2
80005974:	02202821 	move	a1,s1
80005978:	24060018 	li	a2,24
8000597c:	0c0012a8 	jal	80004aa0 <set_flash_info>
80005980:	3c070001 	lui	a3,0x1
		{
			set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, ComSrlCmd_SE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
		}
#endif
	}
	spi_flash_info[ucChip].pfQeBit(ucChip);
80005984:	080016b7 	j	80005adc <spi_regist+0x244>
80005988:	001280c0 	sll	s0,s2,0x3
		set_flash_info(ucChip, ui, SIZEN_16M, SIZE_064K, SIZE_004K, SIZE_256B, "UNKNOWN", ComSrlCmd_SE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
	}
	else
	{
		// have registed
		setFSCR(ucChip, spi_flash_registed[i].uiClk, 1, 1, 31);
8000598c:	00101940 	sll	v1,s0,0x5
80005990:	24422a14 	addiu	v0,v0,10772
80005994:	00431021 	addu	v0,v0,v1
80005998:	8c45001c 	lw	a1,28(v0)
8000599c:	2402001f 	li	v0,31
800059a0:	afa20010 	sw	v0,16(sp)
800059a4:	02402021 	move	a0,s2
800059a8:	24060001 	li	a2,1
800059ac:	0c00123e 	jal	800048f8 <setFSCR>
800059b0:	24070001 	li	a3,1
#ifndef CONFIG_SPI_STD_MODE
		set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, spi_flash_registed[i].pfErase, spi_flash_registed[i].pfRead, spi_flash_registed[i].pfQeBit, spi_flash_registed[i].pfPageWrite);
#else
		if((ui & 0x00ffff00) == SPANSION_F)
800059b4:	3c0300ff 	lui	v1,0xff
800059b8:	3463ff00 	ori	v1,v1,0xff00
800059bc:	02231824 	and	v1,s1,v1
800059c0:	3c020001 	lui	v0,0x1
800059c4:	34420200 	ori	v0,v0,0x200
800059c8:	14620023 	bne	v1,v0,80005a58 <spi_regist+0x1c0>
800059cc:	3c028001 	lui	v0,0x8001
		{
			set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, ComSrlCmd_BE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
800059d0:	00101940 	sll	v1,s0,0x5
800059d4:	24630008 	addiu	v1,v1,8
800059d8:	24422a14 	addiu	v0,v0,10772
800059dc:	00621821 	addu	v1,v1,v0
800059e0:	8c660000 	lw	a2,0(v1)
800059e4:	8c670004 	lw	a3,4(v1)
800059e8:	00101940 	sll	v1,s0,0x5
800059ec:	24630010 	addiu	v1,v1,16
800059f0:	00621821 	addu	v1,v1,v0
800059f4:	8c640000 	lw	a0,0(v1)
800059f8:	afa40010 	sw	a0,16(sp)
800059fc:	8c630004 	lw	v1,4(v1)
80005a00:	afa30014 	sw	v1,20(sp)
80005a04:	00108140 	sll	s0,s0,0x5
80005a08:	02021021 	addu	v0,s0,v0
80005a0c:	8c420018 	lw	v0,24(v0)
80005a10:	afa20018 	sw	v0,24(sp)
80005a14:	3c028000 	lui	v0,0x8000
80005a18:	24425ddc 	addiu	v0,v0,24028
80005a1c:	afa2001c 	sw	v0,28(sp)
80005a20:	3c028000 	lui	v0,0x8000
80005a24:	24425278 	addiu	v0,v0,21112
80005a28:	afa20020 	sw	v0,32(sp)
80005a2c:	3c028000 	lui	v0,0x8000
80005a30:	24424e98 	addiu	v0,v0,20120
80005a34:	afa20024 	sw	v0,36(sp)
80005a38:	3c028000 	lui	v0,0x8000
80005a3c:	24425d64 	addiu	v0,v0,23908
80005a40:	afa20028 	sw	v0,40(sp)
80005a44:	02402021 	move	a0,s2
80005a48:	0c0012a8 	jal	80004aa0 <set_flash_info>
80005a4c:	02202821 	move	a1,s1
		{
			set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, ComSrlCmd_SE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
		}
#endif
	}
	spi_flash_info[ucChip].pfQeBit(ucChip);
80005a50:	080016b7 	j	80005adc <spi_regist+0x244>
80005a54:	001280c0 	sll	s0,s2,0x3
		{
			set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, ComSrlCmd_BE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
		}
		else
		{
			set_flash_info(ucChip, ui, spi_flash_registed[i].uiCapacityId, spi_flash_registed[i].uiBlockSize, spi_flash_registed[i].uiSectorSize, spi_flash_registed[i].uiPageSize, spi_flash_registed[i].pcChipName, ComSrlCmd_SE, mxic_cmd_read_s1, ComSrlCmd_NoneQeBit, mxic_cmd_write_s1);
80005a58:	00101940 	sll	v1,s0,0x5
80005a5c:	24630008 	addiu	v1,v1,8
80005a60:	24422a14 	addiu	v0,v0,10772
80005a64:	00621821 	addu	v1,v1,v0
80005a68:	8c660000 	lw	a2,0(v1)
80005a6c:	8c670004 	lw	a3,4(v1)
80005a70:	00101940 	sll	v1,s0,0x5
80005a74:	24630010 	addiu	v1,v1,16
80005a78:	00621821 	addu	v1,v1,v0
80005a7c:	8c640000 	lw	a0,0(v1)
80005a80:	afa40010 	sw	a0,16(sp)
80005a84:	8c630004 	lw	v1,4(v1)
80005a88:	afa30014 	sw	v1,20(sp)
80005a8c:	00108140 	sll	s0,s0,0x5
80005a90:	02021021 	addu	v0,s0,v0
80005a94:	8c420018 	lw	v0,24(v0)
80005a98:	afa20018 	sw	v0,24(sp)
80005a9c:	3c028000 	lui	v0,0x8000
80005aa0:	24425e74 	addiu	v0,v0,24180
80005aa4:	afa2001c 	sw	v0,28(sp)
80005aa8:	3c028000 	lui	v0,0x8000
80005aac:	24425278 	addiu	v0,v0,21112
80005ab0:	afa20020 	sw	v0,32(sp)
80005ab4:	3c028000 	lui	v0,0x8000
80005ab8:	24424e98 	addiu	v0,v0,20120
80005abc:	afa20024 	sw	v0,36(sp)
80005ac0:	3c028000 	lui	v0,0x8000
80005ac4:	24425d64 	addiu	v0,v0,23908
80005ac8:	afa20028 	sw	v0,40(sp)
80005acc:	02402021 	move	a0,s2
80005ad0:	0c0012a8 	jal	80004aa0 <set_flash_info>
80005ad4:	02202821 	move	a1,s1
		}
#endif
	}
	spi_flash_info[ucChip].pfQeBit(ucChip);
80005ad8:	001280c0 	sll	s0,s2,0x3
80005adc:	00121180 	sll	v0,s2,0x6
80005ae0:	02028021 	addu	s0,s0,v0
80005ae4:	3c028001 	lui	v0,0x8001
80005ae8:	24425218 	addiu	v0,v0,21016
80005aec:	02028021 	addu	s0,s0,v0
80005af0:	8e020040 	lw	v0,64(s0)
80005af4:	0040f809 	jalr	v0
80005af8:	02402021 	move	a0,s2
	prnFlashInfo(ucChip, spi_flash_info[ucChip]);
80005afc:	2602000c 	addiu	v0,s0,12
80005b00:	27a30010 	addiu	v1,sp,16
80005b04:	2604003c 	addiu	a0,s0,60
80005b08:	8c480000 	lw	t0,0(v0)
80005b0c:	8c470004 	lw	a3,4(v0)
80005b10:	8c460008 	lw	a2,8(v0)
80005b14:	8c45000c 	lw	a1,12(v0)
80005b18:	ac680000 	sw	t0,0(v1)
80005b1c:	ac670004 	sw	a3,4(v1)
80005b20:	ac660008 	sw	a2,8(v1)
80005b24:	ac65000c 	sw	a1,12(v1)
80005b28:	24420010 	addiu	v0,v0,16
80005b2c:	1444fff6 	bne	v0,a0,80005b08 <spi_regist+0x270>
80005b30:	24630010 	addiu	v1,v1,16
80005b34:	8c450000 	lw	a1,0(v0)
80005b38:	8c440004 	lw	a0,4(v0)
80005b3c:	8c420008 	lw	v0,8(v0)
80005b40:	ac650000 	sw	a1,0(v1)
80005b44:	ac640004 	sw	a0,4(v1)
80005b48:	ac620008 	sw	v0,8(v1)
80005b4c:	8e050000 	lw	a1,0(s0)
80005b50:	8e060004 	lw	a2,4(s0)
80005b54:	8e070008 	lw	a3,8(s0)
80005b58:	0c00157a 	jal	800055e8 <prnFlashInfo>
80005b5c:	02402021 	move	a0,s2
	ui = spi_flash_info[ucChip].pfRead(ucChip, 0x00, 4, pucBuffer);
80005b60:	001218c0 	sll	v1,s2,0x3
80005b64:	00121180 	sll	v0,s2,0x6
80005b68:	00621821 	addu	v1,v1,v0
80005b6c:	3c028001 	lui	v0,0x8001
80005b70:	24425218 	addiu	v0,v0,21016
80005b74:	00431021 	addu	v0,v0,v1
80005b78:	8c42003c 	lw	v0,60(v0)
80005b7c:	02402021 	move	a0,s2
80005b80:	00002821 	move	a1,zero
80005b84:	24060004 	li	a2,4
80005b88:	0040f809 	jalr	v0
80005b8c:	27a70050 	addiu	a3,sp,80
	LDEBUG("spi_regist: ucChip=%x; i=%x; uiCount=%x\n", ucChip, i, uiCount);
}
80005b90:	8fbf0064 	lw	ra,100(sp)
80005b94:	8fb20060 	lw	s2,96(sp)
80005b98:	8fb1005c 	lw	s1,92(sp)
80005b9c:	8fb00058 	lw	s0,88(sp)
80005ba0:	03e00008 	jr	ra
80005ba4:	27bd0068 	addiu	sp,sp,104

80005ba8 <spiFlashReady>:
	ucDispCount++;
}
*/
// Check WIP bit
unsigned int spiFlashReady(unsigned char ucChip)
{
80005ba8:	27bdffe0 	addiu	sp,sp,-32
80005bac:	afbf001c 	sw	ra,28(sp)
80005bb0:	afb10018 	sw	s1,24(sp)
80005bb4:	afb00014 	sw	s0,20(sp)
80005bb8:	309100ff 	andi	s1,a0,0xff
	unsigned int uiCount, ui;	
	uiCount = 0;
delay_ms(1);
80005bbc:	0c001bb5 	jal	80006ed4 <delay_ms>
80005bc0:	24040001 	li	a0,1
80005bc4:	00008021 	move	s0,zero
	while (1)
	{
		uiCount++;
80005bc8:	26100001 	addiu	s0,s0,1
		ui = SeqCmd_Read(ucChip, IOWIDTH_SINGLE, SPICMD_RDSR, 1);
80005bcc:	02202021 	move	a0,s1
80005bd0:	00002821 	move	a1,zero
80005bd4:	3c060500 	lui	a2,0x500
80005bd8:	0c001378 	jal	80004de0 <SeqCmd_Read>
80005bdc:	24070001 	li	a3,1
		if ((ui & (1 << SPI_STATUS_WIP)) == 0)
80005be0:	30420001 	andi	v0,v0,0x1
80005be4:	1440fff8 	bnez	v0,80005bc8 <spiFlashReady+0x20>
80005be8:	02001021 	move	v0,s0
			break;
		}
	}
	KDEBUG("spiFlashReady: uiCount=%x\n", uiCount);	
	return uiCount;
}
80005bec:	8fbf001c 	lw	ra,28(sp)
80005bf0:	8fb10018 	lw	s1,24(sp)
80005bf4:	8fb00014 	lw	s0,20(sp)
80005bf8:	03e00008 	jr	ra
80005bfc:	27bd0020 	addiu	sp,sp,32

80005c00 <ComSrlCmd_ComWrite>:
	return uiLen;
	
}
// write template
unsigned int ComSrlCmd_ComWrite(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer, unsigned int uiCmd, unsigned char ucIsFast, unsigned char ucIOWidth, unsigned char ucDummyCount)
{
80005c00:	27bdffc0 	addiu	sp,sp,-64
80005c04:	afbf003c 	sw	ra,60(sp)
80005c08:	afb60038 	sw	s6,56(sp)
80005c0c:	afb50034 	sw	s5,52(sp)
80005c10:	afb40030 	sw	s4,48(sp)
80005c14:	afb3002c 	sw	s3,44(sp)
80005c18:	afb20028 	sw	s2,40(sp)
80005c1c:	afb10024 	sw	s1,36(sp)
80005c20:	afb00020 	sw	s0,32(sp)
80005c24:	00a08021 	move	s0,a1
80005c28:	00c09821 	move	s3,a2
80005c2c:	00e09021 	move	s2,a3
80005c30:	93b40057 	lbu	s4,87(sp)
80005c34:	93b5005b 	lbu	s5,91(sp)
80005c38:	93b6005f 	lbu	s6,95(sp)
	unsigned int ui, uiCount, i;
	unsigned char* puc = pucBuffer;
	LDEBUG("ComSrlCmd_ComWrite: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; uiCmd=%x; uiIsfast=%x; ucIOWidth=%x; ucDummyCount=%x\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
80005c3c:	309100ff 	andi	s1,a0,0xff
80005c40:	02202021 	move	a0,s1
80005c44:	00002821 	move	a1,zero
80005c48:	0c001322 	jal	80004c88 <SeqCmd_Order>
80005c4c:	3c060600 	lui	a2,0x600

	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);
80005c50:	afb50010 	sw	s5,16(sp)
80005c54:	afb60014 	sw	s6,20(sp)
80005c58:	02202021 	move	a0,s1
80005c5c:	02002821 	move	a1,s0
80005c60:	8fa60050 	lw	a2,80(sp)
80005c64:	0c0013a8 	jal	80004ea0 <ComSrlCmd_InputCommand>
80005c68:	02803821 	move	a3,s4

	uiCount = uiLen / 4;
80005c6c:	00134082 	srl	t0,s3,0x2
	for (i = 0; i <  uiCount; i++)
80005c70:	11000016 	beqz	t0,80005ccc <ComSrlCmd_ComWrite+0xcc>
80005c74:	02402821 	move	a1,s2
80005c78:	02403021 	move	a2,s2
80005c7c:	00003821 	move	a3,zero
	{
		memcpy(&ui, puc, 4);
		puc += 4;
		SPI_REG_LOAD(SFDR, ui);
80005c80:	3c05b800 	lui	a1,0xb800
80005c84:	34a41208 	ori	a0,a1,0x1208
80005c88:	3c030800 	lui	v1,0x800
80005c8c:	34a5120c 	ori	a1,a1,0x120c
	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);

	uiCount = uiLen / 4;
	for (i = 0; i <  uiCount; i++)
	{
		memcpy(&ui, puc, 4);
80005c90:	88c20000 	lwl	v0,0(a2)
80005c94:	98c20003 	lwr	v0,3(a2)
80005c98:	afa20018 	sw	v0,24(sp)
		puc += 4;
80005c9c:	24c60004 	addiu	a2,a2,4
		SPI_REG_LOAD(SFDR, ui);
80005ca0:	8c820000 	lw	v0,0(a0)
80005ca4:	00431024 	and	v0,v0,v1
80005ca8:	1040fffd 	beqz	v0,80005ca0 <ComSrlCmd_ComWrite+0xa0>
80005cac:	8fa20018 	lw	v0,24(sp)
80005cb0:	aca20000 	sw	v0,0(a1)
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);

	ComSrlCmd_InputCommand(ucChip, uiAddr, uiCmd, ucIsFast, ucIOWidth, ucDummyCount);

	uiCount = uiLen / 4;
	for (i = 0; i <  uiCount; i++)
80005cb4:	24e70001 	addiu	a3,a3,1
80005cb8:	00e8102b 	sltu	v0,a3,t0
80005cbc:	1440fff4 	bnez	v0,80005c90 <ComSrlCmd_ComWrite+0x90>
80005cc0:	00000000 	nop
80005cc4:	00082880 	sll	a1,t0,0x2
80005cc8:	02452821 	addu	a1,s2,a1
		memcpy(&ui, puc, 4);
		puc += 4;
		SPI_REG_LOAD(SFDR, ui);
	}

	i = uiLen % 4;
80005ccc:	32700003 	andi	s0,s3,0x3
	if(i > 0)
80005cd0:	12000014 	beqz	s0,80005d24 <ComSrlCmd_ComWrite+0x124>
80005cd4:	02202021 	move	a0,s1
	{
		memcpy(&ui, puc, i);
80005cd8:	27a40018 	addiu	a0,sp,24
80005cdc:	0c0019e2 	jal	80006788 <memcpy>
80005ce0:	02003021 	move	a2,s0
		puc += i;
		SFCSR_CS_L(ucChip, i-1, ucIOWidth);
80005ce4:	2605ffff 	addiu	a1,s0,-1
80005ce8:	02202021 	move	a0,s1
80005cec:	30a500ff 	andi	a1,a1,0xff
80005cf0:	0c0012f8 	jal	80004be0 <SFCSR_CS_L>
80005cf4:	02a03021 	move	a2,s5
		SPI_REG_LOAD(SFDR, ui);
80005cf8:	3c04b800 	lui	a0,0xb800
80005cfc:	34841208 	ori	a0,a0,0x1208
80005d00:	3c030800 	lui	v1,0x800
80005d04:	8c820000 	lw	v0,0(a0)
80005d08:	00431024 	and	v0,v0,v1
80005d0c:	1040fffd 	beqz	v0,80005d04 <ComSrlCmd_ComWrite+0x104>
80005d10:	3c02b800 	lui	v0,0xb800
80005d14:	3442120c 	ori	v0,v0,0x120c
80005d18:	8fa30018 	lw	v1,24(sp)
80005d1c:	ac430000 	sw	v1,0(v0)
	}
	SFCSR_CS_H(ucChip, 0, IOWIDTH_SINGLE);
80005d20:	02202021 	move	a0,s1
80005d24:	00002821 	move	a1,zero
80005d28:	0c00130e 	jal	80004c38 <SFCSR_CS_H>
80005d2c:	00003021 	move	a2,zero
	ui = spiFlashReady(ucChip);
80005d30:	0c0016ea 	jal	80005ba8 <spiFlashReady>
80005d34:	02202021 	move	a0,s1
	return uiLen;
}
80005d38:	02601021 	move	v0,s3
80005d3c:	8fbf003c 	lw	ra,60(sp)
80005d40:	8fb60038 	lw	s6,56(sp)
80005d44:	8fb50034 	lw	s5,52(sp)
80005d48:	8fb40030 	lw	s4,48(sp)
80005d4c:	8fb3002c 	lw	s3,44(sp)
80005d50:	8fb20028 	lw	s2,40(sp)
80005d54:	8fb10024 	lw	s1,36(sp)
80005d58:	8fb00020 	lw	s0,32(sp)
80005d5c:	03e00008 	jr	ra
80005d60:	27bd0040 	addiu	sp,sp,64

80005d64 <mxic_cmd_write_s1>:
	return ComSrlCmd_ComRead(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_4READ, ISFAST_YES, IOWIDTH_QUAD, DUMMYCOUNT_3);
}
#endif
// Page Program (PP) Sequence (Command 02)
unsigned int mxic_cmd_write_s1(unsigned char ucChip, unsigned int uiAddr, unsigned int uiLen, unsigned char* pucBuffer)
{
80005d64:	27bdffd8 	addiu	sp,sp,-40
80005d68:	afbf0024 	sw	ra,36(sp)
	KDEBUG("mxic_cmd_write_s1: ucChip=%x; uiAddr=%x; uiLen=%x; pucBuffer=%x; SPICMD_PP=%x;\n", ucChip, uiAddr, uiLen, (unsigned int)pucBuffer, SPICMD_PP);
	return ComSrlCmd_ComWrite(ucChip, uiAddr, uiLen, pucBuffer, SPICMD_PP, ISFAST_NO, IOWIDTH_SINGLE, DUMMYCOUNT_0);
80005d6c:	3c020200 	lui	v0,0x200
80005d70:	afa20010 	sw	v0,16(sp)
80005d74:	afa00014 	sw	zero,20(sp)
80005d78:	afa00018 	sw	zero,24(sp)
80005d7c:	afa0001c 	sw	zero,28(sp)
80005d80:	0c001700 	jal	80005c00 <ComSrlCmd_ComWrite>
80005d84:	308400ff 	andi	a0,a0,0xff
}
80005d88:	8fbf0024 	lw	ra,36(sp)
80005d8c:	03e00008 	jr	ra
80005d90:	27bd0028 	addiu	sp,sp,40

80005d94 <ComSrlCmd_CE>:
	KDEBUG("ComSrlCmd_BE: ucChip=%x; uiBlock=%x; uiBlockSize=%x; SPICMD_BE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].block_size, SPICMD_BE);
	return spiFlashReady(ucChip);
}
// Chip Erase (CE) Sequence (Command 60 or C7)
unsigned int ComSrlCmd_CE(unsigned char ucChip)
{
80005d94:	27bdffe8 	addiu	sp,sp,-24
80005d98:	afbf0014 	sw	ra,20(sp)
80005d9c:	afb00010 	sw	s0,16(sp)
80005da0:	309000ff 	andi	s0,a0,0xff
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
80005da4:	02002021 	move	a0,s0
80005da8:	00002821 	move	a1,zero
80005dac:	0c001322 	jal	80004c88 <SeqCmd_Order>
80005db0:	3c060600 	lui	a2,0x600
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_CE);	
80005db4:	02002021 	move	a0,s0
80005db8:	00002821 	move	a1,zero
80005dbc:	0c001322 	jal	80004c88 <SeqCmd_Order>
80005dc0:	3c066000 	lui	a2,0x6000
	KDEBUG("ComSrlCmd_CE: ucChip=%x; SPICMD_CE=%x\n", ucChip, SPICMD_CE);
	return spiFlashReady(ucChip);
80005dc4:	0c0016ea 	jal	80005ba8 <spiFlashReady>
80005dc8:	02002021 	move	a0,s0
}
80005dcc:	8fbf0014 	lw	ra,20(sp)
80005dd0:	8fb00010 	lw	s0,16(sp)
80005dd4:	03e00008 	jr	ra
80005dd8:	27bd0018 	addiu	sp,sp,24

80005ddc <ComSrlCmd_BE>:
	KDEBUG("ComSrlCmd_SE: ucChip=%x; uiSector=%x; uiSectorSize=%x; SPICMD_SE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].sector_size, SPICMD_SE);	
	return spiFlashReady(ucChip);
}
// Block Erase (BE) Sequence (Command D8)
unsigned int ComSrlCmd_BE(unsigned char ucChip, unsigned int uiAddr)
{
80005ddc:	27bdffd8 	addiu	sp,sp,-40
80005de0:	afbf0024 	sw	ra,36(sp)
80005de4:	afb10020 	sw	s1,32(sp)
80005de8:	afb0001c 	sw	s0,28(sp)
80005dec:	00a08821 	move	s1,a1
80005df0:	309000ff 	andi	s0,a0,0xff
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
80005df4:	02002021 	move	a0,s0
80005df8:	00002821 	move	a1,zero
80005dfc:	0c001322 	jal	80004c88 <SeqCmd_Order>
80005e00:	3c060600 	lui	a2,0x600
		
		if(REG32(0xb8000008)&0x1)
80005e04:	3c02b800 	lui	v0,0xb800
80005e08:	34420008 	ori	v0,v0,0x8
80005e0c:	8c420000 	lw	v0,0(v0)
80005e10:	30420001 	andi	v0,v0,0x1
80005e14:	1040000a 	beqz	v0,80005e40 <ComSrlCmd_BE+0x64>
80005e18:	24020003 	li	v0,3
			SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_BE, uiAddr, 4);//JSW:For 4-byte addressing 	
80005e1c:	24020004 	li	v0,4
80005e20:	afa20010 	sw	v0,16(sp)
80005e24:	02002021 	move	a0,s0
80005e28:	00002821 	move	a1,zero
80005e2c:	3c06d800 	lui	a2,0xd800
80005e30:	0c001341 	jal	80004d04 <SeqCmd_Write>
80005e34:	02203821 	move	a3,s1
80005e38:	08001796 	j	80005e58 <ComSrlCmd_BE+0x7c>
80005e3c:	00000000 	nop
		else
			SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_BE, uiAddr, 3);//JSW:For 3to4-byte addressing 
80005e40:	afa20010 	sw	v0,16(sp)
80005e44:	02002021 	move	a0,s0
80005e48:	00002821 	move	a1,zero
80005e4c:	3c06d800 	lui	a2,0xd800
80005e50:	0c001341 	jal	80004d04 <SeqCmd_Write>
80005e54:	02203821 	move	a3,s1
	
	KDEBUG("ComSrlCmd_BE: ucChip=%x; uiBlock=%x; uiBlockSize=%x; SPICMD_BE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].block_size, SPICMD_BE);
	return spiFlashReady(ucChip);
80005e58:	0c0016ea 	jal	80005ba8 <spiFlashReady>
80005e5c:	02002021 	move	a0,s0
}
80005e60:	8fbf0024 	lw	ra,36(sp)
80005e64:	8fb10020 	lw	s1,32(sp)
80005e68:	8fb0001c 	lw	s0,28(sp)
80005e6c:	03e00008 	jr	ra
80005e70:	27bd0028 	addiu	sp,sp,40

80005e74 <ComSrlCmd_SE>:
}

/****************************** Layer 2 ******************************/
// Sector Erase (SE) Sequence (Command 20)
unsigned int ComSrlCmd_SE(unsigned char ucChip, unsigned int uiAddr)
{
80005e74:	27bdffd8 	addiu	sp,sp,-40
80005e78:	afbf0024 	sw	ra,36(sp)
80005e7c:	afb10020 	sw	s1,32(sp)
80005e80:	afb0001c 	sw	s0,28(sp)
80005e84:	00a08821 	move	s1,a1
80005e88:	309000ff 	andi	s0,a0,0xff
	SeqCmd_Order(ucChip,  IOWIDTH_SINGLE, SPICMD_WREN);
80005e8c:	02002021 	move	a0,s0
80005e90:	00002821 	move	a1,zero
80005e94:	0c001322 	jal	80004c88 <SeqCmd_Order>
80005e98:	3c060600 	lui	a2,0x600

			
	if(REG32(0xb8000008)&0x1)
80005e9c:	3c02b800 	lui	v0,0xb800
80005ea0:	34420008 	ori	v0,v0,0x8
80005ea4:	8c420000 	lw	v0,0(v0)
80005ea8:	30420001 	andi	v0,v0,0x1
80005eac:	1040000a 	beqz	v0,80005ed8 <ComSrlCmd_SE+0x64>
80005eb0:	24020003 	li	v0,3
		SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_SE, uiAddr, 4);//JSW:For 4-byte addressing 	
80005eb4:	24020004 	li	v0,4
80005eb8:	afa20010 	sw	v0,16(sp)
80005ebc:	02002021 	move	a0,s0
80005ec0:	00002821 	move	a1,zero
80005ec4:	3c062000 	lui	a2,0x2000
80005ec8:	0c001341 	jal	80004d04 <SeqCmd_Write>
80005ecc:	02203821 	move	a3,s1
80005ed0:	080017bc 	j	80005ef0 <ComSrlCmd_SE+0x7c>
80005ed4:	00000000 	nop
	else
		SeqCmd_Write(ucChip,  IOWIDTH_SINGLE, SPICMD_SE, uiAddr, 3);//JSW:For 3to4-byte addressing 
80005ed8:	afa20010 	sw	v0,16(sp)
80005edc:	02002021 	move	a0,s0
80005ee0:	00002821 	move	a1,zero
80005ee4:	3c062000 	lui	a2,0x2000
80005ee8:	0c001341 	jal	80004d04 <SeqCmd_Write>
80005eec:	02203821 	move	a3,s1
	
	//KDEBUG("ComSrlCmd_SE: ucChip=%x; uiSector=%x; uiSectorSize=%x; SPICMD_SE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].sector_size, SPICMD_SE);	
	KDEBUG("ComSrlCmd_SE: ucChip=%x; uiSector=%x; uiSectorSize=%x; SPICMD_SE=%x\n", ucChip, uiAddr, spi_flash_info[ucChip].sector_size, SPICMD_SE);	
	return spiFlashReady(ucChip);
80005ef0:	0c0016ea 	jal	80005ba8 <spiFlashReady>
80005ef4:	02002021 	move	a0,s0
}
80005ef8:	8fbf0024 	lw	ra,36(sp)
80005efc:	8fb10020 	lw	s1,32(sp)
80005f00:	8fb0001c 	lw	s0,28(sp)
80005f04:	03e00008 	jr	ra
80005f08:	27bd0028 	addiu	sp,sp,40
80005f0c:	00000000 	nop

80005f10 <init_icache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29,t, 0);  //CP0_ITagHi
80005f10:	00001021 	move	v0,zero
80005f14:	00424825 	or	t1,v0,v0
80005f18:	4089e800 	mtc0	t1,c0_taghi
80005f1c:	00000040 	ssnop
80005f20:	00000040 	ssnop
80005f24:	00000040 	ssnop
80005f28:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28,t, 0);  //CP0_ITagLo
80005f2c:	00424825 	or	t1,v0,v0
80005f30:	4089e000 	mtc0	t1,c0_taglo
80005f34:	00000040 	ssnop
80005f38:	00000040 	ssnop
80005f3c:	00000040 	ssnop
80005f40:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
80005f44:	3c028000 	lui	v0,0x8000
80005f48:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
80005f4c:	3c048000 	lui	a0,0x8000
80005f50:	3483ffe0 	ori	v1,a0,0xffe0
			break;
		addr += lsize;
80005f54:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(64<<10)-lsize;   //DCACHE=64K

	while (1) 
	{
		cache_op(Index_Store_Tag_I, addr);
80005f58:	bc480000 	cache	0x8,0(v0)
		if (addr >= aend)
80005f5c:	1443fffe 	bne	v0,v1,80005f58 <init_icache+0x48>
80005f60:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
80005f64:	03e00008 	jr	ra
80005f68:	00000000 	nop

80005f6c <init_dcache>:
	#define KSEG0BASE                 0x80000000
	#define CONFIG_SYS_CACHELINE_SIZE 32

	unsigned int t;
	t=0;
	write_32bit_cp0_register_sel( 29, t, 2);  //CP0_DTagHi
80005f6c:	00001021 	move	v0,zero
80005f70:	00424825 	or	t1,v0,v0
80005f74:	4089e802 	mtc0	t1,c0_taghi1
80005f78:	00000040 	ssnop
80005f7c:	00000040 	ssnop
80005f80:	00000040 	ssnop
80005f84:	00000040 	ssnop
	write_32bit_cp0_register_sel( 28, t, 2);  //CP0_DTagLo
80005f88:	00424825 	or	t1,v0,v0
80005f8c:	4089e002 	mtc0	t1,c0_taglo1
80005f90:	00000040 	ssnop
80005f94:	00000040 	ssnop
80005f98:	00000040 	ssnop
80005f9c:	00000040 	ssnop
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
80005fa0:	3c028000 	lui	v0,0x8000
80005fa4:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
80005fa8:	3c048000 	lui	a0,0x8000
80005fac:	34837fe0 	ori	v1,a0,0x7fe0
			break;
		addr += lsize;
80005fb0:	24420020 	addiu	v0,v0,32
	unsigned long addr = KSEG0BASE;
	unsigned long aend = addr+(32<<10)-lsize;   //DCACHE=32K

	while (1) 
	{
		cache_op(Index_Store_Tag_D, addr);
80005fb4:	bc490000 	cache	0x9,0(v0)
		if (addr >= aend)
80005fb8:	1443fffe 	bne	v0,v1,80005fb4 <init_dcache+0x48>
80005fbc:	24420020 	addiu	v0,v0,32
			break;
		addr += lsize;
	}

}
80005fc0:	03e00008 	jr	ra
80005fc4:	00000000 	nop

80005fc8 <enable_flash_mapping>:
//============================================================================
enable_flash_mapping()
{
	REG32(0xb8001000)&=~(1<<18);
80005fc8:	3c02b800 	lui	v0,0xb800
80005fcc:	34421000 	ori	v0,v0,0x1000
80005fd0:	8c440000 	lw	a0,0(v0)
80005fd4:	3c03fffb 	lui	v1,0xfffb
80005fd8:	3463ffff 	ori	v1,v1,0xffff
80005fdc:	00831824 	and	v1,a0,v1
80005fe0:	ac430000 	sw	v1,0(v0)
}
80005fe4:	03e00008 	jr	ra
80005fe8:	00000000 	nop

80005fec <init_cpu_config>:
init_cpu_config()
{
	unsigned int s;
#if 1	
	//setting K23, KU, MM
	s = read_32bit_cp0_register(CP0_CONFIG);
80005fec:	40038000 	mfc0	v1,c0_config
	s &= ~((3<<28) | (3<<25) | (1<<18));
80005ff0:	3c02c9fb 	lui	v0,0xc9fb
80005ff4:	3442ffff 	ori	v0,v0,0xffff
80005ff8:	00621024 	and	v0,v1,v0
	s |=  ((3<<28) | (3<<25) | (1<<18));
	write_32bit_cp0_register(CP0_CONFIG, s);
80005ffc:	3c033604 	lui	v1,0x3604
80006000:	00431025 	or	v0,v0,v1
80006004:	40828000 	mtc0	v0,c0_config
80006008:	00000040 	ssnop
8000600c:	00000040 	ssnop
80006010:	00000040 	ssnop
80006014:	00000040 	ssnop
	//set_cp0_config(0x07, 2); //2:uncache
	//set_cp0_config(0x07, 3); //3:cache
#endif

	
	s = read_32bit_cp0_register(CP0_STATUS);
80006018:	40036000 	mfc0	v1,c0_status
	s &= ~(ST0_CU1|ST0_CU2|ST0_CU3);
8000601c:	3c021fff 	lui	v0,0x1fff
80006020:	3442ffff 	ori	v0,v0,0xffff
80006024:	00621024 	and	v0,v1,v0
	s |= ST0_CU0;
	write_32bit_cp0_register(CP0_STATUS, s);
80006028:	3c031000 	lui	v1,0x1000
8000602c:	00431025 	or	v0,v0,v1
80006030:	40826000 	mtc0	v0,c0_status
80006034:	00000040 	ssnop
80006038:	00000040 	ssnop
8000603c:	00000040 	ssnop
80006040:	00000040 	ssnop
80006044:	000000c0 	ehb
#endif
	

//	sys_init_icache();
//	sys_init_dcache();	
}
80006048:	03e00008 	jr	ra
8000604c:	00000000 	nop

80006050 <enable_GIC_mapping>:
//============================================================================

enable_GIC_mapping()
{
	//setting GIC base
	REG32(GCR_BASE_ADDR+0x0080)=Virtual2Physical(GIC_BASE_ADDR)|0x01;
80006050:	3c02bfbf 	lui	v0,0xbfbf
80006054:	34438080 	ori	v1,v0,0x8080
80006058:	3c041bdc 	lui	a0,0x1bdc
8000605c:	34840001 	ori	a0,a0,0x1
80006060:	ac640000 	sw	a0,0(v1)

	REG32(GCR_BASE_ADDR+0x0088)=Virtual2Physical(CPC_BASE_ADDR)|0x01;
80006064:	34428088 	ori	v0,v0,0x8088
80006068:	3c031bde 	lui	v1,0x1bde
8000606c:	34630001 	ori	v1,v1,0x1
80006070:	ac430000 	sw	v1,0(v0)


	//IP inverter
	REG32(GIC_BASE_ADDR+0x100)=0xffffffff;
80006074:	3c02bbdc 	lui	v0,0xbbdc
80006078:	34430100 	ori	v1,v0,0x100
8000607c:	2404ffff 	li	a0,-1
80006080:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x104)=0x0003FFFF;	
80006084:	34420104 	ori	v0,v0,0x104
80006088:	3c030003 	lui	v1,0x3
8000608c:	3463ffff 	ori	v1,v1,0xffff
80006090:	ac430000 	sw	v1,0(v0)
	//map2pin
	//REG32(GIC_BASE_ADDR+0x500)=0x80000000;

	//map2vpe
	//REG32(GIC_BASE_ADDR+0x2000)=0x1;
}
80006094:	03e00008 	jr	ra
80006098:	00000000 	nop

8000609c <init_arch>:

//============================================================================
	
asmlinkage void init_arch(int argc, char **argv, char **envp, int *prom_vec)
{
8000609c:	27bdffe8 	addiu	sp,sp,-24
800060a0:	afbf0014 	sw	ra,20(sp)
	//init_icache();
	//init_icache();		
	
	enable_flash_mapping();	
800060a4:	0c0017f2 	jal	80005fc8 <enable_flash_mapping>
800060a8:	00000000 	nop
	init_cpu_config();	
800060ac:	0c0017fb 	jal	80005fec <init_cpu_config>
800060b0:	00000000 	nop
	enable_GIC_mapping();
800060b4:	0c001814 	jal	80006050 <enable_GIC_mapping>
800060b8:	00000000 	nop
#ifdef CONFIG_NAND_FLASH_BOOTING
	jmp=((int)start_kernel); //jump to un cache address
#else
	jmp=((int)start_kernel)& ~UNCACHE_MASK;
#endif
	jmp();
800060bc:	3c03dfff 	lui	v1,0xdfff
800060c0:	3463ffff 	ori	v1,v1,0xffff
800060c4:	3c028000 	lui	v0,0x8000
800060c8:	24426328 	addiu	v0,v0,25384
800060cc:	00431024 	and	v0,v0,v1
800060d0:	0040f809 	jalr	v0
800060d4:	00000000 	nop
}
800060d8:	8fbf0014 	lw	ra,20(sp)
800060dc:	03e00008 	jr	ra
800060e0:	27bd0018 	addiu	sp,sp,24
	...

800060f0 <flush_dcache_range>:
//==============================================================================
void flush_dcache_range(ulong start_addr, ulong stop)
{
#ifndef CONFIG_NAND_FLASH_BOOTING
	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
	unsigned long addr = start_addr & ~(lsize - 1);
800060f0:	2402ffe0 	li	v0,-32
800060f4:	00822024 	and	a0,a0,v0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
800060f8:	24a5ffff 	addiu	a1,a1,-1
800060fc:	00a21024 	and	v0,a1,v0

	while (1) 
	{
		cache_op(Hit_Writeback_Inv_D, addr);
80006100:	bc950000 	cache	0x15,0(a0)
		if (addr == aend)
80006104:	10820004 	beq	a0,v0,80006118 <flush_dcache_range+0x28>
80006108:	24840020 	addiu	a0,a0,32
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (stop - 1) & ~(lsize - 1);

	while (1) 
	{
		cache_op(Hit_Writeback_Inv_D, addr);
8000610c:	bc950000 	cache	0x15,0(a0)
		if (addr == aend)
80006110:	1444fffe 	bne	v0,a0,8000610c <flush_dcache_range+0x1c>
80006114:	24840020 	addiu	a0,a0,32
80006118:	03e00008 	jr	ra
8000611c:	00000000 	nop

80006120 <flush_cache_range>:
	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);

	/* aend will be miscalculated when size is zero, so we return here */
	if (size == 0)
80006120:	10a0000d 	beqz	a1,80006158 <flush_cache_range+0x38>
80006124:	2403ffe0 	li	v1,-32
//==============================================================================
void flush_cache_range(ulong start_addr, ulong size)
{
#ifndef CONFIG_NAND_FLASH_BOOTING
	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
	unsigned long addr = start_addr & ~(lsize - 1);
80006128:	00831024 	and	v0,a0,v1
	unsigned long aend = (start_addr + size - 1) & ~(lsize - 1);
8000612c:	2484ffff 	addiu	a0,a0,-1
80006130:	00852021 	addu	a0,a0,a1
80006134:	00832024 	and	a0,a0,v1
	if (size == 0)
		return;

	while (1) 
	{
		cache_op(Hit_Writeback_Inv_D, addr);
80006138:	bc550000 	cache	0x15,0(v0)
		cache_op(Hit_Invalidate_I, addr);
8000613c:	bc500000 	cache	0x10,0(v0)
		if (addr == aend)
80006140:	10440005 	beq	v0,a0,80006158 <flush_cache_range+0x38>
80006144:	24420020 	addiu	v0,v0,32
	if (size == 0)
		return;

	while (1) 
	{
		cache_op(Hit_Writeback_Inv_D, addr);
80006148:	bc550000 	cache	0x15,0(v0)
		cache_op(Hit_Invalidate_I, addr);
8000614c:	bc500000 	cache	0x10,0(v0)
		if (addr == aend)
80006150:	1482fffd 	bne	a0,v0,80006148 <flush_cache_range+0x28>
80006154:	24420020 	addiu	v0,v0,32
80006158:	03e00008 	jr	ra
8000615c:	00000000 	nop

80006160 <invalidate_dcache_range>:
//==============================================================================
void invalidate_dcache_range(ulong start_addr, ulong stop)
{
#ifndef CONFIG_NAND_FLASH_BOOTING
	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
	unsigned long addr = start_addr & ~(lsize - 1);
80006160:	2402ffe0 	li	v0,-32
80006164:	00822024 	and	a0,a0,v0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
80006168:	24a5ffff 	addiu	a1,a1,-1
8000616c:	00a21024 	and	v0,a1,v0

	while (1) 
	{
		cache_op(Hit_Invalidate_D, addr);
80006170:	bc910000 	cache	0x11,0(a0)
		if (addr == aend)
80006174:	10820004 	beq	a0,v0,80006188 <invalidate_dcache_range+0x28>
80006178:	24840020 	addiu	a0,a0,32
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (stop - 1) & ~(lsize - 1);

	while (1) 
	{
		cache_op(Hit_Invalidate_D, addr);
8000617c:	bc910000 	cache	0x11,0(a0)
		if (addr == aend)
80006180:	1444fffe 	bne	v0,a0,8000617c <invalidate_dcache_range+0x1c>
80006184:	24840020 	addiu	a0,a0,32
80006188:	03e00008 	jr	ra
8000618c:	00000000 	nop

80006190 <invalidate_icache_range>:
//==============================================================================
void invalidate_icache_range(ulong start_addr, ulong stop)  //wei add
{
#ifndef CONFIG_NAND_FLASH_BOOTING
	unsigned long lsize = CONFIG_SYS_CACHELINE_SIZE;
	unsigned long addr = start_addr & ~(lsize - 1);
80006190:	2402ffe0 	li	v0,-32
80006194:	00822024 	and	a0,a0,v0
	unsigned long aend = (stop - 1) & ~(lsize - 1);
80006198:	24a5ffff 	addiu	a1,a1,-1
8000619c:	00a21024 	and	v0,a1,v0

	while (1) 
	{
		cache_op(Hit_Invalidate_I, addr);
800061a0:	bc900000 	cache	0x10,0(a0)
		if (addr == aend)
800061a4:	10820004 	beq	a0,v0,800061b8 <invalidate_icache_range+0x28>
800061a8:	24840020 	addiu	a0,a0,32
	unsigned long addr = start_addr & ~(lsize - 1);
	unsigned long aend = (stop - 1) & ~(lsize - 1);

	while (1) 
	{
		cache_op(Hit_Invalidate_I, addr);
800061ac:	bc900000 	cache	0x10,0(a0)
		if (addr == aend)
800061b0:	1444fffe 	bne	v0,a0,800061ac <invalidate_icache_range+0x1c>
800061b4:	24840020 	addiu	a0,a0,32
800061b8:	03e00008 	jr	ra
800061bc:	00000000 	nop

800061c0 <invalidate_cache>:
	//winfred_wang
	invalidate_cache();
}
//==============================================================================
void invalidate_cache(void)   //wei add
{
800061c0:	27bdffe8 	addiu	sp,sp,-24
800061c4:	afbf0014 	sw	ra,20(sp)
#ifndef CONFIG_NAND_FLASH_BOOTING
	#define START_ADDR 0x80000000
	invalidate_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
800061c8:	3c048000 	lui	a0,0x8000
800061cc:	3c058000 	lui	a1,0x8000
800061d0:	0c001858 	jal	80006160 <invalidate_dcache_range>
800061d4:	34a58000 	ori	a1,a1,0x8000
	invalidate_icache_range(START_ADDR, START_ADDR+_ICACHE_SIZE);	
800061d8:	3c048000 	lui	a0,0x8000
800061dc:	0c001864 	jal	80006190 <invalidate_icache_range>
800061e0:	3c058001 	lui	a1,0x8001
#endif
}
800061e4:	8fbf0014 	lw	ra,20(sp)
800061e8:	03e00008 	jr	ra
800061ec:	27bd0018 	addiu	sp,sp,24

800061f0 <flush_cache>:
	}
#endif
}
//==============================================================================
void flush_cache(void)   //wei add
{
800061f0:	27bdffe8 	addiu	sp,sp,-24
800061f4:	afbf0014 	sw	ra,20(sp)
#ifndef CONFIG_NAND_FLASH_BOOTING
	#define START_ADDR 0x80000000
	flush_cache_range(START_ADDR, _DCACHE_SIZE);
800061f8:	3c048000 	lui	a0,0x8000
800061fc:	0c001848 	jal	80006120 <flush_cache_range>
80006200:	34058000 	li	a1,0x8000
	//flush_dcache_range(START_ADDR, START_ADDR+_DCACHE_SIZE);
#endif	
	//winfred_wang
	invalidate_cache();
80006204:	0c001870 	jal	800061c0 <invalidate_cache>
80006208:	00000000 	nop
}
8000620c:	8fbf0014 	lw	ra,20(sp)
80006210:	03e00008 	jr	ra
80006214:	27bd0018 	addiu	sp,sp,24
	...

80006220 <showBoardInfo>:
}

//-------------------------------------------------------
//show board info
void showBoardInfo(void)
{
80006220:	27bdffc8 	addiu	sp,sp,-56
80006224:	afbf0034 	sw	ra,52(sp)
80006228:	afb10030 	sw	s1,48(sp)
8000622c:	afb0002c 	sw	s0,44(sp)
	volatile int cpu_speed = 0;
80006230:	afa00020 	sw	zero,32(sp)
80006234:	40097801 	mfc0	t1,c0_ebase
	int cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
80006238:	01298825 	or	s1,t1,t1
8000623c:	3231003f 	andi	s1,s1,0x3f
#if 1//patch for ESD
        REG32(0xb800311c)=0xa5000000;	
80006240:	3c10b800 	lui	s0,0xb800
80006244:	3602311c 	ori	v0,s0,0x311c
80006248:	3c03a500 	lui	v1,0xa500
8000624c:	ac430000 	sw	v1,0(v0)
#endif
#if 1
	#define SYS_INT_STATUS 0xb8000004
	REG32(SYS_INT_STATUS)=(1<<1);  //clear wakeup interrupt	
80006250:	36020004 	ori	v0,s0,0x4
80006254:	24030002 	li	v1,2
80006258:	ac430000 	sw	v1,0(v0)
	//REG32(0xb8000010)|=0xffff800;
#ifdef CONFIG_NAND_FLASH_BOOTING 
	cpu_speed = check_cpu_speed();	
	cpu_speed = 450 + ((REG32(SYS_HW_STRAP) & 0x78000) >> 15) * 50;
#else
	cpu_speed = check_cpu_speed();	
8000625c:	0c0036fd 	jal	8000dbf4 <check_cpu_speed>
80006260:	ac430000 	sw	v1,0(v0)
80006264:	afa20020 	sw	v0,32(sp)

	#define POLLING_REG 0xb800006c
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
80006268:	36100008 	ori	s0,s0,0x8
8000626c:	8e020000 	lw	v0,0(s0)
80006270:	7c420580 	ext	v0,v0,0x16,0x1
80006274:	14400003 	bnez	v0,80006284 <showBoardInfo+0x64>
80006278:	3c058001 	lui	a1,0x8001
8000627c:	080018a3 	j	8000628c <showBoardInfo+0x6c>
80006280:	24a51e80 	addiu	a1,a1,7808
80006284:	3c058001 	lui	a1,0x8001
80006288:	24a5089c 	addiu	a1,a1,2204
8000628c:	3c048001 	lui	a0,0x8001
80006290:	0c001d43 	jal	8000750c <prom_printf>
80006294:	24840264 	addiu	a0,a0,612
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
80006298:	8fa70020 	lw	a3,32(sp)
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
8000629c:	3c02b800 	lui	v0,0xb800
800062a0:	3442006c 	ori	v0,v0,0x6c
800062a4:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
800062a8:	24023333 	li	v0,13107
800062ac:	14620004 	bne	v1,v0,800062c0 <showBoardInfo+0xa0>
800062b0:	3c02b800 	lui	v0,0xb800
800062b4:	3c038001 	lui	v1,0x8001
800062b8:	080018b9 	j	800062e4 <showBoardInfo+0xc4>
800062bc:	246308c4 	addiu	v1,v1,2244
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	
800062c0:	3442006c 	ori	v0,v0,0x6c
800062c4:	8c430000 	lw	v1,0(v0)
  	#define PATT_SLEEP  0x3333		
  	#define PATT_READY  0x5555
		
	prom_printf("%s",((*(volatile unsigned int *)(0xb8000008)) & (0x1<<22))?"Reboot Result from Watchdog Timeout!\n":" ");
	
	prom_printf("\n---Realtek RTL8198C boot code at %s %s (%dMHz) [C%d running][C%d %s]\n", BOOT_CODE_TIME,B_VERSION,  cpu_speed, cpu_num, 1-cpu_num, 
800062c8:	24025555 	li	v0,21845
800062cc:	10620003 	beq	v1,v0,800062dc <showBoardInfo+0xbc>
800062d0:	3c038001 	lui	v1,0x8001
800062d4:	080018b9 	j	800062e4 <showBoardInfo+0xc4>
800062d8:	246308cc 	addiu	v1,v1,2252
800062dc:	3c038001 	lui	v1,0x8001
800062e0:	246308d4 	addiu	v1,v1,2260
800062e4:	afb10010 	sw	s1,16(sp)
800062e8:	24020001 	li	v0,1
800062ec:	00518823 	subu	s1,v0,s1
800062f0:	afb10014 	sw	s1,20(sp)
800062f4:	afa30018 	sw	v1,24(sp)
800062f8:	3c048001 	lui	a0,0x8001
800062fc:	248408dc 	addiu	a0,a0,2268
80006300:	3c058001 	lui	a1,0x8001
80006304:	24a50924 	addiu	a1,a1,2340
80006308:	3c068001 	lui	a2,0x8001
8000630c:	0c001d43 	jal	8000750c <prom_printf>
80006310:	24c62de0 	addiu	a2,a2,11744
	(REG32(POLLING_REG)==PATT_SLEEP)  ? "sleep": 
	(REG32(POLLING_REG)==PATT_READY)  ? "ready":	"miss"	);	

    //cpu_num=read_32bit_cp0_register_sel(15, 1)&0x3f;
	//prom_printf("cpu id=%x\n",cpu_num);	
}
80006314:	8fbf0034 	lw	ra,52(sp)
80006318:	8fb10030 	lw	s1,48(sp)
8000631c:	8fb0002c 	lw	s0,44(sp)
80006320:	03e00008 	jr	ra
80006324:	27bd0038 	addiu	sp,sp,56

80006328 <start_kernel>:
	return 1;
}
#endif

void start_kernel(void)
{
80006328:	27bdffc8 	addiu	sp,sp,-56
8000632c:	afbf0034 	sw	ra,52(sp)
80006330:	afb10030 	sw	s1,48(sp)
80006334:	afb0002c 	sw	s0,44(sp)

	int ret;

	gCHKKEY_HIT = 0;
80006338:	3c028001 	lui	v0,0x8001
8000633c:	ac404150 	sw	zero,16720(v0)
	gCHKKEY_CNT = 0;
80006340:	3c028001 	lui	v0,0x8001

	IMG_HEADER_T header;
	SETTING_HEADER_T setting_header;

//-------------------------------------------------------
	setClkInitConsole();
80006344:	0c003037 	jal	8000c0dc <setClkInitConsole>
80006348:	ac404154 	sw	zero,16724(v0)

	initHeap();
8000634c:	0c003046 	jal	8000c118 <initHeap>
80006350:	3c118001 	lui	s1,0x8001
		
	initInterrupt();
80006354:	0c0002f0 	jal	80000bc0 <initInterrupt>
80006358:	27b00010 	addiu	s0,sp,16

	initFlash();
8000635c:	0c00303f 	jal	8000c0fc <initFlash>
80006360:	00000000 	nop

#if defined(CONFIG_POST_ENABLE)
	ret = POSTRW_API();
#endif	

	showBoardInfo();
80006364:	0c001888 	jal	80006220 <showBoardInfo>
80006368:	00000000 	nop
	eth_startup(0); 
	sti();			
	tftpd_entry(1);
#endif

	return_addr=0;
8000636c:	ae2031bc 	sw	zero,12732(s1)
	ret=check_image	(&header,&setting_header);
80006370:	02002021 	move	a0,s0
80006374:	0c0031e2 	jal	8000c788 <check_image>
80006378:	27a50020 	addiu	a1,sp,32
	if(REG32(0xb8019004) > MAX_MOUNT_ROOTFS_TIMES){
		REG32(0xb8019004) = 0;
		ret = 0;
	}
#endif
	doBooting(ret, return_addr, &header);
8000637c:	00402021 	move	a0,v0
80006380:	8e2531bc 	lw	a1,12732(s1)
80006384:	0c0030d2 	jal	8000c348 <doBooting>
80006388:	02003021 	move	a2,s0
}
8000638c:	8fbf0034 	lw	ra,52(sp)
80006390:	8fb10030 	lw	s1,48(sp)
80006394:	8fb0002c 	lw	s0,44(sp)
80006398:	03e00008 	jr	ra
8000639c:	27bd0038 	addiu	sp,sp,56

800063a0 <i_alloc>:
        _heapstart is the first byte allocated to the heap.
        _heapend is the last.
*/
{
        /* initialize the allocator */
        frhd = (HEADER *) _heapstart;
800063a0:	3c028001 	lui	v0,0x8001
800063a4:	ac4440b0 	sw	a0,16560(v0)
        frhd->ptr = NULL;
800063a8:	ac800000 	sw	zero,0(a0)
        frhd->size = (_heapend - _heapstart) / sizeof(HEADER);
800063ac:	00a42823 	subu	a1,a1,a0
800063b0:	000528c2 	srl	a1,a1,0x3
800063b4:	ac850004 	sw	a1,4(a0)
        memleft = frhd->size; /* initial size in 4-byte units */
800063b8:	3c028001 	lui	v0,0x8001
}
800063bc:	03e00008 	jr	ra
800063c0:	ac4540b4 	sw	a1,16564(v0)

800063c4 <malloc>:
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
800063c4:	27bdffe8 	addiu	sp,sp,-24
800063c8:	afbf0014 	sw	ra,20(sp)
800063cc:	3c028001 	lui	v0,0x8001
800063d0:	8c4240b0 	lw	v0,16560(v0)
800063d4:	10400027 	beqz	v0,80006474 <malloc+0xb0>
800063d8:	24830007 	addiu	v1,a0,7
void * malloc(uint32 nbytes)                /* bytes to allocate */
{
        HEADER      *nxt, *prev;
        uint32      nunits;

        nunits = (nbytes+sizeof(HEADER)-1)
800063dc:	000318c2 	srl	v1,v1,0x3
800063e0:	24630001 	addiu	v1,v1,1
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
        {
                if (nxt->size >= nunits) /* big enough */
800063e4:	8c440004 	lw	a0,4(v0)
800063e8:	0083282b 	sltu	a1,a0,v1
800063ec:	14a0001e 	bnez	a1,80006468 <malloc+0xa4>
800063f0:	0064202b 	sltu	a0,v1,a0
800063f4:	08001903 	j	8000640c <malloc+0x48>
800063f8:	00000000 	nop
800063fc:	8c440004 	lw	a0,4(v0)
80006400:	0083282b 	sltu	a1,a0,v1
80006404:	14a00018 	bnez	a1,80006468 <malloc+0xa4>
80006408:	0064202b 	sltu	a0,v1,a0
                {
                        if (nxt->size > nunits)
8000640c:	1080000c 	beqz	a0,80006440 <malloc+0x7c>
80006410:	3c048001 	lui	a0,0x8001
                                nxt->size = nunits;
                        }
#else
                        /* allocate head end */
                        {
                                HEADER  *seg = nxt + nunits;
80006414:	000320c0 	sll	a0,v1,0x3
80006418:	00442021 	addu	a0,v0,a0
                                if (prev==NULL) frhd = seg;
8000641c:	3c058001 	lui	a1,0x8001
80006420:	aca440b0 	sw	a0,16560(a1)
                                else prev->ptr = seg;
                                seg->ptr = nxt->ptr;
80006424:	8c450000 	lw	a1,0(v0)
80006428:	ac850000 	sw	a1,0(a0)
                                seg->size = nxt->size - nunits;
8000642c:	8c450004 	lw	a1,4(v0)
80006430:	00a32823 	subu	a1,a1,v1
80006434:	ac850004 	sw	a1,4(a0)
                                
                                /* nxt now == ptr to alloc */
                                nxt->size = nunits;
80006438:	08001912 	j	80006448 <malloc+0x84>
8000643c:	ac430004 	sw	v1,4(v0)
                        }
#endif
                        else
                        {
                                if (prev==NULL) frhd = nxt->ptr;
80006440:	8c450000 	lw	a1,0(v0)
80006444:	ac8540b0 	sw	a1,16560(a0)
                                else prev->ptr = nxt->ptr;
                        }
                        memleft -= nunits;
80006448:	3c048001 	lui	a0,0x8001
8000644c:	8c8540b4 	lw	a1,16564(a0)
80006450:	00a31823 	subu	v1,a1,v1
80006454:	ac8340b4 	sw	v1,16564(a0)
                        */
                }
        }
        printf("\nAllocation Failed!");
        while(1);
}
80006458:	24420008 	addiu	v0,v0,8
8000645c:	8fbf0014 	lw	ra,20(sp)
80006460:	03e00008 	jr	ra
80006464:	27bd0018 	addiu	sp,sp,24
                enough. If block is larger than needed, break                           
                the block into two pieces and allocate the                              
                portion higher up in memory. Otherwise, just
                allocate the entire block.
        */
        for (prev=NULL,nxt=frhd; nxt; nxt = nxt->ptr)
80006468:	8c420000 	lw	v0,0(v0)
8000646c:	1440ffe3 	bnez	v0,800063fc <malloc+0x38>
80006470:	00000000 	nop
                                Return a pointer past the header to                                     
                                the actual space requested.
                        */
                }
        }
        printf("\nAllocation Failed!");
80006474:	3c048001 	lui	a0,0x8001
80006478:	0c001cc1 	jal	80007304 <dprintf>
8000647c:	2484093c 	addiu	a0,a0,2364
80006480:	08001920 	j	80006480 <malloc+0xbc>
80006484:	00000000 	nop

80006488 <free>:
            free() or malloc(), otherwise free list will be null.
*/
{
        HEADER  *nxt, *prev, *f;
        
        ASSERT_CSP(ap);
80006488:	27bdffe8 	addiu	sp,sp,-24
8000648c:	afbf0014 	sw	ra,20(sp)
80006490:	14800006 	bnez	a0,800064ac <free+0x24>
80006494:	3c038001 	lui	v1,0x8001
80006498:	3c048001 	lui	a0,0x8001
8000649c:	0c001cc1 	jal	80007304 <dprintf>
800064a0:	248405bc 	addiu	a0,a0,1468
800064a4:	08001929 	j	800064a4 <free+0x1c>
800064a8:	00000000 	nop
        ASSERT_CSP(frhd);
800064ac:	8c6540b0 	lw	a1,16560(v1)
800064b0:	14a00006 	bnez	a1,800064cc <free+0x44>
800064b4:	3c038001 	lui	v1,0x8001
800064b8:	3c048001 	lui	a0,0x8001
800064bc:	0c001cc1 	jal	80007304 <dprintf>
800064c0:	248405bc 	addiu	a0,a0,1468
800064c4:	08001931 	j	800064c4 <free+0x3c>
800064c8:	00000000 	nop

        f = (HEADER *)ap - 1;
800064cc:	2484fff8 	addiu	a0,a0,-8
        /* pt to header of block being returned */
        memleft += f->size;
800064d0:	8c870004 	lw	a3,4(a0)
800064d4:	8c6640b4 	lw	a2,16564(v1)
800064d8:	00c73021 	addu	a2,a2,a3
800064dc:	ac6640b4 	sw	a2,16564(v1)
        /*
                Note: frhd is never NULL unless i_alloc() was                           
                    never called to initialize package.
        */
        if (frhd > f)
800064e0:	0085182b 	sltu	v1,a0,a1
800064e4:	1460000a 	bnez	v1,80006510 <free+0x88>
800064e8:	00a4182b 	sltu	v1,a1,a0
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
800064ec:	1060002f 	beqz	v1,800065ac <free+0x124>
800064f0:	00000000 	nop
        {
                if (nxt+nxt->size == f)
800064f4:	8ca20004 	lw	v0,4(a1)
800064f8:	000218c0 	sll	v1,v0,0x3
800064fc:	00a31821 	addu	v1,a1,v1
80006500:	14830023 	bne	a0,v1,80006590 <free+0x108>
80006504:	00471021 	addu	v0,v0,a3
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
80006508:	08001959 	j	80006564 <free+0xdc>
8000650c:	aca20004 	sw	v0,4(a1)
        /*
                free queue head is higher up in memory 
                than returnee 
        */
                nxt = frhd;                     /* old head */
                frhd = f;                       /* new head */
80006510:	3c028001 	lui	v0,0x8001
80006514:	ac4440b0 	sw	a0,16560(v0)
                prev = f + f->size;     /* right after new head */

                if (prev==nxt) /* old and new are contiguous */
80006518:	000710c0 	sll	v0,a3,0x3
8000651c:	00821021 	addu	v0,a0,v0
80006520:	14a20007 	bne	a1,v0,80006540 <free+0xb8>
80006524:	00000000 	nop
                {
                        f->size += nxt->size;
80006528:	8ca20004 	lw	v0,4(a1)
8000652c:	00473821 	addu	a3,v0,a3
80006530:	ac870004 	sw	a3,4(a0)
                        f->ptr = nxt->ptr;      /* contiguate */
80006534:	8ca20000 	lw	v0,0(a1)
80006538:	08001978 	j	800065e0 <free+0x158>
8000653c:	ac820000 	sw	v0,0(a0)
                }
                else f->ptr = nxt;
80006540:	08001978 	j	800065e0 <free+0x158>
80006544:	ac850000 	sw	a1,0(a0)
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
        {
                if (nxt+nxt->size == f)
80006548:	8c620004 	lw	v0,4(v1)
8000654c:	000228c0 	sll	a1,v0,0x3
80006550:	00652821 	addu	a1,v1,a1
80006554:	1485000e 	bne	a0,a1,80006590 <free+0x108>
80006558:	00602821 	move	a1,v1
                {
                        /* they are contiguous */
                        nxt->size += f->size;   
8000655c:	00471021 	addu	v0,v0,a3
80006560:	aca20004 	sw	v0,4(a1)
                        /* form one block */
                        f = nxt + nxt->size;
                        if (f==nxt->ptr)
80006564:	8ca30000 	lw	v1,0(a1)
80006568:	000220c0 	sll	a0,v0,0x3
8000656c:	00a42021 	addu	a0,a1,a0
80006570:	1464001c 	bne	v1,a0,800065e4 <free+0x15c>
80006574:	8fbf0014 	lw	ra,20(sp)
                                continue this checking since if the                                     
                                block following this free one was                                               
                                free, the two would have been                                           
                                made one already.
                        */
                                nxt->size += f->size;
80006578:	8c640004 	lw	a0,4(v1)
8000657c:	00441021 	addu	v0,v0,a0
80006580:	aca20004 	sw	v0,4(a1)
                                nxt->ptr = f->ptr;
80006584:	8c620000 	lw	v0,0(v1)
80006588:	08001978 	j	800065e0 <free+0x158>
8000658c:	aca20000 	sw	v0,0(a1)
                points past the block, make a new entry and
                link it.  If next pointer + its size points to the                              
                block form one contiguous block.
        */
        nxt = frhd;
        for (nxt=frhd; nxt && nxt < f; prev=nxt,nxt=nxt->ptr)
80006590:	8ca30000 	lw	v1,0(a1)
80006594:	10600003 	beqz	v1,800065a4 <free+0x11c>
80006598:	0064302b 	sltu	a2,v1,a0
8000659c:	14c0ffea 	bnez	a2,80006548 <free+0xc0>
800065a0:	00000000 	nop
800065a4:	00a01021 	move	v0,a1
800065a8:	00602821 	move	a1,v1
                the end of the queue was reached. If at end, just                       
                link to the end of the queue.  Therefore, 'nxt' is                      
                either NULL or points to a block higher up in                           
                memory than the one being returned.
        */                                              
        prev->ptr = f;  /* link to queue */
800065ac:	ac440000 	sw	a0,0(v0)
        prev = f + f->size;     /* right after space to free */
800065b0:	8c830004 	lw	v1,4(a0)
800065b4:	000310c0 	sll	v0,v1,0x3
800065b8:	00821021 	addu	v0,a0,v0
        if (prev == nxt)        /* f and nxt are contiguous */
800065bc:	14450007 	bne	v0,a1,800065dc <free+0x154>
800065c0:	00000000 	nop
        {
                f->size += nxt->size;
800065c4:	8c450004 	lw	a1,4(v0)
800065c8:	00a31821 	addu	v1,a1,v1
800065cc:	ac830004 	sw	v1,4(a0)
                /* form a larger contiguous block */
                f->ptr = nxt->ptr;
800065d0:	8c420000 	lw	v0,0(v0)
800065d4:	08001978 	j	800065e0 <free+0x158>
800065d8:	ac820000 	sw	v0,0(a0)
        }
        else f->ptr = nxt;
800065dc:	ac850000 	sw	a1,0(a0)
        return;
}
800065e0:	8fbf0014 	lw	ra,20(sp)
800065e4:	03e00008 	jr	ra
800065e8:	27bd0018 	addiu	sp,sp,24
800065ec:	00000000 	nop

800065f0 <serial_outc>:




void serial_outc(char c)
{
800065f0:	7c042420 	seb	a0,a0
800065f4:	24020001 	li	v0,1
#if 1	
		i++;
		if (i >=6540)
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
800065f8:	3c05b800 	lui	a1,0xb800
800065fc:	34a52014 	ori	a1,a1,0x2014
#if 1
    while (1)
	{
#if 1	
		i++;
		if (i >=6540)
80006600:	08001984 	j	80006610 <serial_outc+0x20>
80006604:	2406198c 	li	a2,6540
80006608:	10460006 	beq	v0,a2,80006624 <serial_outc+0x34>
8000660c:	308300ff 	andi	v1,a0,0xff
			break;
#endif		
		if 	(rtl_inb(UART_LSR) & 0x60)
80006610:	90a30000 	lbu	v1,0(a1)
80006614:	30630060 	andi	v1,v1,0x60
80006618:	1060fffb 	beqz	v1,80006608 <serial_outc+0x18>
8000661c:	24420001 	addiu	v0,v0,1
			break;	
	}
#endif

	//for(i=0; i<0xff00;i++);
 	rtl_outb(UART_THR, c);  
80006620:	308300ff 	andi	v1,a0,0xff
80006624:	3c02b800 	lui	v0,0xb800
80006628:	34422000 	ori	v0,v0,0x2000
8000662c:	a0430000 	sb	v1,0(v0)
		  
	if (c == 0x0a)
80006630:	2402000a 	li	v0,10
80006634:	14820004 	bne	a0,v0,80006648 <serial_outc+0x58>
80006638:	2403000d 	li	v1,13
		rtl_outb(UART_THR, 0x0d);  
8000663c:	3c02b800 	lui	v0,0xb800
80006640:	34422000 	ori	v0,v0,0x2000
80006644:	a0430000 	sb	v1,0(v0)
80006648:	03e00008 	jr	ra
8000664c:	00000000 	nop

80006650 <serial_inc>:
#if defined(CONFIG_TFTP_COMMAND)
	tickStart=get_timer_jiffies();
#endif
    while (1)
	{
		if 	(rtl_inb(UART_LSR) & 0x1)
80006650:	3c03b800 	lui	v1,0xb800
80006654:	34632014 	ori	v1,v1,0x2014
80006658:	90620000 	lbu	v0,0(v1)
8000665c:	30420001 	andi	v0,v0,0x1
80006660:	1040fffd 	beqz	v0,80006658 <serial_inc+0x8>
80006664:	3c02b800 	lui	v0,0xb800
        if(time_after((get_timer_jiffies()),(tickStart+18000)))
		//if((get_timer_jiffies() - tickStart) > 18000) //3min=18000  1min=6000
		    autoreboot();
#endif
	}	
	i=rtl_inb(UART_RBR);
80006668:	34422000 	ori	v0,v0,0x2000
8000666c:	90420000 	lbu	v0,0(v0)
	return (i & 0xff);
	// ----------------------------------------------------
	// above is UART0, and below is SC16IS7x0 
	// ----------------------------------------------------
	
}
80006670:	03e00008 	jr	ra
80006674:	7c021420 	seb	v0,v0

80006678 <isspace>:

int isspace(char ch)
{
80006678:	7c042420 	seb	a0,a0
    return (unsigned int)(ch - 9) < 5u  ||  ch == ' ';	
8000667c:	2483fff7 	addiu	v1,a0,-9
80006680:	2c630005 	sltiu	v1,v1,5
80006684:	14600003 	bnez	v1,80006694 <isspace+0x1c>
80006688:	24020001 	li	v0,1
8000668c:	38820020 	xori	v0,a0,0x20
80006690:	2c420001 	sltiu	v0,v0,1
}
80006694:	03e00008 	jr	ra
80006698:	00000000 	nop
8000669c:	00000000 	nop

800066a0 <strcpy>:
#if 1
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
800066a0:	00801021 	move	v0,a0
800066a4:	00801821 	move	v1,a0
800066a8:	80a40000 	lb	a0,0(a1)
800066ac:	a0640000 	sb	a0,0(v1)
800066b0:	24630001 	addiu	v1,v1,1
800066b4:	1480fffc 	bnez	a0,800066a8 <strcpy+0x8>
800066b8:	24a50001 	addiu	a1,a1,1
		/* nothing */;
	return tmp;
}
800066bc:	03e00008 	jr	ra
800066c0:	00000000 	nop

800066c4 <strcmp>:
int strcmp(const char * cs,const char * ct)
{
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
800066c4:	80830000 	lb	v1,0(a0)
800066c8:	90a20000 	lbu	v0,0(a1)
800066cc:	00621023 	subu	v0,v1,v0
800066d0:	7c021420 	seb	v0,v0
800066d4:	14400003 	bnez	v0,800066e4 <strcmp+0x20>
800066d8:	24a50001 	addiu	a1,a1,1
800066dc:	1460fff9 	bnez	v1,800066c4 <strcmp>
800066e0:	24840001 	addiu	a0,a0,1
			break;
	}

	return __res;
}
800066e4:	03e00008 	jr	ra
800066e8:	00000000 	nop

800066ec <strchr>:
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
800066ec:	80830000 	lb	v1,0(a0)
800066f0:	7c052c20 	seb	a1,a1
800066f4:	1065000c 	beq	v1,a1,80006728 <strchr+0x3c>
800066f8:	00801021 	move	v0,a0
		if (*s == '\0')
800066fc:	14600007 	bnez	v1,8000671c <strchr+0x30>
80006700:	24420001 	addiu	v0,v0,1
80006704:	2442ffff 	addiu	v0,v0,-1
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
80006708:	03e00008 	jr	ra
8000670c:	00001021 	move	v0,zero
		if (*s == '\0')
80006710:	10600007 	beqz	v1,80006730 <strchr+0x44>
80006714:	00000000 	nop
}
#endif

char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
80006718:	24420001 	addiu	v0,v0,1
8000671c:	80430000 	lb	v1,0(v0)
80006720:	1465fffb 	bne	v1,a1,80006710 <strchr+0x24>
80006724:	00000000 	nop
80006728:	03e00008 	jr	ra
8000672c:	00000000 	nop
80006730:	00001021 	move	v0,zero
		if (*s == '\0')
			return NULL;
	return (char *) s;
}
80006734:	03e00008 	jr	ra
80006738:	00000000 	nop

8000673c <strlen>:
#endif
size_t strlen(const char * s)
{
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
8000673c:	80830000 	lb	v1,0(a0)
80006740:	10600006 	beqz	v1,8000675c <strlen+0x20>
80006744:	00801021 	move	v0,a0
80006748:	24420001 	addiu	v0,v0,1
8000674c:	80430000 	lb	v1,0(v0)
80006750:	1460fffe 	bnez	v1,8000674c <strlen+0x10>
80006754:	24420001 	addiu	v0,v0,1
80006758:	2442ffff 	addiu	v0,v0,-1
		/* nothing */;
	return sc - s;
}
8000675c:	03e00008 	jr	ra
80006760:	00441023 	subu	v0,v0,a0

80006764 <memset>:

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
80006764:	10c00006 	beqz	a2,80006780 <memset+0x1c>
80006768:	00801021 	move	v0,a0
}
#endif

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;
8000676c:	00801821 	move	v1,a0

	while (count--)
		*xs++ = c;
80006770:	a0650000 	sb	a1,0(v1)
80006774:	24c6ffff 	addiu	a2,a2,-1

void * memset(void * s,int c, size_t count)
{
	char *xs = (char *) s;

	while (count--)
80006778:	14c0fffd 	bnez	a2,80006770 <memset+0xc>
8000677c:	24630001 	addiu	v1,v1,1
		*xs++ = c;

	return s;
}
80006780:	03e00008 	jr	ra
80006784:	00000000 	nop

80006788 <memcpy>:
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
80006788:	10c00008 	beqz	a2,800067ac <memcpy+0x24>
8000678c:	00801021 	move	v0,a0
80006790:	00001821 	move	v1,zero
		*tmp++ = *s++;
80006794:	00432021 	addu	a0,v0,v1
80006798:	00a33821 	addu	a3,a1,v1
8000679c:	90e70000 	lbu	a3,0(a3)
800067a0:	24630001 	addiu	v1,v1,1
#endif
void * memcpy(void * dest,const void *src,size_t count)
{
	char *tmp = (char *) dest, *s = (char *) src;

	while (count--)
800067a4:	1466fffb 	bne	v1,a2,80006794 <memcpy+0xc>
800067a8:	a0870000 	sb	a3,0(a0)
		*tmp++ = *s++;

	return dest;
}
800067ac:	03e00008 	jr	ra
800067b0:	00000000 	nop

800067b4 <memcmp>:
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
800067b4:	10c00007 	beqz	a2,800067d4 <memcmp+0x20>
800067b8:	00001021 	move	v0,zero
		if ((res = *su1 - *su2) != 0)
800067bc:	90830000 	lbu	v1,0(a0)
800067c0:	90a20000 	lbu	v0,0(a1)
800067c4:	00621023 	subu	v0,v1,v0
800067c8:	7c021420 	seb	v0,v0
800067cc:	1040000a 	beqz	v0,800067f8 <memcmp+0x44>
800067d0:	00001821 	move	v1,zero
800067d4:	03e00008 	jr	ra
800067d8:	00000000 	nop
800067dc:	00a31021 	addu	v0,a1,v1
800067e0:	90e70001 	lbu	a3,1(a3)
800067e4:	90420001 	lbu	v0,1(v0)
800067e8:	00e21023 	subu	v0,a3,v0
800067ec:	7c021420 	seb	v0,v0
800067f0:	1440fff8 	bnez	v0,800067d4 <memcmp+0x20>
800067f4:	24630001 	addiu	v1,v1,1
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	signed char res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
800067f8:	24c6ffff 	addiu	a2,a2,-1
800067fc:	14c0fff7 	bnez	a2,800067dc <memcmp+0x28>
80006800:	00833821 	addu	a3,a0,v1
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
80006804:	03e00008 	jr	ra
80006808:	00000000 	nop

8000680c <strstr>:
#endif
char * strstr(const char * s1,const char * s2)
{
	int l1, l2;

	l2 = strlen(s2);
8000680c:	27bdffd8 	addiu	sp,sp,-40
80006810:	afbf0024 	sw	ra,36(sp)
80006814:	afb40020 	sw	s4,32(sp)
80006818:	afb3001c 	sw	s3,28(sp)
8000681c:	afb20018 	sw	s2,24(sp)
80006820:	afb10014 	sw	s1,20(sp)
80006824:	afb00010 	sw	s0,16(sp)
80006828:	00808021 	move	s0,a0
8000682c:	00a09021 	move	s2,a1
80006830:	0c0019cf 	jal	8000673c <strlen>
80006834:	00a02021 	move	a0,a1
80006838:	00408821 	move	s1,v0
	if (!l2)
8000683c:	10400011 	beqz	v0,80006884 <strstr+0x78>
80006840:	0040a021 	move	s4,v0
		return (char *) s1;
	l1 = strlen(s1);
80006844:	0c0019cf 	jal	8000673c <strlen>
80006848:	02002021 	move	a0,s0
8000684c:	00409821 	move	s3,v0
	while (l1 >= l2) {
80006850:	0051102a 	slt	v0,v0,s1
80006854:	1440000a 	bnez	v0,80006880 <strstr+0x74>
80006858:	00000000 	nop
		l1--;
		if (!memcmp(s1,s2,l2))
8000685c:	02002021 	move	a0,s0
80006860:	02402821 	move	a1,s2
80006864:	0c0019ed 	jal	800067b4 <memcmp>
80006868:	02203021 	move	a2,s1
8000686c:	10400005 	beqz	v0,80006884 <strstr+0x78>
80006870:	2673ffff 	addiu	s3,s3,-1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
80006874:	0274102a 	slt	v0,s3,s4
80006878:	1040fff8 	beqz	v0,8000685c <strstr+0x50>
8000687c:	26100001 	addiu	s0,s0,1
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
80006880:	00008021 	move	s0,zero
	}
	return NULL;
}
80006884:	02001021 	move	v0,s0
80006888:	8fbf0024 	lw	ra,36(sp)
8000688c:	8fb40020 	lw	s4,32(sp)
80006890:	8fb3001c 	lw	s3,28(sp)
80006894:	8fb20018 	lw	s2,24(sp)
80006898:	8fb10014 	lw	s1,20(sp)
8000689c:	8fb00010 	lw	s0,16(sp)
800068a0:	03e00008 	jr	ra
800068a4:	27bd0028 	addiu	sp,sp,40
	...

800068b0 <strtol>:
#include <limits.h>


#define ABS_LONG_MIN 2147483648UL
long int strtol(const char *nptr, char **endptr, int base)
{
800068b0:	27bdffd8 	addiu	sp,sp,-40
800068b4:	afbf0024 	sw	ra,36(sp)
800068b8:	afb40020 	sw	s4,32(sp)
800068bc:	afb3001c 	sw	s3,28(sp)
800068c0:	afb20018 	sw	s2,24(sp)
800068c4:	afb10014 	sw	s1,20(sp)
800068c8:	afb00010 	sw	s0,16(sp)
800068cc:	00808021 	move	s0,a0
800068d0:	00a09821 	move	s3,a1
800068d4:	00c0a021 	move	s4,a2
  int neg=0;
  unsigned long int v;

  while(isspace(*nptr)) nptr++;
800068d8:	82110000 	lb	s1,0(s0)
800068dc:	0c00199e 	jal	80006678 <isspace>
800068e0:	02202021 	move	a0,s1
800068e4:	1440fffc 	bnez	v0,800068d8 <strtol+0x28>
800068e8:	26100001 	addiu	s0,s0,1
800068ec:	2610ffff 	addiu	s0,s0,-1

  if (*nptr == '-') { neg=-1; ++nptr; }
800068f0:	2402002d 	li	v0,45
800068f4:	16220003 	bne	s1,v0,80006904 <strtol+0x54>
800068f8:	00009021 	move	s2,zero
800068fc:	26100001 	addiu	s0,s0,1
80006900:	2412ffff 	li	s2,-1
  v=strtoul(nptr,endptr,base);
80006904:	02002021 	move	a0,s0
80006908:	02602821 	move	a1,s3
8000690c:	0c001a60 	jal	80006980 <strtoul>
80006910:	02803021 	move	a2,s4
  if (v>=ABS_LONG_MIN) {
80006914:	0441000c 	bgez	v0,80006948 <strtol+0x98>
80006918:	00021823 	negu	v1,v0
    if (v==ABS_LONG_MIN && neg) {
8000691c:	3c048000 	lui	a0,0x8000
80006920:	14440005 	bne	v0,a0,80006938 <strtol+0x88>
80006924:	00000000 	nop
80006928:	12400009 	beqz	s2,80006950 <strtol+0xa0>
8000692c:	8fbf0024 	lw	ra,36(sp)
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
}
80006930:	08001a58 	j	80006960 <strtol+0xb0>
80006934:	8fb40020 	lw	s4,32(sp)
    if (v==ABS_LONG_MIN && neg) {
      //errno=0;
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
80006938:	12400005 	beqz	s2,80006950 <strtol+0xa0>
8000693c:	3c028000 	lui	v0,0x8000
  }
  return (neg?-v:v);
}
80006940:	08001a57 	j	8000695c <strtol+0xac>
80006944:	8fbf0024 	lw	ra,36(sp)
      return v;
    }
   // errno=ERANGE;
    return (neg?LONG_MIN:LONG_MAX);
  }
  return (neg?-v:v);
80006948:	08001a56 	j	80006958 <strtol+0xa8>
8000694c:	0072100b 	movn	v0,v1,s2
80006950:	3c027fff 	lui	v0,0x7fff
80006954:	3442ffff 	ori	v0,v0,0xffff
}
80006958:	8fbf0024 	lw	ra,36(sp)
8000695c:	8fb40020 	lw	s4,32(sp)
80006960:	8fb3001c 	lw	s3,28(sp)
80006964:	8fb20018 	lw	s2,24(sp)
80006968:	8fb10014 	lw	s1,20(sp)
8000696c:	8fb00010 	lw	s0,16(sp)
80006970:	03e00008 	jr	ra
80006974:	27bd0028 	addiu	sp,sp,40
	...

80006980 <strtoul>:

#include <limits.h>

unsigned long int strtoul(const char *nptr, char **endptr, int base)
{
80006980:	27bdffd8 	addiu	sp,sp,-40
80006984:	afbf0024 	sw	ra,36(sp)
80006988:	afb30020 	sw	s3,32(sp)
8000698c:	afb2001c 	sw	s2,28(sp)
80006990:	afb10018 	sw	s1,24(sp)
80006994:	afb00014 	sw	s0,20(sp)
80006998:	00808021 	move	s0,a0
8000699c:	00a09821 	move	s3,a1
800069a0:	00c08821 	move	s1,a2
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
800069a4:	82120000 	lb	s2,0(s0)
800069a8:	0c00199e 	jal	80006678 <isspace>
800069ac:	02402021 	move	a0,s2
800069b0:	1440fffc 	bnez	v0,800069a4 <strtoul+0x24>
800069b4:	26100001 	addiu	s0,s0,1
800069b8:	2610ffff 	addiu	s0,s0,-1
  if (*nptr == '+') ++nptr;
800069bc:	26020001 	addiu	v0,s0,1
800069c0:	3a52002b 	xori	s2,s2,0x2b
800069c4:	0052800a 	movz	s0,v0,s2
  if (base==16 && nptr[0]=='0') goto skip0x;
800069c8:	24020010 	li	v0,16
800069cc:	16220006 	bne	s1,v0,800069e8 <strtoul+0x68>
800069d0:	24020030 	li	v0,48
800069d4:	82030000 	lb	v1,0(s0)
800069d8:	14620012 	bne	v1,v0,80006a24 <strtoul+0xa4>
800069dc:	00000000 	nop
  if (!base) {
    if (*nptr=='0') {
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
800069e0:	08001a81 	j	80006a04 <strtoul+0x84>
800069e4:	82020001 	lb	v0,1(s0)
  unsigned long int v=0;

  while(isspace(*nptr)) ++nptr;
  if (*nptr == '+') ++nptr;
  if (base==16 && nptr[0]=='0') goto skip0x;
  if (!base) {
800069e8:	1620000d 	bnez	s1,80006a20 <strtoul+0xa0>
800069ec:	00000000 	nop
    if (*nptr=='0') {
800069f0:	82030000 	lb	v1,0(s0)
800069f4:	1462000b 	bne	v1,v0,80006a24 <strtoul+0xa4>
800069f8:	2411000a 	li	s1,10
800069fc:	24110008 	li	s1,8
      base=8;
skip0x:
      if (nptr[1]=='x'||nptr[1]=='X') {
80006a00:	82020001 	lb	v0,1(s0)
80006a04:	24030078 	li	v1,120
80006a08:	10430003 	beq	v0,v1,80006a18 <strtoul+0x98>
80006a0c:	24030058 	li	v1,88
80006a10:	14430003 	bne	v0,v1,80006a20 <strtoul+0xa0>
80006a14:	00000000 	nop
	nptr+=2;
80006a18:	26100002 	addiu	s0,s0,2
80006a1c:	24110010 	li	s1,16
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
80006a20:	82030000 	lb	v1,0(s0)
80006a24:	00001021 	move	v0,zero
80006a28:	1060001f 	beqz	v1,80006aa8 <strtoul+0x128>
80006a2c:	240600ff 	li	a2,255
    register unsigned char c=*nptr;
80006a30:	306300ff 	andi	v1,v1,0xff
    c=(c>='a'?c-'a'+10:c>='A'?c-'A'+10:c<='9'?c-'0':0xff);
80006a34:	2c640061 	sltiu	a0,v1,97
80006a38:	14800004 	bnez	a0,80006a4c <strtoul+0xcc>
80006a3c:	00000000 	nop
80006a40:	2463ffa9 	addiu	v1,v1,-87
80006a44:	08001a9d 	j	80006a74 <strtoul+0xf4>
80006a48:	306400ff 	andi	a0,v1,0xff
80006a4c:	2c640041 	sltiu	a0,v1,65
80006a50:	14800004 	bnez	a0,80006a64 <strtoul+0xe4>
80006a54:	2c65003a 	sltiu	a1,v1,58
80006a58:	2463ffc9 	addiu	v1,v1,-55
80006a5c:	08001a9d 	j	80006a74 <strtoul+0xf4>
80006a60:	306400ff 	andi	a0,v1,0xff
80006a64:	10a00003 	beqz	a1,80006a74 <strtoul+0xf4>
80006a68:	00c02021 	move	a0,a2
80006a6c:	2463ffd0 	addiu	v1,v1,-48
80006a70:	306400ff 	andi	a0,v1,0xff
    if (c>=base) break;
80006a74:	0091182a 	slt	v1,a0,s1
80006a78:	1060000b 	beqz	v1,80006aa8 <strtoul+0x128>
80006a7c:	00000000 	nop
    {
      register unsigned long int w=v*base;
80006a80:	70511802 	mul	v1,v0,s1
      if (w<v) {
80006a84:	0062102b 	sltu	v0,v1,v0
80006a88:	10400003 	beqz	v0,80006a98 <strtoul+0x118>
80006a8c:	26100001 	addiu	s0,s0,1
80006a90:	08001aad 	j	80006ab4 <strtoul+0x134>
80006a94:	2402ffff 	li	v0,-1
	//errno=ERANGE;
	return ULONG_MAX;
      }
      v=w+c;
80006a98:	00831021 	addu	v0,a0,v1
	base=16;
      }
    } else
      base=10;
  }
  while(*nptr) {
80006a9c:	82030000 	lb	v1,0(s0)
80006aa0:	1460ffe3 	bnez	v1,80006a30 <strtoul+0xb0>
80006aa4:	00000000 	nop
      }
      v=w+c;
    }
    ++nptr;
  }
  if (endptr) *endptr=(char *)nptr;
80006aa8:	12600003 	beqz	s3,80006ab8 <strtoul+0x138>
80006aac:	8fbf0024 	lw	ra,36(sp)
80006ab0:	ae700000 	sw	s0,0(s3)
  //errno=0;	/* in case v==ULONG_MAX, ugh! */
  return v;
}
80006ab4:	8fbf0024 	lw	ra,36(sp)
80006ab8:	8fb30020 	lw	s3,32(sp)
80006abc:	8fb2001c 	lw	s2,28(sp)
80006ac0:	8fb10018 	lw	s1,24(sp)
80006ac4:	8fb00014 	lw	s0,20(sp)
80006ac8:	03e00008 	jr	ra
80006acc:	27bd0028 	addiu	sp,sp,40

80006ad0 <StrUpr>:
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
80006ad0:	80850000 	lb	a1,0(a0)
80006ad4:	10a0000d 	beqz	a1,80006b0c <StrUpr+0x3c>
80006ad8:	00801021 	move	v0,a0
80006adc:	00801821 	move	v1,a0
		if( *p >= 'a'  &&  *p <= 'z' ){
80006ae0:	30a500ff 	andi	a1,a1,0xff
80006ae4:	24a6ff9f 	addiu	a2,a1,-97
80006ae8:	30c600ff 	andi	a2,a2,0xff
80006aec:	2cc6001a 	sltiu	a2,a2,26
80006af0:	10c00002 	beqz	a2,80006afc <StrUpr+0x2c>
80006af4:	24a5ffe0 	addiu	a1,a1,-32
			*p -= det ;
80006af8:	a0650000 	sb	a1,0(v1)
		}
		p++ ;
80006afc:	24630001 	addiu	v1,v1,1
char* StrUpr( char* string ){
	char*		p ;
	const int	det = 'a' - 'A';

	p = string ;
	while( *p ){
80006b00:	80650000 	lb	a1,0(v1)
80006b04:	14a0fff7 	bnez	a1,80006ae4 <StrUpr+0x14>
80006b08:	30a500ff 	andi	a1,a1,0xff
			*p -= det ;
		}
		p++ ;
	}
	return string ;
}
80006b0c:	03e00008 	jr	ra
80006b10:	00000000 	nop

80006b14 <GetArgc>:
;			argument number
;   Destroy:
---------------------------------------------------------------------------
*/
int GetArgc( const char* string )
{
80006b14:	00003021 	move	a2,zero
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
80006b18:	08001ad4 	j	80006b50 <GetArgc+0x3c>
80006b1c:	24050020 	li	a1,32
	{
		if( *p != ' '  &&  *p )
80006b20:	1065000a 	beq	v1,a1,80006b4c <GetArgc+0x38>
80006b24:	00000000 	nop
		{
			argc++ ;
80006b28:	24c60001 	addiu	a2,a2,1
			while( *p != ' '  &&  *p ) p++ ;
80006b2c:	24840001 	addiu	a0,a0,1
80006b30:	80830000 	lb	v1,0(a0)
80006b34:	10650007 	beq	v1,a1,80006b54 <GetArgc+0x40>
80006b38:	00000000 	nop
80006b3c:	1460fffc 	bnez	v1,80006b30 <GetArgc+0x1c>
80006b40:	24840001 	addiu	a0,a0,1
80006b44:	08001ad5 	j	80006b54 <GetArgc+0x40>
80006b48:	2484ffff 	addiu	a0,a0,-1
			continue ;
		}
		p++ ;
80006b4c:	24840001 	addiu	a0,a0,1
	int			argc;
	char*		p ;

	argc = 0 ;
	p = (char* )string ;
	while( *p )
80006b50:	80830000 	lb	v1,0(a0)
80006b54:	1460fff2 	bnez	v1,80006b20 <GetArgc+0xc>
80006b58:	24020013 	li	v0,19
80006b5c:	28c30014 	slti	v1,a2,20
		}
		p++ ;
	}
	if (argc >= MAX_ARGV) argc = MAX_ARGV - 1;
	return argc ;
}
80006b60:	03e00008 	jr	ra
80006b64:	00c3100b 	movn	v0,a2,v1

80006b68 <Hex2Val>:
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
80006b68:	08001af5 	j	80006bd4 <Hex2Val+0x6c>
80006b6c:	00003021 	move	a2,zero
	{
		if( c>='0' && c<='9')		HexValue = c - '0';
80006b70:	2443ffd0 	addiu	v1,v0,-48
80006b74:	306300ff 	andi	v1,v1,0xff
80006b78:	2c67000a 	sltiu	a3,v1,10
80006b7c:	14e00010 	bnez	a3,80006bc0 <Hex2Val+0x58>
80006b80:	00000000 	nop
		else if( c>='a' && c<='f')	HexValue = c - 'a' + 10;
80006b84:	2443ff9f 	addiu	v1,v0,-97
80006b88:	306300ff 	andi	v1,v1,0xff
80006b8c:	2c630006 	sltiu	v1,v1,6
80006b90:	10600004 	beqz	v1,80006ba4 <Hex2Val+0x3c>
80006b94:	00000000 	nop
80006b98:	2442ffa9 	addiu	v0,v0,-87
80006b9c:	08001af0 	j	80006bc0 <Hex2Val+0x58>
80006ba0:	304300ff 	andi	v1,v0,0xff
		else if( c>='A' && c<='F')  HexValue = c - 'A' + 10;
80006ba4:	2443ffbf 	addiu	v1,v0,-65
80006ba8:	306300ff 	andi	v1,v1,0xff
80006bac:	2c630006 	sltiu	v1,v1,6
80006bb0:	1060000e 	beqz	v1,80006bec <Hex2Val+0x84>
80006bb4:	00000000 	nop
80006bb8:	2442ffc9 	addiu	v0,v0,-55
80006bbc:	304300ff 	andi	v1,v0,0xff
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
80006bc0:	00061100 	sll	v0,a2,0x4
80006bc4:	00621821 	addu	v1,v1,v0
		if(sum < csum) return FALSE;	// value overlow
80006bc8:	0066302b 	sltu	a2,v1,a2
80006bcc:	14c00007 	bnez	a2,80006bec <Hex2Val+0x84>
80006bd0:	00603021 	move	a2,v1
	unsigned long				sum,csum;
	register unsigned char		c,HexValue;

	sum = csum = 0;
	ptrb = HexStr;
	while(c=*ptrb++)
80006bd4:	90820000 	lbu	v0,0(a0)
80006bd8:	1440ffe5 	bnez	v0,80006b70 <Hex2Val+0x8>
80006bdc:	24840001 	addiu	a0,a0,1
		else return FALSE;				// character invalid
		sum = csum*16 + HexValue;
		if(sum < csum) return FALSE;	// value overlow
		csum = sum;
	}
	*PVal = csum;
80006be0:	aca60000 	sw	a2,0(a1)
	return TRUE;
80006be4:	03e00008 	jr	ra
80006be8:	24020001 	li	v0,1
}
80006bec:	03e00008 	jr	ra
80006bf0:	00001021 	move	v0,zero

80006bf4 <GetArgv>:
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
{
80006bf4:	27bdffe0 	addiu	sp,sp,-32
80006bf8:	afbf001c 	sw	ra,28(sp)
80006bfc:	afb10018 	sw	s1,24(sp)
80006c00:	afb00014 	sw	s0,20(sp)
80006c04:	00808821 	move	s1,a0
	char*			p ;
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
80006c08:	3c108001 	lui	s0,0x8001
80006c0c:	261040c0 	addiu	s0,s0,16576
80006c10:	02002021 	move	a0,s0
80006c14:	00002821 	move	a1,zero
80006c18:	0c0019d9 	jal	80006764 <memset>
80006c1c:	24060050 	li	a2,80
;			argument string array, argv[0], argv[1],...
;			argument string end by zero character
;   Destroy:
---------------------------------------------------------------------------
*/
char** GetArgv(const char* string)
80006c20:	3c048001 	lui	a0,0x8001
80006c24:	24844110 	addiu	a0,a0,16656
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
80006c28:	08001b26 	j	80006c98 <GetArgv+0xa4>
80006c2c:	24030020 	li	v1,32
	{
		ArgvArray[n] = p ;
80006c30:	ae110000 	sw	s1,0(s0)
		while( *p != ' '  &&  *p ) p++ ;
80006c34:	82220000 	lb	v0,0(s1)
80006c38:	1043000a 	beq	v0,v1,80006c64 <GetArgv+0x70>
80006c3c:	00000000 	nop
80006c40:	10400008 	beqz	v0,80006c64 <GetArgv+0x70>
80006c44:	00000000 	nop
80006c48:	26310001 	addiu	s1,s1,1
80006c4c:	82220000 	lb	v0,0(s1)
80006c50:	10430004 	beq	v0,v1,80006c64 <GetArgv+0x70>
80006c54:	00000000 	nop
80006c58:	1440fffc 	bnez	v0,80006c4c <GetArgv+0x58>
80006c5c:	26310001 	addiu	s1,s1,1
80006c60:	2631ffff 	addiu	s1,s1,-1
		*p++ = '\0';
80006c64:	a2200000 	sb	zero,0(s1)
80006c68:	26310001 	addiu	s1,s1,1
		while( *p == ' '  &&  *p ) p++ ;
80006c6c:	82220000 	lb	v0,0(s1)
80006c70:	14430006 	bne	v0,v1,80006c8c <GetArgv+0x98>
80006c74:	00000000 	nop
80006c78:	26310001 	addiu	s1,s1,1
80006c7c:	82220000 	lb	v0,0(s1)
80006c80:	1043fffe 	beq	v0,v1,80006c7c <GetArgv+0x88>
80006c84:	26310001 	addiu	s1,s1,1
80006c88:	2631ffff 	addiu	s1,s1,-1
80006c8c:	26100004 	addiu	s0,s0,4
		n++ ;
		if (n == MAX_ARGV) break;
80006c90:	12040004 	beq	s0,a0,80006ca4 <GetArgv+0xb0>
80006c94:	3c028001 	lui	v0,0x8001
	int				n;

	n = 0 ;
	memset( ArgvArray, 0, MAX_ARGV*sizeof(char *) );
	p = (char* )string ;
	while( *p )
80006c98:	82220000 	lb	v0,0(s1)
80006c9c:	1440ffe4 	bnez	v0,80006c30 <GetArgv+0x3c>
80006ca0:	3c028001 	lui	v0,0x8001
		while( *p == ' '  &&  *p ) p++ ;
		n++ ;
		if (n == MAX_ARGV) break;
	}
	return (char** )&ArgvArray ;
}
80006ca4:	244240c0 	addiu	v0,v0,16576
80006ca8:	8fbf001c 	lw	ra,28(sp)
80006cac:	8fb10018 	lw	s1,24(sp)
80006cb0:	8fb00014 	lw	s0,20(sp)
80006cb4:	03e00008 	jr	ra
80006cb8:	27bd0020 	addiu	sp,sp,32

80006cbc <GetLine>:
unsigned char history_cmd[HISTORY_CMD_ELN][ MAX_MONITOR_BUFFER +1 ]={0};
int hist_save_idx=0;
int hist_see_idx=0;
#endif
void GetLine( char * buffer, const unsigned int size, int EchoFlag )
{
80006cbc:	27bdffc8 	addiu	sp,sp,-56
80006cc0:	afbf0034 	sw	ra,52(sp)
80006cc4:	afbe0030 	sw	s8,48(sp)
80006cc8:	afb7002c 	sw	s7,44(sp)
80006ccc:	afb60028 	sw	s6,40(sp)
80006cd0:	afb50024 	sw	s5,36(sp)
80006cd4:	afb40020 	sw	s4,32(sp)
80006cd8:	afb3001c 	sw	s3,28(sp)
80006cdc:	afb20018 	sw	s2,24(sp)
80006ce0:	afb10014 	sw	s1,20(sp)
80006ce4:	afb00010 	sw	s0,16(sp)
80006ce8:	afa40038 	sw	a0,56(sp)
80006cec:	00a0b021 	move	s6,a1
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80006cf0:	10a0003a 	beqz	a1,80006ddc <GetLine+0x120>
80006cf4:	00c0a821 	move	s5,a2
80006cf8:	00809821 	move	s3,a0
80006cfc:	00009021 	move	s2,zero
	{
		c = GetChar() ;
		if( c == -1 )
80006d00:	2417ffff 	li	s7,-1
		}

#endif
		    break ;
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
80006d04:	24140008 	li	s4,8
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
80006d08:	241e0020 	li	s8,32
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
	{
		c = GetChar() ;
80006d0c:	0c001994 	jal	80006650 <serial_inc>
80006d10:	00000000 	nop
		if( c == -1 )
80006d14:	1057002e 	beq	v0,s7,80006dd0 <GetLine+0x114>
80006d18:	7c022420 	seb	a0,v0
		{
		    continue;
		}
		ch = c;
		//dprintf("%x ",ch);
		if( ch == KEYCODE_LF )
80006d1c:	2402000a 	li	v0,10
80006d20:	1082002e 	beq	a0,v0,80006ddc <GetLine+0x120>
80006d24:	2402000d 	li	v0,13
		    *--p = 0 ;
		    n-- ;
		    #endif // USE_LF
		    break ;
		}
		else if( ch == KEYCODE_CR )
80006d28:	14820003 	bne	a0,v0,80006d38 <GetLine+0x7c>
80006d2c:	00000000 	nop
			(hist_save_idx >= HISTORY_CMD_ELN-1) ? hist_save_idx=0 : hist_save_idx++;
			hist_see_idx=hist_save_idx;
		}

#endif
		    break ;
80006d30:	08001b77 	j	80006ddc <GetLine+0x120>
80006d34:	a2600000 	sb	zero,0(s3)
		}
		else if ((ch == KEYCODE_BS) || (ch == KEYCODE_CTRL_BS))
80006d38:	10940003 	beq	a0,s4,80006d48 <GetLine+0x8c>
80006d3c:	2402007f 	li	v0,127
80006d40:	1482000f 	bne	a0,v0,80006d80 <GetLine+0xc4>
80006d44:	24020009 	li	v0,9
		{
		    if( p != buffer )
80006d48:	8fa20038 	lw	v0,56(sp)
80006d4c:	12620021 	beq	s3,v0,80006dd4 <GetLine+0x118>
80006d50:	0256102b 	sltu	v0,s2,s6
		    {
			    p-- ;
80006d54:	2673ffff 	addiu	s3,s3,-1
			    n-- ;
							if(EchoFlag)
80006d58:	12a0001d 	beqz	s5,80006dd0 <GetLine+0x114>
80006d5c:	2652ffff 	addiu	s2,s2,-1
							{
								PutChar(KEYCODE_BS);
80006d60:	0c00197c 	jal	800065f0 <serial_outc>
80006d64:	02802021 	move	a0,s4
								PutChar(' ');
80006d68:	0c00197c 	jal	800065f0 <serial_outc>
80006d6c:	24040020 	li	a0,32
								PutChar(KEYCODE_BS);
80006d70:	0c00197c 	jal	800065f0 <serial_outc>
80006d74:	02802021 	move	a0,s4
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80006d78:	08001b75 	j	80006dd4 <GetLine+0x118>
80006d7c:	0256102b 	sltu	v0,s2,s6
								PutChar(' ');
								PutChar(KEYCODE_BS);
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
80006d80:	1482000d 	bne	a0,v0,80006db8 <GetLine+0xfc>
80006d84:	02608021 	move	s0,s3
80006d88:	00008821 	move	s1,zero
		{
		    for( i=0 ; i < TAB ; i++ )
		    {
			    *p++ = ' ' ;
80006d8c:	a21e0000 	sb	s8,0(s0)
			    n++ ;
							if(EchoFlag) PutChar(' ');
80006d90:	12a00003 	beqz	s5,80006da0 <GetLine+0xe4>
80006d94:	26100001 	addiu	s0,s0,1
80006d98:	0c00197c 	jal	800065f0 <serial_outc>
80006d9c:	24040020 	li	a0,32
							}
		    }
		}
		else if( ch == KEYCODE_TAB )
		{
		    for( i=0 ; i < TAB ; i++ )
80006da0:	26310001 	addiu	s1,s1,1
80006da4:	1634fff9 	bne	s1,s4,80006d8c <GetLine+0xd0>
80006da8:	00000000 	nop
80006dac:	26730008 	addiu	s3,s3,8
80006db0:	08001b74 	j	80006dd0 <GetLine+0x114>
80006db4:	26520008 	addiu	s2,s2,8
			
		}
#endif
		else
		{
		    *p++ = ch ;
80006db8:	a2640000 	sb	a0,0(s3)
80006dbc:	26730001 	addiu	s3,s3,1
		    n++ ;
					if(EchoFlag) PutChar(ch);
80006dc0:	12a00003 	beqz	s5,80006dd0 <GetLine+0x114>
80006dc4:	26520001 	addiu	s2,s2,1
80006dc8:	0c00197c 	jal	800065f0 <serial_outc>
80006dcc:	00000000 	nop
	int		c;
	char*		p = buffer ;
	unsigned int	n = 0L ;
	int		i ;

	while( n < size )
80006dd0:	0256102b 	sltu	v0,s2,s6
80006dd4:	1440ffcd 	bnez	v0,80006d0c <GetLine+0x50>
80006dd8:	00000000 	nop
		    *p++ = ch ;
		    n++ ;
					if(EchoFlag) PutChar(ch);
		}
	}
}
80006ddc:	8fbf0034 	lw	ra,52(sp)
80006de0:	8fbe0030 	lw	s8,48(sp)
80006de4:	8fb7002c 	lw	s7,44(sp)
80006de8:	8fb60028 	lw	s6,40(sp)
80006dec:	8fb50024 	lw	s5,36(sp)
80006df0:	8fb40020 	lw	s4,32(sp)
80006df4:	8fb3001c 	lw	s3,28(sp)
80006df8:	8fb20018 	lw	s2,24(sp)
80006dfc:	8fb10014 	lw	s1,20(sp)
80006e00:	8fb00010 	lw	s0,16(sp)
80006e04:	03e00008 	jr	ra
80006e08:	27bd0038 	addiu	sp,sp,56
80006e0c:	00000000 	nop

80006e10 <strcasecmp>:
/**************************************************************************
STRCASECMP (not entirely correct, but this will do for our purposes)
**************************************************************************/
int strcasecmp(char *a, char *b)
{
	while (*a && *b && (*a & ~0x20) == (*b & ~0x20)) {a++; b++; }
80006e10:	80820000 	lb	v0,0(a0)
80006e14:	10400013 	beqz	v0,80006e64 <strcasecmp+0x54>
80006e18:	2403ffdf 	li	v1,-33
80006e1c:	80a30000 	lb	v1,0(a1)
80006e20:	1060000f 	beqz	v1,80006e60 <strcasecmp+0x50>
80006e24:	00621826 	xor	v1,v1,v0
80006e28:	2406ffdf 	li	a2,-33
80006e2c:	00661824 	and	v1,v1,a2
80006e30:	1460000c 	bnez	v1,80006e64 <strcasecmp+0x54>
80006e34:	2403ffdf 	li	v1,-33
80006e38:	24840001 	addiu	a0,a0,1
80006e3c:	80820000 	lb	v0,0(a0)
80006e40:	10400007 	beqz	v0,80006e60 <strcasecmp+0x50>
80006e44:	24a50001 	addiu	a1,a1,1
80006e48:	80a30000 	lb	v1,0(a1)
80006e4c:	10600004 	beqz	v1,80006e60 <strcasecmp+0x50>
80006e50:	00621826 	xor	v1,v1,v0
80006e54:	00661824 	and	v1,v1,a2
80006e58:	1060fff8 	beqz	v1,80006e3c <strcasecmp+0x2c>
80006e5c:	24840001 	addiu	a0,a0,1
80006e60:	2403ffdf 	li	v1,-33
80006e64:	00431024 	and	v0,v0,v1
80006e68:	90a40000 	lbu	a0,0(a1)
80006e6c:	00831824 	and	v1,a0,v1
80006e70:	7c031c20 	seb	v1,v1
	return((*a & ~0x20) - (*b & ~0x20));
}
80006e74:	03e00008 	jr	ra
80006e78:	00431023 	subu	v0,v0,v1

80006e7c <getdec>:
}


int getdec(char **ptr)
{
	char *p = *ptr;
80006e7c:	8c830000 	lw	v1,0(a0)
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
80006e80:	80650000 	lb	a1,0(v1)
80006e84:	24a6ffd0 	addiu	a2,a1,-48
80006e88:	30c600ff 	andi	a2,a2,0xff
80006e8c:	2cc6000a 	sltiu	a2,a2,10
80006e90:	14c00003 	bnez	a2,80006ea0 <getdec+0x24>
80006e94:	00001021 	move	v0,zero
80006e98:	03e00008 	jr	ra
80006e9c:	2402ffff 	li	v0,-1
	while ((*p >= '0') && (*p <= '9')) {
		ret = ret*10 + (*p - '0');
80006ea0:	00023040 	sll	a2,v0,0x1
80006ea4:	000210c0 	sll	v0,v0,0x3
80006ea8:	00c21021 	addu	v0,a2,v0
80006eac:	00451021 	addu	v0,v0,a1
		p++;
80006eb0:	24630001 	addiu	v1,v1,1
int getdec(char **ptr)
{
	char *p = *ptr;
	int ret=0;
	if ((*p < '0') || (*p > '9')) return(-1);
	while ((*p >= '0') && (*p <= '9')) {
80006eb4:	80650000 	lb	a1,0(v1)
80006eb8:	24a6ffd0 	addiu	a2,a1,-48
80006ebc:	30c600ff 	andi	a2,a2,0xff
80006ec0:	2cc6000a 	sltiu	a2,a2,10
80006ec4:	14c0fff6 	bnez	a2,80006ea0 <getdec+0x24>
80006ec8:	2442ffd0 	addiu	v0,v0,-48
		ret = ret*10 + (*p - '0');
		p++;
	}
	*ptr = p;
	return(ret);
}
80006ecc:	03e00008 	jr	ra
80006ed0:	ac830000 	sw	v1,0(a0)

80006ed4 <delay_ms>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
}
//-----------------------------------------
void delay_ms(unsigned int time_ms)
{
80006ed4:	27bdffe0 	addiu	sp,sp,-32
80006ed8:	afbf001c 	sw	ra,28(sp)
80006edc:	afb10018 	sw	s1,24(sp)
80006ee0:	afb00014 	sw	s0,20(sp)
	
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
80006ee4:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006ee8:	00808821 	move	s1,a0
80006eec:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
80006ef0:	3c02cccc 	lui	v0,0xcccc
80006ef4:	3442cccd 	ori	v0,v0,0xcccd
80006ef8:	02220019 	multu	s1,v0
80006efc:	00008810 	mfhi	s1
80006f00:	001188c2 	srl	s1,s1,0x3
80006f04:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006f08:	00000000 	nop
80006f0c:	00501023 	subu	v0,v0,s0
80006f10:	0051102b 	sltu	v0,v0,s1
80006f14:	1440fffb 	bnez	v0,80006f04 <delay_ms+0x30>
80006f18:	8fbf001c 	lw	ra,28(sp)
}
80006f1c:	8fb10018 	lw	s1,24(sp)
80006f20:	8fb00014 	lw	s0,20(sp)
80006f24:	03e00008 	jr	ra
80006f28:	27bd0020 	addiu	sp,sp,32

80006f2c <delay_sec>:
   preTime = get_timer_jiffies();
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
}
//-----------------------------------------
void delay_sec(unsigned int time_sec)
{
80006f2c:	27bdffe0 	addiu	sp,sp,-32
80006f30:	afbf001c 	sw	ra,28(sp)
80006f34:	afb20018 	sw	s2,24(sp)
80006f38:	afb10014 	sw	s1,20(sp)
80006f3c:	afb00010 	sw	s0,16(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
80006f40:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006f44:	00809021 	move	s2,a0
80006f48:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_sec*100 );
80006f4c:	00128880 	sll	s1,s2,0x2
80006f50:	00129100 	sll	s2,s2,0x4
80006f54:	02329021 	addu	s2,s1,s2
80006f58:	00128880 	sll	s1,s2,0x2
80006f5c:	02518821 	addu	s1,s2,s1
80006f60:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006f64:	00000000 	nop
80006f68:	00501023 	subu	v0,v0,s0
80006f6c:	0051102b 	sltu	v0,v0,s1
80006f70:	1440fffb 	bnez	v0,80006f60 <delay_sec+0x34>
80006f74:	8fbf001c 	lw	ra,28(sp)
}
80006f78:	8fb20018 	lw	s2,24(sp)
80006f7c:	8fb10014 	lw	s1,20(sp)
80006f80:	8fb00010 	lw	s0,16(sp)
80006f84:	03e00008 	jr	ra
80006f88:	27bd0020 	addiu	sp,sp,32

80006f8c <delay>:



//-----------------------------------------
void delay(unsigned int time_ms)
{
80006f8c:	27bdffe0 	addiu	sp,sp,-32
80006f90:	afbf001c 	sw	ra,28(sp)
80006f94:	afb10018 	sw	s1,24(sp)
80006f98:	afb00014 	sw	s0,20(sp)
   unsigned int preTime;
   
   preTime = get_timer_jiffies();
80006f9c:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006fa0:	00808821 	move	s1,a0
80006fa4:	00408021 	move	s0,v0
   while ( get_timer_jiffies()-preTime <  time_ms/10 );
80006fa8:	3c02cccc 	lui	v0,0xcccc
80006fac:	3442cccd 	ori	v0,v0,0xcccd
80006fb0:	02220019 	multu	s1,v0
80006fb4:	00008810 	mfhi	s1
80006fb8:	001188c2 	srl	s1,s1,0x3
80006fbc:	0c00325c 	jal	8000c970 <get_timer_jiffies>
80006fc0:	00000000 	nop
80006fc4:	00501023 	subu	v0,v0,s0
80006fc8:	0051102b 	sltu	v0,v0,s1
80006fcc:	1440fffb 	bnez	v0,80006fbc <delay+0x30>
80006fd0:	8fbf001c 	lw	ra,28(sp)
}
80006fd4:	8fb10018 	lw	s1,24(sp)
80006fd8:	8fb00014 	lw	s0,20(sp)
80006fdc:	03e00008 	jr	ra
80006fe0:	27bd0020 	addiu	sp,sp,32

80006fe4 <twiddle>:
**************************************************************************/

static int twiddle_count;

void twiddle(void)
{
80006fe4:	27bdffe8 	addiu	sp,sp,-24
80006fe8:	afbf0014 	sw	ra,20(sp)
	static const char tiddles[]="-\\|/";
	putchar(tiddles[(twiddle_count++)&3]);
80006fec:	3c028001 	lui	v0,0x8001
80006ff0:	8c434110 	lw	v1,16656(v0)
80006ff4:	30650003 	andi	a1,v1,0x3
80006ff8:	3c048001 	lui	a0,0x8001
80006ffc:	2484eb50 	addiu	a0,a0,-5296
80007000:	00a42021 	addu	a0,a1,a0
80007004:	80840000 	lb	a0,0(a0)
80007008:	24630001 	addiu	v1,v1,1
8000700c:	0c00197c 	jal	800065f0 <serial_outc>
80007010:	ac434110 	sw	v1,16656(v0)
	putchar('\b');
80007014:	0c00197c 	jal	800065f0 <serial_outc>
80007018:	24040008 	li	a0,8
}
8000701c:	8fbf0014 	lw	ra,20(sp)
80007020:	03e00008 	jr	ra
80007024:	27bd0018 	addiu	sp,sp,24

80007028 <vsprintf>:
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
80007028:	27bdffa8 	addiu	sp,sp,-88
8000702c:	afbf0054 	sw	ra,84(sp)
80007030:	afbe0050 	sw	s8,80(sp)
80007034:	afb7004c 	sw	s7,76(sp)
80007038:	afb60048 	sw	s6,72(sp)
8000703c:	afb50044 	sw	s5,68(sp)
80007040:	afb40040 	sw	s4,64(sp)
80007044:	afb3003c 	sw	s3,60(sp)
80007048:	afb20038 	sw	s2,56(sp)
8000704c:	afb10034 	sw	s1,52(sp)
80007050:	afb00030 	sw	s0,48(sp)
80007054:	0080a021 	move	s4,a0
80007058:	00a09021 	move	s2,a1
8000705c:	00c0b821 	move	s7,a2
80007060:	80a40000 	lb	a0,0(a1)
80007064:	10800098 	beqz	a0,800072c8 <vsprintf+0x2a0>
80007068:	02808821 	move	s1,s4
		if (*fmt != '%') {
8000706c:	24150025 	li	s5,37
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80007070:	27be0010 	addiu	s8,sp,16
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
80007074:	3c168001 	lui	s6,0x8001
80007078:	26d60950 	addiu	s6,s6,2384
					*q++ = '-';
					i = -i;
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
8000707c:	3c026666 	lui	v0,0x6666
80007080:	34426667 	ori	v0,v0,0x6667
80007084:	afa20028 	sw	v0,40(sp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
		if (*fmt != '%') {
80007088:	1095000a 	beq	a0,s5,800070b4 <vsprintf+0x8c>
8000708c:	24020073 	li	v0,115
			buf ? *s++ = *fmt : putchar(*fmt);
80007090:	12800004 	beqz	s4,800070a4 <vsprintf+0x7c>
80007094:	00000000 	nop
80007098:	a2240000 	sb	a0,0(s1)
8000709c:	08001cae 	j	800072b8 <vsprintf+0x290>
800070a0:	26310001 	addiu	s1,s1,1
800070a4:	0c00197c 	jal	800065f0 <serial_outc>
800070a8:	26520001 	addiu	s2,s2,1
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
800070ac:	08001cb0 	j	800072c0 <vsprintf+0x298>
800070b0:	82440000 	lb	a0,0(s2)
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
800070b4:	26520001 	addiu	s2,s2,1
800070b8:	82430000 	lb	v1,0(s2)
800070bc:	14620012 	bne	v1,v0,80007108 <vsprintf+0xe0>
800070c0:	00002021 	move	a0,zero
			for (p = (char *)*dp++; *p != '\0'; p++)
800070c4:	8ef00000 	lw	s0,0(s7)
800070c8:	82040000 	lb	a0,0(s0)
800070cc:	1080007a 	beqz	a0,800072b8 <vsprintf+0x290>
800070d0:	26f70004 	addiu	s7,s7,4
				buf ? *s++ = *p : putchar(*p);
800070d4:	12800004 	beqz	s4,800070e8 <vsprintf+0xc0>
800070d8:	00000000 	nop
800070dc:	a2240000 	sb	a0,0(s1)
800070e0:	08001c3c 	j	800070f0 <vsprintf+0xc8>
800070e4:	26310001 	addiu	s1,s1,1
800070e8:	0c00197c 	jal	800065f0 <serial_outc>
800070ec:	00000000 	nop
		if (*fmt != '%') {
			buf ? *s++ = *fmt : putchar(*fmt);
			continue;
		}
		if (*++fmt == 's') {
			for (p = (char *)*dp++; *p != '\0'; p++)
800070f0:	26100001 	addiu	s0,s0,1
800070f4:	82040000 	lb	a0,0(s0)
800070f8:	1480fff6 	bnez	a0,800070d4 <vsprintf+0xac>
800070fc:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
80007100:	08001caf 	j	800072bc <vsprintf+0x294>
80007104:	26520001 	addiu	s2,s2,1
			char tmp[20], *q = tmp;
			int alt = 0;
			int shift = 28;

#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
80007108:	306300ff 	andi	v1,v1,0xff
8000710c:	2465ffd0 	addiu	a1,v1,-48
80007110:	30a500ff 	andi	a1,a1,0xff
80007114:	2ca5000a 	sltiu	a1,a1,10
80007118:	10a0000f 	beqz	a1,80007158 <vsprintf+0x130>
8000711c:	2402001c 	li	v0,28
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
		                {    width = width * 10 + fch - '0';
80007120:	00041040 	sll	v0,a0,0x1
80007124:	000420c0 	sll	a0,a0,0x3
80007128:	00442021 	addu	a0,v0,a0
8000712c:	00831821 	addu	v1,a0,v1
80007130:	2464ffd0 	addiu	a0,v1,-48
#if 1   //wei patch for %02x
			if ((*fmt  >= '0') && (*fmt  <= '9'))
			{
				int width;
				unsigned char fch = *fmt;
		                for (width=0; (fch>='0') && (fch<='9'); fch=*++fmt)
80007134:	26520001 	addiu	s2,s2,1
80007138:	92430000 	lbu	v1,0(s2)
8000713c:	2462ffd0 	addiu	v0,v1,-48
80007140:	304200ff 	andi	v0,v0,0xff
80007144:	2c42000a 	sltiu	v0,v0,10
80007148:	1440fff6 	bnez	v0,80007124 <vsprintf+0xfc>
8000714c:	00041040 	sll	v0,a0,0x1
		                {    width = width * 10 + fch - '0';
		                }
				  shift=(width-1)*4;
80007150:	2482ffff 	addiu	v0,a0,-1
80007154:	00021080 	sll	v0,v0,0x2

			/*
			 * Before each format q points to tmp buffer
			 * After each format q points past end of item
			 */
			if ((*fmt == 'x')||(*fmt == 'X')) {
80007158:	82460000 	lb	a2,0(s2)
8000715c:	24030078 	li	v1,120
80007160:	10c30003 	beq	a2,v1,80007170 <vsprintf+0x148>
80007164:	24050058 	li	a1,88
80007168:	14c50012 	bne	a2,a1,800071b4 <vsprintf+0x18c>
8000716c:	00000000 	nop
				/* With x86 gcc, sizeof(long) == sizeof(int) */
				const long *lp = (const long *)dp;
				long h = *lp++;
80007170:	8ee40000 	lw	a0,0(s7)
80007174:	26e50004 	addiu	a1,s7,4
				int ncase = (*fmt & 0x20);
80007178:	30c60020 	andi	a2,a2,0x20
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
8000717c:	03c09821 	move	s3,s8
80007180:	0440004d 	bltz	v0,800072b8 <vsprintf+0x290>
80007184:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
80007188:	00441807 	srav	v1,a0,v0
8000718c:	3063000f 	andi	v1,v1,0xf
80007190:	00761821 	addu	v1,v1,s6
80007194:	90630000 	lbu	v1,0(v1)
80007198:	00661825 	or	v1,v1,a2
8000719c:	a2630000 	sb	v1,0(s3)
				dp = (const int *)lp;
				if (alt) {
					*q++ = '0';
					*q++ = 'X' | ncase;
				}
				for ( ; shift >= 0; shift -= 4)
800071a0:	2442fffc 	addiu	v0,v0,-4
800071a4:	0441fff8 	bgez	v0,80007188 <vsprintf+0x160>
800071a8:	26730001 	addiu	s3,s3,1
800071ac:	08001c9e 	j	80007278 <vsprintf+0x250>
800071b0:	00a0b821 	move	s7,a1
					*q++ = "0123456789ABCDEF"[(h >> shift) & 0xF] | ncase;
			}
			else if (*fmt == 'd') {
800071b4:	24020064 	li	v0,100
800071b8:	14c20028 	bne	a2,v0,8000725c <vsprintf+0x234>
800071bc:	24020063 	li	v0,99
				int i = *dp++;
800071c0:	8ee20000 	lw	v0,0(s7)
800071c4:	26f70004 	addiu	s7,s7,4
				char *r;
				if (i < 0) {
800071c8:	04410005 	bgez	v0,800071e0 <vsprintf+0x1b8>
800071cc:	03c02021 	move	a0,s8
					*q++ = '-';
800071d0:	2403002d 	li	v1,45
800071d4:	a3a30010 	sb	v1,16(sp)
					i = -i;
800071d8:	00021023 	negu	v0,v0
800071dc:	27a40011 	addiu	a0,sp,17
800071e0:	00809821 	move	s3,a0
				}
				p = q;		/* save beginning of digits */
				do {
					*q++ = '0' + (i % 10);
800071e4:	8fa50028 	lw	a1,40(sp)
800071e8:	00450018 	mult	v0,a1
800071ec:	00001810 	mfhi	v1
800071f0:	00031883 	sra	v1,v1,0x2
800071f4:	00022fc3 	sra	a1,v0,0x1f
800071f8:	00651823 	subu	v1,v1,a1
800071fc:	00033040 	sll	a2,v1,0x1
80007200:	000328c0 	sll	a1,v1,0x3
80007204:	00c52821 	addu	a1,a2,a1
80007208:	00451023 	subu	v0,v0,a1
8000720c:	24420030 	addiu	v0,v0,48
80007210:	a2620000 	sb	v0,0(s3)
80007214:	26730001 	addiu	s3,s3,1
					i /= 10;
				} while (i);
80007218:	1460fff2 	bnez	v1,800071e4 <vsprintf+0x1bc>
8000721c:	00601021 	move	v0,v1
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
80007220:	2662ffff 	addiu	v0,s3,-1
80007224:	0082182b 	sltu	v1,a0,v0
80007228:	10600013 	beqz	v1,80007278 <vsprintf+0x250>
8000722c:	00000000 	nop
					i = *r;
80007230:	80430000 	lb	v1,0(v0)
					*r = *p;
80007234:	90850000 	lbu	a1,0(a0)
80007238:	a0450000 	sb	a1,0(v0)
					*p++ = i;
8000723c:	a0830000 	sb	v1,0(a0)
80007240:	24840001 	addiu	a0,a0,1
					*q++ = '0' + (i % 10);
					i /= 10;
				} while (i);
				/* reverse digits, stop in middle */
				r = q;		/* don't alter q */
				while (--r > p) {
80007244:	2442ffff 	addiu	v0,v0,-1
80007248:	0082182b 	sltu	v1,a0,v0
8000724c:	1460fff8 	bnez	v1,80007230 <vsprintf+0x208>
80007250:	00000000 	nop
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80007254:	08001c9f 	j	8000727c <vsprintf+0x254>
80007258:	03d3102b 	sltu	v0,s8,s3
				for (r = p + ETH_ALEN; p < r; ++p)
					q += SprintF(q, "%hhX:", *p);
				--q;
			}
#endif			
			else if (*fmt == 'c')
8000725c:	14c20005 	bne	a2,v0,80007274 <vsprintf+0x24c>
80007260:	27b30011 	addiu	s3,sp,17
				*q++ = *dp++;
80007264:	8ee20000 	lw	v0,0(s7)
80007268:	a3a20010 	sb	v0,16(sp)
8000726c:	08001c9e 	j	80007278 <vsprintf+0x250>
80007270:	26f70004 	addiu	s7,s7,4
			else
				*q++ = *fmt;
80007274:	a3a60010 	sb	a2,16(sp)
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
80007278:	03d3102b 	sltu	v0,s8,s3
8000727c:	1040000e 	beqz	v0,800072b8 <vsprintf+0x290>
80007280:	00000000 	nop
80007284:	03c08021 	move	s0,s8
				buf ? *s++ = *p : putchar(*p);
80007288:	12800005 	beqz	s4,800072a0 <vsprintf+0x278>
8000728c:	00000000 	nop
80007290:	92020000 	lbu	v0,0(s0)
80007294:	a2220000 	sb	v0,0(s1)
80007298:	08001caa 	j	800072a8 <vsprintf+0x280>
8000729c:	26310001 	addiu	s1,s1,1
800072a0:	0c00197c 	jal	800065f0 <serial_outc>
800072a4:	82040000 	lb	a0,0(s0)
			else if (*fmt == 'c')
				*q++ = *dp++;
			else
				*q++ = *fmt;
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
800072a8:	26100001 	addiu	s0,s0,1
800072ac:	0213102b 	sltu	v0,s0,s3
800072b0:	1440fff5 	bnez	v0,80007288 <vsprintf+0x260>
800072b4:	00000000 	nop
int vsprintf(char *buf, const char *fmt, const int *dp)
{
	char *p, *s;

	s = buf;
	for ( ; *fmt != '\0'; ++fmt) {
800072b8:	26520001 	addiu	s2,s2,1
800072bc:	82440000 	lb	a0,0(s2)
800072c0:	1480ff71 	bnez	a0,80007088 <vsprintf+0x60>
800072c4:	00000000 	nop
			/* now output the saved string */
			for (p = tmp; p < q; ++p)
				buf ? *s++ = *p : putchar(*p);
		}
	}
	if (buf)
800072c8:	12800002 	beqz	s4,800072d4 <vsprintf+0x2ac>
800072cc:	02341023 	subu	v0,s1,s4
		*s = '\0';
800072d0:	a2200000 	sb	zero,0(s1)
	return (s - buf);
}
800072d4:	8fbf0054 	lw	ra,84(sp)
800072d8:	8fbe0050 	lw	s8,80(sp)
800072dc:	8fb7004c 	lw	s7,76(sp)
800072e0:	8fb60048 	lw	s6,72(sp)
800072e4:	8fb50044 	lw	s5,68(sp)
800072e8:	8fb40040 	lw	s4,64(sp)
800072ec:	8fb3003c 	lw	s3,60(sp)
800072f0:	8fb20038 	lw	s2,56(sp)
800072f4:	8fb10034 	lw	s1,52(sp)
800072f8:	8fb00030 	lw	s0,48(sp)
800072fc:	03e00008 	jr	ra
80007300:	27bd0058 	addiu	sp,sp,88

80007304 <dprintf>:
*/
#include <stdarg.h>


int dprintf(char *fmt, ...)
{
80007304:	27bdffe8 	addiu	sp,sp,-24
80007308:	afbf0014 	sw	ra,20(sp)
8000730c:	afa5001c 	sw	a1,28(sp)
80007310:	afa60020 	sw	a2,32(sp)
80007314:	afa70024 	sw	a3,36(sp)
80007318:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
8000731c:	00802821 	move	a1,a0
80007320:	00002021 	move	a0,zero
80007324:	0c001c0a 	jal	80007028 <vsprintf>
80007328:	27a6001c 	addiu	a2,sp,28
}
8000732c:	8fbf0014 	lw	ra,20(sp)
80007330:	03e00008 	jr	ra
80007334:	27bd0018 	addiu	sp,sp,24

80007338 <ddump>:
//----------------------------------------------------------------
//----------------------------------------------------------------

void ddump(unsigned char * pData, int len)
{
80007338:	27bdffc0 	addiu	sp,sp,-64
8000733c:	afbf003c 	sw	ra,60(sp)
80007340:	afbe0038 	sw	s8,56(sp)
80007344:	afb70034 	sw	s7,52(sp)
80007348:	afb60030 	sw	s6,48(sp)
8000734c:	afb5002c 	sw	s5,44(sp)
80007350:	afb40028 	sw	s4,40(sp)
80007354:	afb30024 	sw	s3,36(sp)
80007358:	afb20020 	sw	s2,32(sp)
8000735c:	afb1001c 	sw	s1,28(sp)
80007360:	afb00018 	sw	s0,24(sp)
80007364:	0080b821 	move	s7,a0
80007368:	afa50044 	sw	a1,68(sp)
	unsigned char *sbuf = pData;	
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );
8000736c:	3c048001 	lui	a0,0x8001
80007370:	0c001cc1 	jal	80007304 <dprintf>
80007374:	24840964 	addiu	a0,a0,2404

	while(i< length)
80007378:	8fa20044 	lw	v0,68(sp)
8000737c:	1840004d 	blez	v0,800074b4 <ddump+0x17c>
80007380:	0000f021 	move	s8,zero
80007384:	afa20010 	sw	v0,16(sp)
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
80007388:	3c138001 	lui	s3,0x8001
8000738c:	267309a8 	addiu	s3,s3,2472

			for(j=0;j<16-offset;j++)	//a last line
			dprintf("   ");
80007390:	3c148001 	lui	s4,0x8001
80007394:	26941878 	addiu	s4,s4,6264
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
80007398:	3c158001 	lui	s5,0x8001
8000739c:	26b523c0 	addiu	s5,s5,9152
			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
800073a0:	3c168001 	lui	s6,0x8001
800073a4:	26d609b8 	addiu	s6,s6,2488
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
	{		
			
			dprintf("%08X: ", (sbuf+i) );
800073a8:	3c048001 	lui	a0,0x8001
800073ac:	248409a0 	addiu	a0,a0,2464
800073b0:	0c001cc1 	jal	80007304 <dprintf>
800073b4:	02e02821 	move	a1,s7

			if(i+16 < length)
800073b8:	27de0010 	addiu	s8,s8,16
800073bc:	8fa30044 	lw	v1,68(sp)
800073c0:	03c3102a 	slt	v0,s8,v1
800073c4:	10400004 	beqz	v0,800073d8 <ddump+0xa0>
800073c8:	24120010 	li	s2,16
800073cc:	02e08021 	move	s0,s7
800073d0:	08001cfb 	j	800073ec <ddump+0xb4>
800073d4:	00008821 	move	s1,zero
800073d8:	8fb20010 	lw	s2,16(sp)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
800073dc:	1e40fffb 	bgtz	s2,800073cc <ddump+0x94>
800073e0:	24020010 	li	v0,16
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
800073e4:	08001d04 	j	80007410 <ddump+0xd8>
800073e8:	00528823 	subu	s1,v0,s2
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	
800073ec:	02602021 	move	a0,s3
800073f0:	0c001cc1 	jal	80007304 <dprintf>
800073f4:	92050000 	lbu	a1,0(s0)
				offset=16;
			else			
				offset=length-i;
			

			for(j=0; j<offset; j++)
800073f8:	26310001 	addiu	s1,s1,1
800073fc:	0232102a 	slt	v0,s1,s2
80007400:	1440fffa 	bnez	v0,800073ec <ddump+0xb4>
80007404:	26100001 	addiu	s0,s0,1
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
80007408:	24020010 	li	v0,16
8000740c:	00528823 	subu	s1,v0,s2
80007410:	1a200008 	blez	s1,80007434 <ddump+0xfc>
80007414:	3c048001 	lui	a0,0x8001
80007418:	00008021 	move	s0,zero
			dprintf("   ");
8000741c:	0c001cc1 	jal	80007304 <dprintf>
80007420:	02802021 	move	a0,s4
			

			for(j=0; j<offset; j++)
				dprintf("%02x ", sbuf[i+j]);	

			for(j=0;j<16-offset;j++)	//a last line
80007424:	26100001 	addiu	s0,s0,1
80007428:	0211102a 	slt	v0,s0,s1
8000742c:	1440fffb 	bnez	v0,8000741c <ddump+0xe4>
80007430:	3c048001 	lui	a0,0x8001
			dprintf("   ");


			dprintf("    ");		//between byte and char
80007434:	0c001cc1 	jal	80007304 <dprintf>
80007438:	248409b0 	addiu	a0,a0,2480
			
			for(j=0;  j<offset; j++)
8000743c:	1a400014 	blez	s2,80007490 <ddump+0x158>
80007440:	3c048001 	lui	a0,0x8001
80007444:	02e08021 	move	s0,s7
80007448:	00008821 	move	s1,zero
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
8000744c:	92050000 	lbu	a1,0(s0)
80007450:	24a2ffe0 	addiu	v0,a1,-32
80007454:	304200ff 	andi	v0,v0,0xff
80007458:	2c42005f 	sltiu	v0,v0,95
8000745c:	10400005 	beqz	v0,80007474 <ddump+0x13c>
80007460:	00000000 	nop
					dprintf("%c", sbuf[i+j]);
80007464:	0c001cc1 	jal	80007304 <dprintf>
80007468:	02c02021 	move	a0,s6
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
8000746c:	08001d20 	j	80007480 <ddump+0x148>
80007470:	26310001 	addiu	s1,s1,1
			{	
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
80007474:	0c001cc1 	jal	80007304 <dprintf>
80007478:	02a02021 	move	a0,s5
			dprintf("   ");


			dprintf("    ");		//between byte and char
			
			for(j=0;  j<offset; j++)
8000747c:	26310001 	addiu	s1,s1,1
80007480:	0232102a 	slt	v0,s1,s2
80007484:	1440fff1 	bnez	v0,8000744c <ddump+0x114>
80007488:	26100001 	addiu	s0,s0,1
				if( ' ' <= sbuf[i+j]  && sbuf[i+j] <= '~')
					dprintf("%c", sbuf[i+j]);
				else
					dprintf(".");
			}
			dprintf("\n\r");
8000748c:	3c048001 	lui	a0,0x8001
80007490:	0c001cc1 	jal	80007304 <dprintf>
80007494:	248409bc 	addiu	a0,a0,2492
80007498:	8fa30010 	lw	v1,16(sp)
8000749c:	2463fff0 	addiu	v1,v1,-16
800074a0:	afa30010 	sw	v1,16(sp)
	int length=len;

	int i=0,j,offset;
	dprintf(" [Addr]   .0 .1 .2 .3 .4 .5 .6 .7 .8 .9 .A .B .C .D .E .F\r\n" );

	while(i< length)
800074a4:	8fa30044 	lw	v1,68(sp)
800074a8:	03c3102a 	slt	v0,s8,v1
800074ac:	1440ffbe 	bnez	v0,800073a8 <ddump+0x70>
800074b0:	26f70010 	addiu	s7,s7,16

	//dprintf("\n\r");


	
}
800074b4:	8fbf003c 	lw	ra,60(sp)
800074b8:	8fbe0038 	lw	s8,56(sp)
800074bc:	8fb70034 	lw	s7,52(sp)
800074c0:	8fb60030 	lw	s6,48(sp)
800074c4:	8fb5002c 	lw	s5,44(sp)
800074c8:	8fb40028 	lw	s4,40(sp)
800074cc:	8fb30024 	lw	s3,36(sp)
800074d0:	8fb20020 	lw	s2,32(sp)
800074d4:	8fb1001c 	lw	s1,28(sp)
800074d8:	8fb00018 	lw	s0,24(sp)
800074dc:	03e00008 	jr	ra
800074e0:	27bd0040 	addiu	sp,sp,64

800074e4 <SprintF>:
{
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
}

int SprintF(char *buf, const char *fmt, ...)
{
800074e4:	27bdffe8 	addiu	sp,sp,-24
800074e8:	afbf0014 	sw	ra,20(sp)
800074ec:	afa60020 	sw	a2,32(sp)
800074f0:	afa70024 	sw	a3,36(sp)
800074f4:	afa5001c 	sw	a1,28(sp)
	return vsprintf(buf, fmt, ((const int *)&fmt)+1);
800074f8:	0c001c0a 	jal	80007028 <vsprintf>
800074fc:	27a60020 	addiu	a2,sp,32
}
80007500:	8fbf0014 	lw	ra,20(sp)
80007504:	03e00008 	jr	ra
80007508:	27bd0018 	addiu	sp,sp,24

8000750c <prom_printf>:
		*s = '\0';
	return (s - buf);
}

void prom_printf(const char *fmt, ...)
{
8000750c:	27bdffe8 	addiu	sp,sp,-24
80007510:	afbf0014 	sw	ra,20(sp)
80007514:	afa5001c 	sw	a1,28(sp)
80007518:	afa60020 	sw	a2,32(sp)
8000751c:	afa70024 	sw	a3,36(sp)
80007520:	afa40018 	sw	a0,24(sp)
	(void)vsprintf(0, fmt, ((const int *)&fmt)+1);	
80007524:	00802821 	move	a1,a0
80007528:	00002021 	move	a0,zero
8000752c:	0c001c0a 	jal	80007028 <vsprintf>
80007530:	27a6001c 	addiu	a2,sp,28
}
80007534:	8fbf0014 	lw	ra,20(sp)
80007538:	03e00008 	jr	ra
8000753c:	27bd0018 	addiu	sp,sp,24

80007540 <rtl8168_tx>:
//===============================================================================
void rtl8168_tx(unsigned char *content, unsigned int size, int portnum)
{
   unsigned int i;

   if ( (portnum == 0) || (portnum== 2) )
80007540:	10c00004 	beqz	a2,80007554 <rtl8168_tx+0x14>
80007544:	3c04a053 	lui	a0,0xa053
80007548:	24020002 	li	v0,2
8000754c:	14c2001b 	bne	a2,v0,800075bc <rtl8168_tx+0x7c>
80007550:	00000000 	nop
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX1_DESC_ADDR + 0x08, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
80007554:	34820008 	ori	v0,a0,0x8
80007558:	24035a00 	li	v1,23040
8000755c:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX1_DESC_ADDR + 0x18, htonl(PADDR(RX1_BUFF_ADDR)));  // RX Buffer Address
80007560:	34840018 	ori	a0,a0,0x18
80007564:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX1_DESC_ADDR + 0x8);
80007568:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x0C);
8000756c:	2403000c 	li	v1,12
80007570:	3c02b900 	lui	v0,0xb900
80007574:	34420037 	ori	v0,v0,0x37
80007578:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX1_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
8000757c:	00051a02 	srl	v1,a1,0x8
80007580:	3063ff00 	andi	v1,v1,0xff00
80007584:	30a2ff00 	andi	v0,a1,0xff00
80007588:	00021200 	sll	v0,v0,0x8
8000758c:	00621825 	or	v1,v1,v0
80007590:	00051600 	sll	v0,a1,0x18
80007594:	00621825 	or	v1,v1,v0
80007598:	7ca21e00 	ext	v0,a1,0x18,0x4
8000759c:	344200f0 	ori	v0,v0,0xf0
800075a0:	00621825 	or	v1,v1,v0
800075a4:	3c02a052 	lui	v0,0xa052
800075a8:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(TX1_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX1_BUFF_ADDR)));
800075ac:	34420008 	ori	v0,v0,0x8
800075b0:	24035800 	li	v1,22528
800075b4:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX1_DESC_ADDR + 0x8);
800075b8:	8c420000 	lw	v0,0(v0)
      }
      #endif
   }

  #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
800075bc:	24c6ffff 	addiu	a2,a2,-1
800075c0:	2cc60002 	sltiu	a2,a2,2
800075c4:	10c0001b 	beqz	a2,80007634 <rtl8168_tx+0xf4>
800075c8:	3c04a063 	lui	a0,0xa063
   {
      // Fill RX Descriptor
      WRITE_MEM32(RX2_DESC_ADDR + 0x08, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
800075cc:	34820008 	ori	v0,a0,0x8
800075d0:	24036a00 	li	v1,27136
800075d4:	ac430000 	sw	v1,0(v0)
      WRITE_MEM32(RX2_DESC_ADDR + 0x18, htonl(PADDR(RX2_BUFF_ADDR)));  // RX Buffer Address
800075d8:	34840018 	ori	a0,a0,0x18
800075dc:	ac830000 	sw	v1,0(a0)

      // Ensure Descriptor is updated
      READ_MEM32(RX2_DESC_ADDR + 0x8);
800075e0:	8c420000 	lw	v0,0(v0)

      // Enable TX/RX (This seems to trigger NIC prefetching RX descriptor)
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x0C);
800075e4:	2403000c 	li	v1,12
800075e8:	3c02ba00 	lui	v0,0xba00
800075ec:	34420037 	ori	v0,v0,0x37
800075f0:	a0430000 	sb	v1,0(v0)

      #if 1
      // Fill Descriptor
      WRITE_MEM32(TX2_DESC_ADDR + 0x0, htonl(DescOwn | FirstFrag | LastFrag | RingEnd | size));
800075f4:	00051a02 	srl	v1,a1,0x8
800075f8:	3063ff00 	andi	v1,v1,0xff00
800075fc:	30a2ff00 	andi	v0,a1,0xff00
80007600:	00021200 	sll	v0,v0,0x8
80007604:	00621025 	or	v0,v1,v0
80007608:	00051e00 	sll	v1,a1,0x18
8000760c:	00431025 	or	v0,v0,v1
80007610:	7ca51e00 	ext	a1,a1,0x18,0x4
80007614:	34a500f0 	ori	a1,a1,0xf0
80007618:	00452825 	or	a1,v0,a1
8000761c:	3c02a062 	lui	v0,0xa062
80007620:	ac450000 	sw	a1,0(v0)
      WRITE_MEM32(TX2_DESC_ADDR + 0x8, htonl(PADDR((unsigned int) TX2_BUFF_ADDR)));
80007624:	34420008 	ori	v0,v0,0x8
80007628:	24036800 	li	v1,26624
8000762c:	ac430000 	sw	v1,0(v0)

      // Ensure Descriptor is updated
      READ_MEM32(TX2_DESC_ADDR + 0x8);
80007630:	8c420000 	lw	v0,0(v0)
80007634:	03e00008 	jr	ra
80007638:	00000000 	nop

8000763c <rtl8168_tx_trigger>:
   return 0;
}
//===============================================================================
void rtl8168_tx_trigger(int portnum)
{
	if ((portnum == 0) |(portnum== 2) )   //Port 0
8000763c:	10800004 	beqz	a0,80007650 <rtl8168_tx_trigger+0x14>
80007640:	24030040 	li	v1,64
80007644:	24020002 	li	v0,2
80007648:	14820004 	bne	a0,v0,8000765c <rtl8168_tx_trigger+0x20>
8000764c:	00000000 	nop
	{		
		WRITE_MEM8(PCIE1_EP_MEM + TxPoll, 0x40);	// Indicate TX Packet
80007650:	3c02b900 	lui	v0,0xb900
80007654:	34420038 	ori	v0,v0,0x38
80007658:	a0430000 	sb	v1,0(v0)
	}
  
	if ((portnum == 1) |(portnum == 2) )   //PORT1
8000765c:	2484ffff 	addiu	a0,a0,-1
80007660:	2c840002 	sltiu	a0,a0,2
80007664:	10800004 	beqz	a0,80007678 <rtl8168_tx_trigger+0x3c>
80007668:	24030040 	li	v1,64
	{	     
	      WRITE_MEM8(PCIE2_EP_MEM + TxPoll, 0x40);	 // Indicate TX Packet
8000766c:	3c02ba00 	lui	v0,0xba00
80007670:	34420038 	ori	v0,v0,0x38
80007674:	a0430000 	sb	v1,0(v0)
80007678:	03e00008 	jr	ra
8000767c:	00000000 	nop

80007680 <PCIE_isr>:


volatile unsigned int grxok=0;
volatile unsigned int gtxok=0;
static void PCIE_isr(void)
{
80007680:	27bdffe8 	addiu	sp,sp,-24
80007684:	afbf0014 	sw	ra,20(sp)
80007688:	afb00010 	sw	s0,16(sp)
		addr=PCIE2_EP_MEM;
	}


//	printf("PCIE ISR\n");	
	unsigned int r=READ_MEM16(addr + IntrStatus);
8000768c:	3c02b900 	lui	v0,0xb900
80007690:	3442003e 	ori	v0,v0,0x3e
80007694:	94500000 	lhu	s0,0(v0)
80007698:	3210ffff 	andi	s0,s0,0xffff
	if((r==0) || (r==0xffff))
8000769c:	12000041 	beqz	s0,800077a4 <PCIE_isr+0x124>
800076a0:	3402ffff 	li	v0,0xffff
800076a4:	12020040 	beq	s0,v0,800077a8 <PCIE_isr+0x128>
800076a8:	8fbf0014 	lw	ra,20(sp)
		return 0;
	
	printf("\n=>ISR=%x \n", r);
800076ac:	3c048001 	lui	a0,0x8001
800076b0:	248409c0 	addiu	a0,a0,2496
800076b4:	0c001cc1 	jal	80007304 <dprintf>
800076b8:	02002821 	move	a1,s0

	if(r & RxOK)   // bit 0
800076bc:	32020001 	andi	v0,s0,0x1
800076c0:	10400008 	beqz	v0,800076e4 <PCIE_isr+0x64>
800076c4:	32020002 	andi	v0,s0,0x2
	{
		printf("RxOK\n");	
800076c8:	3c048001 	lui	a0,0x8001
800076cc:	0c001cc1 	jal	80007304 <dprintf>
800076d0:	248409cc 	addiu	a0,a0,2508
		grxok=1;
800076d4:	24030001 	li	v1,1
800076d8:	3c028001 	lui	v0,0x8001
800076dc:	ac434120 	sw	v1,16672(v0)
	}
	if(r &RxErr)   // bit 1
800076e0:	32020002 	andi	v0,s0,0x2
800076e4:	10400005 	beqz	v0,800076fc <PCIE_isr+0x7c>
800076e8:	32020004 	andi	v0,s0,0x4
	{
		printf("RxErr\n");	
800076ec:	3c048001 	lui	a0,0x8001
800076f0:	0c001cc1 	jal	80007304 <dprintf>
800076f4:	248409d4 	addiu	a0,a0,2516
	}
	if(r & TxOK)   //bit 2
800076f8:	32020004 	andi	v0,s0,0x4
800076fc:	10400008 	beqz	v0,80007720 <PCIE_isr+0xa0>
80007700:	32020008 	andi	v0,s0,0x8
	{
		printf("TxOK\n");	
80007704:	3c048001 	lui	a0,0x8001
80007708:	0c001cc1 	jal	80007304 <dprintf>
8000770c:	248409dc 	addiu	a0,a0,2524
		gtxok=1;
80007710:	24030001 	li	v1,1
80007714:	3c028001 	lui	v0,0x8001
80007718:	ac434124 	sw	v1,16676(v0)
	}
	if(r &TxErr)  //bit 3
8000771c:	32020008 	andi	v0,s0,0x8
80007720:	10400005 	beqz	v0,80007738 <PCIE_isr+0xb8>
80007724:	32020010 	andi	v0,s0,0x10
	{
		printf("TxErr\n");	
80007728:	3c048001 	lui	a0,0x8001
8000772c:	0c001cc1 	jal	80007304 <dprintf>
80007730:	248409e4 	addiu	a0,a0,2532
	}
	
	if(r & RxDescUnavail)  //bit 4
80007734:	32020010 	andi	v0,s0,0x10
80007738:	10400005 	beqz	v0,80007750 <PCIE_isr+0xd0>
8000773c:	32020020 	andi	v0,s0,0x20
	{
		printf("RxDescUnavail\n");	
80007740:	3c048001 	lui	a0,0x8001
80007744:	0c001cc1 	jal	80007304 <dprintf>
80007748:	248409ec 	addiu	a0,a0,2540
	}
	if(r &LinkChg)   //bit 5
8000774c:	32020020 	andi	v0,s0,0x20
80007750:	10400005 	beqz	v0,80007768 <PCIE_isr+0xe8>
80007754:	32020040 	andi	v0,s0,0x40
	{
		printf("LinkChg\n");	
80007758:	3c048001 	lui	a0,0x8001
8000775c:	0c001cc1 	jal	80007304 <dprintf>
80007760:	248409fc 	addiu	a0,a0,2556
	}
	if(r &RxFIFOOver)   //bit 6
80007764:	32020040 	andi	v0,s0,0x40
80007768:	10400004 	beqz	v0,8000777c <PCIE_isr+0xfc>
8000776c:	00000000 	nop
	{
		printf("RxFIFOOver\n");	
80007770:	3c048001 	lui	a0,0x8001
80007774:	0c001cc1 	jal	80007304 <dprintf>
80007778:	24840a08 	addiu	a0,a0,2568
	}	
	if(r &TxDescUnavail)   //bit 7
8000777c:	32100080 	andi	s0,s0,0x80
80007780:	12000005 	beqz	s0,80007798 <PCIE_isr+0x118>
80007784:	2403ffff 	li	v1,-1
	{
		printf("TxDescUnavail\n");	
80007788:	3c048001 	lui	a0,0x8001
8000778c:	0c001cc1 	jal	80007304 <dprintf>
80007790:	24840a14 	addiu	a0,a0,2580
	{
		printf("SYSErr\n");	
	}		
*/
	
	WRITE_MEM16(addr + IntrStatus, 0xffff);
80007794:	2403ffff 	li	v1,-1
80007798:	3c02b900 	lui	v0,0xb900
8000779c:	3442003e 	ori	v0,v0,0x3e
800077a0:	a4430000 	sh	v1,0(v0)
}
800077a4:	8fbf0014 	lw	ra,20(sp)
800077a8:	8fb00010 	lw	s0,16(sp)
800077ac:	03e00008 	jr	ra
800077b0:	27bd0018 	addiu	sp,sp,24

800077b4 <rtl8168_rx>:
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
{
800077b4:	27bdffc8 	addiu	sp,sp,-56
800077b8:	afbf0034 	sw	ra,52(sp)
800077bc:	afb50030 	sw	s5,48(sp)
800077c0:	afb4002c 	sw	s4,44(sp)
800077c4:	afb30028 	sw	s3,40(sp)
800077c8:	afb20024 	sw	s2,36(sp)
800077cc:	afb10020 	sw	s1,32(sp)
800077d0:	afb0001c 	sw	s0,28(sp)
800077d4:	00809021 	move	s2,a0
800077d8:	00a08821 	move	s1,a1
800077dc:	00c09821 	move	s3,a2
 

   
   
  #if DBG	  
     prom_printf("\nTest Rx Bytes=%d\n",size); //OK   
800077e0:	3c048001 	lui	a0,0x8001
800077e4:	0c001d43 	jal	8000750c <prom_printf>
800077e8:	24840a24 	addiu	a0,a0,2596
     prom_printf("P0 PCIE Error count: %d\n",P0_PCIE_error_count);
800077ec:	3c048001 	lui	a0,0x8001
800077f0:	24840a38 	addiu	a0,a0,2616
800077f4:	0c001d43 	jal	8000750c <prom_printf>
800077f8:	00002821 	move	a1,zero
  #if (TEST_8196_PCIE_P1) 
     prom_printf("P1 PCIE Error count: %d\n",P1_PCIE_error_count);
800077fc:	3c048001 	lui	a0,0x8001
80007800:	24840a54 	addiu	a0,a0,2644
80007804:	0c001d43 	jal	8000750c <prom_printf>
80007808:	00002821 	move	a1,zero
  #endif
  #endif 
   
  
    if ((portnum == 0) || (portnum == 2) )
8000780c:	12600004 	beqz	s3,80007820 <rtl8168_rx+0x6c>
80007810:	3c03a053 	lui	v1,0xa053
80007814:	24020002 	li	v0,2
80007818:	16620055 	bne	s3,v0,80007970 <rtl8168_rx+0x1bc>
8000781c:	00000000 	nop
   {
      // Wait RX Packet   
		  //loop here when OWN bit=1 (means Memory is owned by PCIE IP)
		 //dprintf("Wait Rx own bit \n");
		  while ((READ_MEM32(RX1_DESC_ADDR) & htonl(DescOwn)) != 0)
80007820:	8c620000 	lw	v0,0(v1)
80007824:	30420080 	andi	v0,v0,0x80
80007828:	1440fffd 	bnez	v0,80007820 <rtl8168_rx+0x6c>
8000782c:	00000000 	nop
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
80007830:	1220004f 	beqz	s1,80007970 <rtl8168_rx+0x1bc>
80007834:	3c02a05a 	lui	v0,0xa05a
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
80007838:	90430000 	lbu	v1,0(v0)
8000783c:	306300ff 	andi	v1,v1,0xff
80007840:	92420000 	lbu	v0,0(s2)
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
80007844:	00008021 	move	s0,zero
      int i2;
	   
      for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
80007848:	10620045 	beq	v1,v0,80007960 <rtl8168_rx+0x1ac>
8000784c:	3c05a05a 	lui	a1,0xa05a
80007850:	08001e1d 	j	80007874 <rtl8168_rx+0xc0>
80007854:	3c03a05a 	lui	v1,0xa05a
80007858:	90640000 	lbu	a0,0(v1)
8000785c:	308400ff 	andi	a0,a0,0xff
80007860:	02501021 	addu	v0,s2,s0
80007864:	90420000 	lbu	v0,0(v0)
80007868:	1082003e 	beq	a0,v0,80007964 <rtl8168_rx+0x1b0>
8000786c:	26100001 	addiu	s0,s0,1
80007870:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
80007874:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX1_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
80007878:	afa20010 	sw	v0,16(sp)
8000787c:	3c048001 	lui	a0,0x8001
80007880:	24840a70 	addiu	a0,a0,2672
80007884:	02202821 	move	a1,s1
80007888:	02003021 	move	a2,s0
8000788c:	0c001d43 	jal	8000750c <prom_printf>
80007890:	30e700ff 	andi	a3,a3,0xff
80007894:	3c13a05a 	lui	s3,0xa05a
80007898:	36710001 	ori	s1,s3,0x1
8000789c:	02118821 	addu	s1,s0,s1
800078a0:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
800078a4:	36730005 	ori	s3,s3,0x5
800078a8:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i2),READ_MEM8(RX1_BUFF_ADDR + i+i2),content[i+i2]);
800078ac:	3c145fa6 	lui	s4,0x5fa6
800078b0:	3c158001 	lui	s5,0x8001
800078b4:	26b50ac0 	addiu	s5,s5,2752
800078b8:	92260000 	lbu	a2,0(s1)
800078bc:	02a02021 	move	a0,s5
800078c0:	02342821 	addu	a1,s1,s4
800078c4:	30c600ff 	andi	a2,a2,0xff
800078c8:	0c001d43 	jal	8000750c <prom_printf>
800078cc:	92470001 	lbu	a3,1(s2)
800078d0:	26310001 	addiu	s1,s1,1
		  P0_PCIE_error_count++;
		     		  
	         prom_printf("Compare Error, No: Port0, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X \n",
	                     size, i, READ_MEM8(RX1_BUFF_ADDR + i), content[i]);
		   
		   for (i2=1;i2<=4;i2++)
800078d4:	1633fff8 	bne	s1,s3,800078b8 <rtl8168_rx+0x104>
800078d8:	26520001 	addiu	s2,s2,1

		   }
		   
		  
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n==================================\n");
800078dc:	3c118001 	lui	s1,0x8001
800078e0:	0c001d43 	jal	8000750c <prom_printf>
800078e4:	26240ae4 	addiu	a0,s1,2788
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0420000+i),READ_MEM32(0xa0420000+i));
800078e8:	3c05a042 	lui	a1,0xa042
800078ec:	02052821 	addu	a1,s0,a1
800078f0:	8ca60000 	lw	a2,0(a1)
800078f4:	3c048001 	lui	a0,0x8001
800078f8:	0c001d43 	jal	8000750c <prom_printf>
800078fc:	24840b0c 	addiu	a0,a0,2828
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0630000+i),READ_MEM32(0xa0630000+i));
80007900:	3c05a063 	lui	a1,0xa063
80007904:	02052821 	addu	a1,s0,a1
80007908:	8ca60000 	lw	a2,0(a1)
8000790c:	3c048001 	lui	a0,0x8001
80007910:	0c001d43 	jal	8000750c <prom_printf>
80007914:	24840b28 	addiu	a0,a0,2856
		   prom_printf("\n==================================\n");
80007918:	0c001d43 	jal	8000750c <prom_printf>
8000791c:	26240ae4 	addiu	a0,s1,2788

		
		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0420000+i-4),READ_MEM32(0xa0420000+i-4));
80007920:	3c05a041 	lui	a1,0xa041
80007924:	34a5fffc 	ori	a1,a1,0xfffc
80007928:	02052821 	addu	a1,s0,a1
8000792c:	8ca60000 	lw	a2,0(a1)
80007930:	3c048001 	lui	a0,0x8001
80007934:	0c001d43 	jal	8000750c <prom_printf>
80007938:	24840b44 	addiu	a0,a0,2884
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0630000+i-4),READ_MEM32(0xa0630000+i-4));
8000793c:	3c05a062 	lui	a1,0xa062
80007940:	34a5fffc 	ori	a1,a1,0xfffc
80007944:	02052821 	addu	a1,s0,a1
80007948:	8ca60000 	lw	a2,0(a1)
8000794c:	3c048001 	lui	a0,0x8001
80007950:	0c001d43 	jal	8000750c <prom_printf>
80007954:	24840b70 	addiu	a0,a0,2928
		   
		   
		 //#if 1 //for 2 port
		 		 	
		 	return -1; // RX Error
80007958:	08001eb8 	j	80007ae0 <rtl8168_rx+0x32c>
8000795c:	2402ffff 	li	v0,-1
		 //dprintf("got Rx own bit \n");
		 
      // Check RX Packet Content
      int i2;
	   
      for (i = 0; i < size; i++)        
80007960:	26100001 	addiu	s0,s0,1
80007964:	0211102b 	sltu	v0,s0,s1
80007968:	1440ffbb 	bnez	v0,80007858 <rtl8168_rx+0xa4>
8000796c:	02051821 	addu	v1,s0,a1
         }
      }
   }
//-------------------------------------------------
  #if (TEST_8196_PCIE_P1)
    if( (portnum == 1) || (portnum == 2) )//PORT1
80007970:	2673ffff 	addiu	s3,s3,-1
80007974:	2e730002 	sltiu	s3,s3,2
80007978:	12600059 	beqz	s3,80007ae0 <rtl8168_rx+0x32c>
8000797c:	00001021 	move	v0,zero
				   break;
			    }
	      }		 	 
	    
	#else
		  while ((READ_MEM32(RX2_DESC_ADDR) & htonl(DescOwn)) != 0);
80007980:	3c03a063 	lui	v1,0xa063
80007984:	8c620000 	lw	v0,0(v1)
80007988:	30420080 	andi	v0,v0,0x80
8000798c:	1440fffd 	bnez	v0,80007984 <rtl8168_rx+0x1d0>
80007990:	00000000 	nop
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
80007994:	12200051 	beqz	s1,80007adc <rtl8168_rx+0x328>
80007998:	3c02a06a 	lui	v0,0xa06a
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
8000799c:	90430000 	lbu	v1,0(v0)
800079a0:	306300ff 	andi	v1,v1,0xff
800079a4:	92420000 	lbu	v0,0(s2)
		   prom_printf("\n================================================\n");

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
		   prom_printf("\n================================================\n");
		   return -1;
800079a8:	00008021 	move	s0,zero
       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
      {
      
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
800079ac:	10620047 	beq	v1,v0,80007acc <rtl8168_rx+0x318>
800079b0:	3c05a06a 	lui	a1,0xa06a
800079b4:	08001e76 	j	800079d8 <rtl8168_rx+0x224>
800079b8:	3c03a06a 	lui	v1,0xa06a
800079bc:	90640000 	lbu	a0,0(v1)
800079c0:	308400ff 	andi	a0,a0,0xff
800079c4:	02501021 	addu	v0,s2,s0
800079c8:	90420000 	lbu	v0,0(v0)
800079cc:	10820040 	beq	a0,v0,80007ad0 <rtl8168_rx+0x31c>
800079d0:	26100001 	addiu	s0,s0,1
800079d4:	2610ffff 	addiu	s0,s0,-1
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
800079d8:	90670000 	lbu	a3,0(v1)
         if (READ_MEM8(RX2_BUFF_ADDR + i) != content[i])
         {
           #if DBG//JSW:DEBUG_PRINT
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
800079dc:	afa20010 	sw	v0,16(sp)
800079e0:	3c048001 	lui	a0,0x8001
800079e4:	24840b9c 	addiu	a0,a0,2972
800079e8:	02202821 	move	a1,s1
800079ec:	02003021 	move	a2,s0
800079f0:	0c001d43 	jal	8000750c <prom_printf>
800079f4:	30e700ff 	andi	a3,a3,0xff
800079f8:	3c13a06a 	lui	s3,0xa06a
800079fc:	36710001 	ori	s1,s3,0x1
80007a00:	02118821 	addu	s1,s0,s1
80007a04:	02509021 	addu	s2,s2,s0
}
//===============================================================================

 

int rtl8168_rx(unsigned char *content, unsigned int size, int portnum)
80007a08:	36730005 	ori	s3,s3,0x5
80007a0c:	02139821 	addu	s3,s0,s3
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
		   {
		   	 prom_printf("\nOffset(%d),Content:%x,Expected:%x\n",(i+i3),READ_MEM8(RX2_BUFF_ADDR + i+i3),content[i+i3]);
80007a10:	3c145f96 	lui	s4,0x5f96
80007a14:	3c158001 	lui	s5,0x8001
80007a18:	26b50ac0 	addiu	s5,s5,2752
80007a1c:	92260000 	lbu	a2,0(s1)
80007a20:	02a02021 	move	a0,s5
80007a24:	02342821 	addu	a1,s1,s4
80007a28:	30c600ff 	andi	a2,a2,0xff
80007a2c:	0c001d43 	jal	8000750c <prom_printf>
80007a30:	92470001 	lbu	a3,1(s2)
80007a34:	26310001 	addiu	s1,s1,1
		   P1_PCIE_error_count++;	
		  
	         prom_printf("Compare Error, No: Port1, Size: %d, Offset: %d, Content: 0x%X, Expected: 0x%X\n",
	                     size, i, READ_MEM8(RX2_BUFF_ADDR + i), content[i]);
		   //prom_printf("PCIE Mac LoopBack Compare Error!!! \n");
		   for (i3=1;i3<=4;i3++)
80007a38:	1633fff8 	bne	s1,s3,80007a1c <rtl8168_rx+0x268>
80007a3c:	26520001 	addiu	s2,s2,1
		   }
		   		   
			  
  		   
		   //prom_printf("\ncontent=%x\n",&content);
		   prom_printf("\n================================================\n");
80007a40:	3c118001 	lui	s1,0x8001
80007a44:	0c001d43 	jal	8000750c <prom_printf>
80007a48:	26240bec 	addiu	a0,s1,3052
		   prom_printf("\nOK Tx(0x%x) content=%x\n",(0xa0820000+i),READ_MEM32(0xa0820000+i));
80007a4c:	3c05a082 	lui	a1,0xa082
80007a50:	02052821 	addu	a1,s0,a1
80007a54:	8ca60000 	lw	a2,0(a1)
80007a58:	3c048001 	lui	a0,0x8001
80007a5c:	0c001d43 	jal	8000750c <prom_printf>
80007a60:	24840b0c 	addiu	a0,a0,2828
		   prom_printf("\nFail Rx(0x%x) content=%x\n",(0xa0a30000+i),READ_MEM32(0xa0a30000+i));
80007a64:	3c05a0a3 	lui	a1,0xa0a3
80007a68:	02052821 	addu	a1,s0,a1
80007a6c:	8ca60000 	lw	a2,0(a1)
80007a70:	3c048001 	lui	a0,0x8001
80007a74:	0c001d43 	jal	8000750c <prom_printf>
80007a78:	24840b28 	addiu	a0,a0,2856
		   prom_printf("\n================================================\n");
80007a7c:	0c001d43 	jal	8000750c <prom_printf>
80007a80:	26240bec 	addiu	a0,s1,3052

		   prom_printf("\nCheck last 4 Bytes,Tx(0x%x) content=%x\n",(0xa0820000+i-4),READ_MEM32(0xa0820000+i-4));
80007a84:	3c05a081 	lui	a1,0xa081
80007a88:	34a5fffc 	ori	a1,a1,0xfffc
80007a8c:	02052821 	addu	a1,s0,a1
80007a90:	8ca60000 	lw	a2,0(a1)
80007a94:	3c048001 	lui	a0,0x8001
80007a98:	0c001d43 	jal	8000750c <prom_printf>
80007a9c:	24840b44 	addiu	a0,a0,2884
		   prom_printf("\nCheck last 4 Bytes,Rx(0x%x) content=%x\n",(0xa0a30000+i-4),READ_MEM32(0xa0a30000+i-4));
80007aa0:	3c05a0a2 	lui	a1,0xa0a2
80007aa4:	34a5fffc 	ori	a1,a1,0xfffc
80007aa8:	02052821 	addu	a1,s0,a1
80007aac:	8ca60000 	lw	a2,0(a1)
80007ab0:	3c048001 	lui	a0,0x8001
80007ab4:	0c001d43 	jal	8000750c <prom_printf>
80007ab8:	24840b70 	addiu	a0,a0,2928
		   prom_printf("\n================================================\n");
80007abc:	0c001d43 	jal	8000750c <prom_printf>
80007ac0:	26240bec 	addiu	a0,s1,3052
		   return -1;
80007ac4:	08001eb8 	j	80007ae0 <rtl8168_rx+0x32c>
80007ac8:	2402ffff 	li	v0,-1
#endif
       #endif

       int i3;
      // Check RX Packet Content
        for (i = 0; i < size; i++)        
80007acc:	26100001 	addiu	s0,s0,1
80007ad0:	0211102b 	sltu	v0,s0,s1
80007ad4:	1440ffb9 	bnez	v0,800079bc <rtl8168_rx+0x208>
80007ad8:	02051821 	addu	v1,s0,a1
80007adc:	00001021 	move	v0,zero
      }
   }
 #endif

   return 0;
}
80007ae0:	8fbf0034 	lw	ra,52(sp)
80007ae4:	8fb50030 	lw	s5,48(sp)
80007ae8:	8fb4002c 	lw	s4,44(sp)
80007aec:	8fb30028 	lw	s3,40(sp)
80007af0:	8fb20024 	lw	s2,36(sp)
80007af4:	8fb10020 	lw	s1,32(sp)
80007af8:	8fb0001c 	lw	s0,28(sp)
80007afc:	03e00008 	jr	ra
80007b00:	27bd0038 	addiu	sp,sp,56

80007b04 <EnIRQ>:
#define NULL 0
struct irqaction irq_PCIE = {PCIE_isr, (unsigned long)NULL, (unsigned long)PCIE_IRQ_NO,"PCIE", (void *)NULL, (struct irqaction *)NULL};   


void EnIRQ(int portnum, int enableirq)
{
80007b04:	27bdffe8 	addiu	sp,sp,-24
80007b08:	afbf0014 	sw	ra,20(sp)
	unsigned int addr;
	if(portnum==0)
80007b0c:	3c02ba00 	lui	v0,0xba00
80007b10:	3c03b900 	lui	v1,0xb900
	{
		addr=PCIE2_EP_MEM;
	}

	
	if(enableirq)
80007b14:	10a00017 	beqz	a1,80007b74 <EnIRQ+0x70>
80007b18:	0064100a 	movz	v0,v1,a0
	{

		WRITE_MEM16(addr + IntrMask, 0xffff);
80007b1c:	2442003c 	addiu	v0,v0,60
80007b20:	2403ffff 	li	v1,-1
80007b24:	a4430000 	sh	v1,0(v0)

		
		int irraddr=IRR_REG+PCIE_IRR_NO*4;		
	  	REG32(irraddr) = (REG32(irraddr) &~(0x0f<<PCIE_IRR_OFFSET)) | (4<<PCIE_IRR_OFFSET);	
80007b28:	3c02b800 	lui	v0,0xb800
80007b2c:	34423010 	ori	v0,v0,0x3010
80007b30:	8c440000 	lw	a0,0(v0)
80007b34:	3c03ff0f 	lui	v1,0xff0f
80007b38:	3463ffff 	ori	v1,v1,0xffff
80007b3c:	00831824 	and	v1,a0,v1
80007b40:	3c040040 	lui	a0,0x40
80007b44:	00641825 	or	v1,v1,a0
80007b48:	ac430000 	sw	v1,0(v0)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
80007b4c:	24040015 	li	a0,21
80007b50:	3c058001 	lui	a1,0x8001
80007b54:	24a52df0 	addiu	a1,a1,11760
80007b58:	0c000274 	jal	800009d0 <request_IRQ>
80007b5c:	00003021 	move	a2,zero
		dprintf("Enable PCIE ISR \n");
80007b60:	3c048001 	lui	a0,0x8001
80007b64:	0c001cc1 	jal	80007304 <dprintf>
80007b68:	24840c20 	addiu	a0,a0,3104
		WRITE_MEM16(addr + IntrMask, 0);
		free_IRQ(PCIE_IRQ_NO);
		dprintf("Disable PCIE ISR\r\n");

	}
}
80007b6c:	08001ee5 	j	80007b94 <EnIRQ+0x90>
80007b70:	8fbf0014 	lw	ra,20(sp)
		request_IRQ(PCIE_IRQ_NO, &irq_PCIE, NULL); 
		dprintf("Enable PCIE ISR \n");
	}
	else
	{
		WRITE_MEM16(addr + IntrMask, 0);
80007b74:	2442003c 	addiu	v0,v0,60
80007b78:	a4400000 	sh	zero,0(v0)
		free_IRQ(PCIE_IRQ_NO);
80007b7c:	0c000289 	jal	80000a24 <free_IRQ>
80007b80:	24040015 	li	a0,21
		dprintf("Disable PCIE ISR\r\n");
80007b84:	3c048001 	lui	a0,0x8001
80007b88:	0c001cc1 	jal	80007304 <dprintf>
80007b8c:	24840c34 	addiu	a0,a0,3124

	}
}
80007b90:	8fbf0014 	lw	ra,20(sp)
80007b94:	03e00008 	jr	ra
80007b98:	27bd0018 	addiu	sp,sp,24

80007b9c <rtl8168_init>:

	
}
//===============================================================================
void rtl8168_init(int portnum, int en_loopback)
{
80007b9c:	27bdffe0 	addiu	sp,sp,-32
80007ba0:	afbf001c 	sw	ra,28(sp)
80007ba4:	afb10018 	sw	s1,24(sp)
80007ba8:	afb00014 	sw	s0,20(sp)
80007bac:	00808021 	move	s0,a0
   int i;

   if( (portnum == 0) || (portnum == 2) )
80007bb0:	10800004 	beqz	a0,80007bc4 <rtl8168_init+0x28>
80007bb4:	00a08821 	move	s1,a1
80007bb8:	24020002 	li	v0,2
80007bbc:	14820088 	bne	a0,v0,80007de0 <rtl8168_init+0x244>
80007bc0:	00000000 	nop
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE1_RC_CFG + 0x04, 0x00100007);
80007bc4:	3c04b8b0 	lui	a0,0xb8b0
80007bc8:	34820004 	ori	v0,a0,0x4
80007bcc:	3c030010 	lui	v1,0x10
80007bd0:	34630007 	ori	v1,v1,0x7
80007bd4:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B,default
80007bd8:	3c02b8b1 	lui	v0,0xb8b1
80007bdc:	34430078 	ori	v1,v0,0x78
80007be0:	90650000 	lbu	a1,0(v1)
80007be4:	30a5001f 	andi	a1,a1,0x1f
80007be8:	34840078 	ori	a0,a0,0x78
80007bec:	a0850000 	sb	a1,0(a0)
      //WRITE_MEM8(PCIE1_RC_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_256B);  // Set MAX_PAYLOAD_SIZE to 256B

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE1_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
80007bf0:	34440004 	ori	a0,v0,0x4
80007bf4:	3c050018 	lui	a1,0x18
80007bf8:	34a50007 	ori	a1,a1,0x7
80007bfc:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x10, (PCIE1_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
80007c00:	34440010 	ori	a0,v0,0x10
80007c04:	3c0518c0 	lui	a1,0x18c0
80007c08:	34a50001 	ori	a1,a1,0x1
80007c0c:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE1_EP_CFG + 0x18, (PCIE1_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
80007c10:	34440018 	ori	a0,v0,0x18
80007c14:	3c051900 	lui	a1,0x1900
80007c18:	34a50004 	ori	a1,a1,0x4
80007c1c:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE1_EP_CFG + 0x78, (READ_MEM8(PCIE1_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
80007c20:	90640000 	lbu	a0,0(v1)
80007c24:	3084001f 	andi	a0,a0,0x1f
80007c28:	a0640000 	sb	a0,0(v1)
     // WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_128B);  // Set MAX_REQ_SIZE to 128B 
      WRITE_MEM8(PCIE1_EP_CFG + 0x79, (READ_MEM8(PCIE1_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 256B,default
80007c2c:	34420079 	ori	v0,v0,0x79
80007c30:	90430000 	lbu	v1,0(v0)
80007c34:	2404ff8f 	li	a0,-113
80007c38:	00831824 	and	v1,a0,v1
80007c3c:	34630010 	ori	v1,v1,0x10
80007c40:	306300ff 	andi	v1,v1,0xff
80007c44:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);
80007c48:	24030010 	li	v1,16
80007c4c:	3c02b900 	lui	v0,0xb900
80007c50:	34420037 	ori	v0,v0,0x37
80007c54:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
80007c58:	1220000c 	beqz	s1,80007c8c <rtl8168_init+0xf0>
80007c5c:	3c02b900 	lui	v0,0xb900
80007c60:	34420040 	ori	v0,v0,0x40
80007c64:	8c440000 	lw	a0,0(v0)
80007c68:	3c03fffc 	lui	v1,0xfffc
80007c6c:	3463f8ff 	ori	v1,v1,0xf8ff
80007c70:	00832024 	and	a0,a0,v1
80007c74:	3c030003 	lui	v1,0x3
80007c78:	34630600 	ori	v1,v1,0x600
80007c7c:	00831825 	or	v1,a0,v1
80007c80:	ac430000 	sw	v1,0(v0)
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80007c84:	08001f2a 	j	80007ca8 <rtl8168_init+0x10c>
80007c88:	3c02b900 	lui	v0,0xb900
      // 2. Reset EP
      WRITE_MEM8(PCIE1_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
      if(en_loopback)      WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));  //wei del
     else 				     WRITE_MEM32(PCIE1_EP_MEM + TxConfig, (READ_MEM32(PCIE1_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (0 << 16));
80007c8c:	34420040 	ori	v0,v0,0x40
80007c90:	8c440000 	lw	a0,0(v0)
80007c94:	2403f8ff 	li	v1,-1793
80007c98:	00831824 	and	v1,a0,v1
80007c9c:	34630600 	ori	v1,v1,0x600
80007ca0:	ac430000 	sw	v1,0(v0)
	  
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE1_EP_MEM + RxConfig, (READ_MEM32(PCIE1_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80007ca4:	3c02b900 	lui	v0,0xb900
80007ca8:	34430044 	ori	v1,v0,0x44
80007cac:	8c650000 	lw	a1,0(v1)
80007cb0:	2404f84f 	li	a0,-1969
80007cb4:	00a42024 	and	a0,a1,a0
80007cb8:	348405b0 	ori	a0,a0,0x5b0
80007cbc:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrLow, PADDR(TX1_DESC_ADDR));
80007cc0:	34430020 	ori	v1,v0,0x20
80007cc4:	3c040052 	lui	a0,0x52
80007cc8:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + TxDescStartAddrHigh, 0);
80007ccc:	34430024 	ori	v1,v0,0x24
80007cd0:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrLow, PADDR(RX1_DESC_ADDR));
80007cd4:	344300e4 	ori	v1,v0,0xe4
80007cd8:	3c040053 	lui	a0,0x53
80007cdc:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);
80007ce0:	344200e8 	ori	v0,v0,0xe8
80007ce4:	ac400000 	sw	zero,0(v0)
80007ce8:	3c02a052 	lui	v0,0xa052
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007cec:	3c03a052 	lui	v1,0xa052
80007cf0:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80007cf4:	a0400000 	sb	zero,0(v0)
80007cf8:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007cfc:	1443fffd 	bne	v0,v1,80007cf4 <rtl8168_init+0x158>
80007d00:	00000000 	nop
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
80007d04:	08001f4a 	j	80007d28 <rtl8168_init+0x18c>
80007d08:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
80007d0c:	14430008 	bne	v0,v1,80007d30 <rtl8168_init+0x194>
80007d10:	00000000 	nop
            WRITE_MEM32(TX1_DESC_ADDR + TX1_DESC_SIZE * i, htonl(PADDR(RingEnd)));
80007d14:	3c02a052 	lui	v0,0xa052
80007d18:	344203f0 	ori	v0,v0,0x3f0
80007d1c:	ac400000 	sw	zero,0(v0)
80007d20:	08001f50 	j	80007d40 <rtl8168_init+0x1a4>
80007d24:	3c02a053 	lui	v0,0xa053
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
80007d28:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
80007d2c:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE1_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX1_DESC_ADDR, 0x0, NUM_TX_DESC * TX1_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
80007d30:	24420001 	addiu	v0,v0,1
80007d34:	1444fff5 	bne	v0,a0,80007d0c <rtl8168_init+0x170>
80007d38:	00000000 	nop
80007d3c:	3c02a053 	lui	v0,0xa053
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007d40:	3c03a053 	lui	v1,0xa053
80007d44:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80007d48:	a0400000 	sb	zero,0(v0)
80007d4c:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007d50:	1443fffd 	bne	v0,v1,80007d48 <rtl8168_init+0x1ac>
80007d54:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80007d58:	08001f70 	j	80007dc0 <rtl8168_init+0x224>
80007d5c:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007d60:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
80007d64:	144300ab 	bne	v0,v1,80008014 <rtl8168_init+0x478>
80007d68:	00000000 	nop
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
80007d6c:	3c02a053 	lui	v0,0xa053
80007d70:	344303f0 	ori	v1,v0,0x3f0
80007d74:	3c040010 	lui	a0,0x10
80007d78:	348400c0 	ori	a0,a0,0xc0
80007d7c:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
      }

      tx1_desc_addr = (unsigned char *) TX1_DESC_ADDR;
80007d80:	3c04a052 	lui	a0,0xa052
80007d84:	3c038001 	lui	v1,0x8001
80007d88:	ac6431c8 	sw	a0,12744(v1)
      tx1_buff_addr = (unsigned char *) TX1_BUFF_ADDR;
80007d8c:	3c04a058 	lui	a0,0xa058
80007d90:	3c038001 	lui	v1,0x8001
80007d94:	ac6431cc 	sw	a0,12748(v1)
      rx1_desc_addr = (unsigned char *) RX1_DESC_ADDR;
80007d98:	3c038001 	lui	v1,0x8001
80007d9c:	ac6231d0 	sw	v0,12752(v1)
      rx1_buff_addr = (unsigned char *) RX1_BUFF_ADDR;
80007da0:	3c03a05a 	lui	v1,0xa05a
80007da4:	3c028001 	lui	v0,0x8001
80007da8:	ac4331e4 	sw	v1,12772(v0)
	  
#if USING_INTERRUPT
	EnIRQ(0, 1);
80007dac:	00002021 	move	a0,zero
80007db0:	0c001ec1 	jal	80007b04 <EnIRQ>
80007db4:	24050001 	li	a1,1

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
80007db8:	08001f79 	j	80007de4 <rtl8168_init+0x248>
80007dbc:	2610ffff 	addiu	s0,s0,-1
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80007dc0:	34630080 	ori	v1,v1,0x80
80007dc4:	3c02a053 	lui	v0,0xa053
80007dc8:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX1_DESC_ADDR, 0x0, NUM_RX_DESC * RX1_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
80007dcc:	3c03a053 	lui	v1,0xa053
80007dd0:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80007dd4:	3c040010 	lui	a0,0x10
80007dd8:	08001f58 	j	80007d60 <rtl8168_init+0x1c4>
80007ddc:	34840080 	ori	a0,a0,0x80

   //else  
	//------------------------------------------------------------------	
   
   #if (TEST_8196_PCIE_P1)
   if ( (portnum == 1) || (portnum== 2) )//PORT1
80007de0:	2610ffff 	addiu	s0,s0,-1
80007de4:	2e100002 	sltiu	s0,s0,2
80007de8:	1200008e 	beqz	s0,80008024 <rtl8168_init+0x488>
80007dec:	8fbf001c 	lw	ra,28(sp)
   {
      // 0. Set PCIE RootComplex
      WRITE_MEM32(PCIE2_RC_CFG + 0x04, 0x00100007);
80007df0:	3c04b8b2 	lui	a0,0xb8b2
80007df4:	34820004 	ori	v0,a0,0x4
80007df8:	3c030010 	lui	v1,0x10
80007dfc:	34630007 	ori	v1,v1,0x7
80007e00:	ac430000 	sw	v1,0(v0)
      WRITE_MEM8(PCIE2_RC_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
80007e04:	3c02b8b3 	lui	v0,0xb8b3
80007e08:	34430078 	ori	v1,v0,0x78
80007e0c:	90650000 	lbu	a1,0(v1)
80007e10:	30a5001f 	andi	a1,a1,0x1f
80007e14:	34840078 	ori	a0,a0,0x78
80007e18:	a0850000 	sb	a1,0(a0)

      // 1. Set 8111C EP
      WRITE_MEM32(PCIE2_EP_CFG + 0x04, 0x00180007);  // Mem, IO Enable
80007e1c:	34440004 	ori	a0,v0,0x4
80007e20:	3c050018 	lui	a1,0x18
80007e24:	34a50007 	ori	a1,a1,0x7
80007e28:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x10, (PCIE2_EP_IO | 0x00000001) & 0x1FFFFFFF);  // Set BAR
80007e2c:	34440010 	ori	a0,v0,0x10
80007e30:	3c0518e0 	lui	a1,0x18e0
80007e34:	34a50001 	ori	a1,a1,0x1
80007e38:	ac850000 	sw	a1,0(a0)
      WRITE_MEM32(PCIE2_EP_CFG + 0x18, (PCIE2_EP_MEM | 0x00000004) & 0x1FFFFFFF);  // Set BAR
80007e3c:	34440018 	ori	a0,v0,0x18
80007e40:	3c051a00 	lui	a1,0x1a00
80007e44:	34a50004 	ori	a1,a1,0x4
80007e48:	ac850000 	sw	a1,0(a0)

      WRITE_MEM8(PCIE2_EP_CFG + 0x78, (READ_MEM8(PCIE2_EP_CFG + 0x78) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
80007e4c:	90640000 	lbu	a0,0(v1)
80007e50:	3084001f 	andi	a0,a0,0x1f
80007e54:	a0640000 	sb	a0,0(v1)
      WRITE_MEM8(PCIE2_EP_CFG + 0x79, (READ_MEM8(PCIE2_EP_CFG + 0x79) & (~0x70)) | MAX_READ_REQSIZE_256B);  // Set MAX_REQ_SIZE to 128B
80007e58:	34420079 	ori	v0,v0,0x79
80007e5c:	90430000 	lbu	v1,0(v0)
80007e60:	2404ff8f 	li	a0,-113
80007e64:	00831824 	and	v1,a0,v1
80007e68:	34630010 	ori	v1,v1,0x10
80007e6c:	306300ff 	andi	v1,v1,0xff
80007e70:	a0430000 	sb	v1,0(v0)

      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);
80007e74:	24030010 	li	v1,16
80007e78:	3c02ba00 	lui	v0,0xba00
80007e7c:	34420037 	ori	v0,v0,0x37
80007e80:	a0430000 	sb	v1,0(v0)

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
80007e84:	1220000c 	beqz	s1,80007eb8 <rtl8168_init+0x31c>
80007e88:	3c02ba00 	lui	v0,0xba00
80007e8c:	34420040 	ori	v0,v0,0x40
80007e90:	8c440000 	lw	a0,0(v0)
80007e94:	3c03fffc 	lui	v1,0xfffc
80007e98:	3463f8ff 	ori	v1,v1,0xf8ff
80007e9c:	00832024 	and	a0,a0,v1
80007ea0:	3c030003 	lui	v1,0x3
80007ea4:	34630600 	ori	v1,v1,0x600
80007ea8:	00831825 	or	v1,a0,v1
80007eac:	ac430000 	sw	v1,0(v0)
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80007eb0:	08001fb8 	j	80007ee0 <rtl8168_init+0x344>
80007eb4:	3c02ba00 	lui	v0,0xba00
      // 2. Reset EP
      WRITE_MEM8(PCIE2_EP_MEM + ChipCmd, 0x10);

      // 3. Set MAC Loopback & Disable TX CRC & TxDMA Size
     if(en_loopback)      	WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB | TxMACLoopBack | (1 << 16));
	else  				WRITE_MEM32(PCIE2_EP_MEM + TxConfig, (READ_MEM32(PCIE2_EP_MEM + TxConfig) & (~0x700)) | TxDMA1KB |  (1 << 16));
80007eb8:	34420040 	ori	v0,v0,0x40
80007ebc:	8c440000 	lw	a0,0(v0)
80007ec0:	3c03fffe 	lui	v1,0xfffe
80007ec4:	3463f8ff 	ori	v1,v1,0xf8ff
80007ec8:	00832024 	and	a0,a0,v1
80007ecc:	3c030001 	lui	v1,0x1
80007ed0:	34630600 	ori	v1,v1,0x600
80007ed4:	00831825 	or	v1,a0,v1
80007ed8:	ac430000 	sw	v1,0(v0)
	
      // Enable Runt & Error Accept of RX Config
      WRITE_MEM32(PCIE2_EP_MEM + RxConfig, (READ_MEM32(PCIE2_EP_MEM + RxConfig) & (~0x700)) | RxDMA512B | AcceptErr | AcceptRunt | (1 << 7));
80007edc:	3c02ba00 	lui	v0,0xba00
80007ee0:	34430044 	ori	v1,v0,0x44
80007ee4:	8c650000 	lw	a1,0(v1)
80007ee8:	2404f84f 	li	a0,-1969
80007eec:	00a42024 	and	a0,a1,a0
80007ef0:	348405b0 	ori	a0,a0,0x5b0
80007ef4:	ac640000 	sw	a0,0(v1)

      // 4. Set TX/RX Desciptor Starting Address
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrLow, PADDR(TX2_DESC_ADDR));
80007ef8:	34430020 	ori	v1,v0,0x20
80007efc:	3c040062 	lui	a0,0x62
80007f00:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + TxDescStartAddrHigh, 0);
80007f04:	34430024 	ori	v1,v0,0x24
80007f08:	ac600000 	sw	zero,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrLow, PADDR(RX2_DESC_ADDR));
80007f0c:	344300e4 	ori	v1,v0,0xe4
80007f10:	3c040063 	lui	a0,0x63
80007f14:	ac640000 	sw	a0,0(v1)
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);
80007f18:	344200e8 	ori	v0,v0,0xe8
80007f1c:	ac400000 	sw	zero,0(v0)
80007f20:	3c02a062 	lui	v0,0xa062
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007f24:	3c03a062 	lui	v1,0xa062
80007f28:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80007f2c:	a0400000 	sb	zero,0(v0)
80007f30:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007f34:	1443fffd 	bne	v0,v1,80007f2c <rtl8168_init+0x390>
80007f38:	00000000 	nop
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
80007f3c:	08001fd8 	j	80007f60 <rtl8168_init+0x3c4>
80007f40:	00001021 	move	v0,zero
      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
      {
         if(i == (NUM_TX_DESC - 1))
80007f44:	14430008 	bne	v0,v1,80007f68 <rtl8168_init+0x3cc>
80007f48:	00000000 	nop
            WRITE_MEM32(TX2_DESC_ADDR + TX2_DESC_SIZE * i, htonl(PADDR(RingEnd)));
80007f4c:	3c02a062 	lui	v0,0xa062
80007f50:	344203f0 	ori	v0,v0,0x3f0
80007f54:	ac400000 	sw	zero,0(v0)
80007f58:	08001fde 	j	80007f78 <rtl8168_init+0x3dc>
80007f5c:	3c02a063 	lui	v0,0xa063
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
80007f60:	24040040 	li	a0,64
      {
         if(i == (NUM_TX_DESC - 1))
80007f64:	2403003f 	li	v1,63
      WRITE_MEM32(PCIE2_EP_MEM + RxDescAddrHigh, 0);

      // 5. Set TX Ring - Descriptor Assigned to CPU
      memset((unsigned char *) TX2_DESC_ADDR, 0x0, NUM_TX_DESC * TX2_DESC_SIZE);

      for (i = 0; i < NUM_TX_DESC; i++)
80007f68:	24420001 	addiu	v0,v0,1
80007f6c:	1444fff5 	bne	v0,a0,80007f44 <rtl8168_init+0x3a8>
80007f70:	00000000 	nop
80007f74:	3c02a063 	lui	v0,0xa063
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007f78:	3c03a063 	lui	v1,0xa063
80007f7c:	34630400 	ori	v1,v1,0x400
      *__s++ = __c;
80007f80:	a0400000 	sb	zero,0(v0)
80007f84:	24420001 	addiu	v0,v0,1
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007f88:	1443fffd 	bne	v0,v1,80007f80 <rtl8168_init+0x3e4>
80007f8c:	00000000 	nop
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
80007f90:	08001ffa 	j	80007fe8 <rtl8168_init+0x44c>
80007f94:	3c030010 	lui	v1,0x10
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80007f98:	24420010 	addiu	v0,v0,16
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
80007f9c:	1443001a 	bne	v0,v1,80008008 <rtl8168_init+0x46c>
80007fa0:	00000000 	nop
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
80007fa4:	3c02a063 	lui	v0,0xa063
80007fa8:	344303f0 	ori	v1,v0,0x3f0
80007fac:	3c040010 	lui	a0,0x10
80007fb0:	348400c0 	ori	a0,a0,0xc0
80007fb4:	ac640000 	sw	a0,0(v1)
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
      }

      tx2_desc_addr = (unsigned char *) TX2_DESC_ADDR;
80007fb8:	3c04a062 	lui	a0,0xa062
80007fbc:	3c038001 	lui	v1,0x8001
80007fc0:	ac6431dc 	sw	a0,12764(v1)
      tx2_buff_addr = (unsigned char *) TX2_BUFF_ADDR;
80007fc4:	3c04a068 	lui	a0,0xa068
80007fc8:	3c038001 	lui	v1,0x8001
80007fcc:	ac6431d8 	sw	a0,12760(v1)
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
80007fd0:	3c038001 	lui	v1,0x8001
80007fd4:	ac6231d4 	sw	v0,12756(v1)
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
80007fd8:	3c03a06a 	lui	v1,0xa06a
80007fdc:	3c028001 	lui	v0,0x8001
80007fe0:	08002008 	j	80008020 <rtl8168_init+0x484>
80007fe4:	ac4331e0 	sw	v1,12768(v0)
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
80007fe8:	34630080 	ori	v1,v1,0x80
80007fec:	3c02a063 	lui	v0,0xa063
80007ff0:	ac430000 	sw	v1,0(v0)
      // 6. Set RX Ring - Descriptor Assigned to NIC
      memset((unsigned char *) RX2_DESC_ADDR, 0x0, NUM_RX_DESC * RX2_DESC_SIZE);

      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
80007ff4:	3c03a063 	lui	v1,0xa063
80007ff8:	346303f0 	ori	v1,v1,0x3f0
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX2_BUFF_SIZE));
         else
            WRITE_MEM32(RX2_DESC_ADDR + RX2_DESC_SIZE * i, htonl(DescOwn | RX2_BUFF_SIZE));
80007ffc:	3c040010 	lui	a0,0x10
80008000:	08001fe6 	j	80007f98 <rtl8168_init+0x3fc>
80008004:	34840080 	ori	a0,a0,0x80
80008008:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
8000800c:	08001fe7 	j	80007f9c <rtl8168_init+0x400>
80008010:	24420010 	addiu	v0,v0,16
      for (i = 0; i < NUM_RX_DESC; i++)
      {
         if(i == (NUM_RX_DESC - 1))
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RingEnd | RX1_BUFF_SIZE));
         else
            WRITE_MEM32(RX1_DESC_ADDR + RX1_DESC_SIZE * i, htonl(DescOwn | RX1_BUFF_SIZE));
80008014:	ac440000 	sw	a0,0(v0)
static __inline void *memset(void *s, int c, int size)
{
   unsigned char *__s = (unsigned char *) s;
   unsigned char __c = (unsigned char) c;

   while (size--)
80008018:	08001f59 	j	80007d64 <rtl8168_init+0x1c8>
8000801c:	24420010 	addiu	v0,v0,16
      rx2_desc_addr = (unsigned char *) RX2_DESC_ADDR;
      rx2_buff_addr = (unsigned char *) RX2_BUFF_ADDR;
   }
  #endif
	//------------------------------------------------------------------------   
}
80008020:	8fbf001c 	lw	ra,28(sp)
80008024:	8fb10018 	lw	s1,24(sp)
80008028:	8fb00014 	lw	s0,20(sp)
8000802c:	03e00008 	jr	ra
80008030:	27bd0020 	addiu	sp,sp,32

80008034 <example>:
#endif

//===============================================================================
//unsigned short example();
unsigned short example(int portnum, int quietmode)     // 0:port 0, 1:port 1,  2:port 0 and port 1, rc=0, fail, rc=1 pass
{
80008034:	27bdffd8 	addiu	sp,sp,-40
80008038:	afbf0024 	sw	ra,36(sp)
8000803c:	afb40020 	sw	s4,32(sp)
80008040:	afb3001c 	sw	s3,28(sp)
80008044:	afb20018 	sw	s2,24(sp)
80008048:	afb10014 	sw	s1,20(sp)
8000804c:	afb00010 	sw	s0,16(sp)
80008050:	00808821 	move	s1,a0
   /* Get Random Data Length */
   #if PCIE_Test_With_8102E
          length1 = rand2() & 0x5ff; // limit to1535 ,OK for 8102E FT2
  	   //length1 = rand2() & 0x700; // limit to 1972 ,OK with 8102E
   #else
        length1 = rand2() & 0xfff; // limit to 64~4095
80008054:	0c00327b 	jal	8000c9ec <rand2>
80008058:	00a09821 	move	s3,a1
8000805c:	30420fff 	andi	v0,v0,0xfff
        //length1 = 1024 ; // fixed to 4092 ,error
	 //dprintf("Len=%x \n", length1);
   #endif   
   length1 = (length1 < 64) ? 64 : length1; 
80008060:	28500040 	slti	s0,v0,64
80008064:	24030040 	li	v1,64
80008068:	0050180a 	movz	v1,v0,s0
//-----------------------------------------------

   /* Set MAC */
  if ( (portnum == 0) || (portnum== 2) )//PORT1
8000806c:	12200004 	beqz	s1,80008080 <example+0x4c>
80008070:	00608021 	move	s0,v1
80008074:	24020002 	li	v0,2
80008078:	16220013 	bne	s1,v0,800080c8 <example+0x94>
8000807c:	2632ffff 	addiu	s2,s1,-1
  {

   rx1_str[0] = 0x00;
80008080:	3c02a058 	lui	v0,0xa058
80008084:	a0400000 	sb	zero,0(v0)
   rx1_str[1] = 0x11;
80008088:	34430001 	ori	v1,v0,0x1
8000808c:	24040011 	li	a0,17
80008090:	a0640000 	sb	a0,0(v1)
   rx1_str[2] = 0x22;
80008094:	34430002 	ori	v1,v0,0x2
80008098:	24040022 	li	a0,34
8000809c:	a0640000 	sb	a0,0(v1)
   rx1_str[3] = 0x33;
800080a0:	34430003 	ori	v1,v0,0x3
800080a4:	24040033 	li	a0,51
800080a8:	a0640000 	sb	a0,0(v1)
   rx1_str[4] = 0x44;
800080ac:	34430004 	ori	v1,v0,0x4
800080b0:	24040044 	li	a0,68
800080b4:	a0640000 	sb	a0,0(v1)
   rx1_str[5] = 0x55;
800080b8:	34420005 	ori	v0,v0,0x5
800080bc:	24030055 	li	v1,85
800080c0:	a0430000 	sb	v1,0(v0)

   
  }
	
    #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
800080c4:	2632ffff 	addiu	s2,s1,-1
800080c8:	2e430002 	sltiu	v1,s2,2
800080cc:	10600013 	beqz	v1,8000811c <example+0xe8>
800080d0:	00001021 	move	v0,zero
	   {
	   	   //prom_printf("\nTest PCIE P1 \n");
		   rx2_str[0] = 0x00;
800080d4:	3c02a068 	lui	v0,0xa068
800080d8:	a0400000 	sb	zero,0(v0)
		   rx2_str[1] = 0x11;
800080dc:	34430001 	ori	v1,v0,0x1
800080e0:	24040011 	li	a0,17
800080e4:	a0640000 	sb	a0,0(v1)
		   rx2_str[2] = 0x22;
800080e8:	34430002 	ori	v1,v0,0x2
800080ec:	24040022 	li	a0,34
800080f0:	a0640000 	sb	a0,0(v1)
		   rx2_str[3] = 0x33;
800080f4:	34430003 	ori	v1,v0,0x3
800080f8:	24040033 	li	a0,51
800080fc:	a0640000 	sb	a0,0(v1)
		   rx2_str[4] = 0x44;
80008100:	34430004 	ori	v1,v0,0x4
80008104:	24040044 	li	a0,68
80008108:	a0640000 	sb	a0,0(v1)
		   rx2_str[5] = 0x55;
8000810c:	34420005 	ori	v0,v0,0x5
80008110:	24030055 	li	v1,85
80008114:	a0430000 	sb	v1,0(v0)
80008118:	00001021 	move	v0,zero
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
8000811c:	3c06a058 	lui	a2,0xa058
80008120:	34c60006 	ori	a2,a2,0x6
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
80008124:	2e450002 	sltiu	a1,s2,2
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
80008128:	3c07a068 	lui	a3,0xa068
8000812c:	34e70006 	ori	a3,a3,0x6
		   rx2_str[0] = 0x00;
		   rx2_str[1] = 0x11;
		   rx2_str[2] = 0x22;
		   rx2_str[3] = 0x33;
		   rx2_str[4] = 0x44;
		   rx2_str[5] = 0x55;
80008130:	304300ff 	andi	v1,v0,0xff
   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
	
   {
            rx1_str[i] = (i - 6) & 0xFF; //default
80008134:	00462021 	addu	a0,v0,a2
        //   rx1_str[i] = ((i - 6) & 0xFF)|0x10;//JSW 20090214: test for PCIE_MacLoopBack ,bit4 always 1

		 
	 #if (TEST_8196_PCIE_P1)
	  if ( (portnum == 1) || (portnum== 2) )//PORT1
80008138:	10a00003 	beqz	a1,80008148 <example+0x114>
8000813c:	a0830000 	sb	v1,0(a0)
	   {
     		 rx2_str[i] = (i - 6) & 0xFF;	
80008140:	00472021 	addu	a0,v0,a3
80008144:	a0830000 	sb	v1,0(a0)
80008148:	24420001 	addiu	v0,v0,1
//-----------------------------------------------


   
   /* Set Sequential Data */   
   for (i = 6; i < length1; i++)  //wei add
8000814c:	24430006 	addiu	v1,v0,6
80008150:	0070182a 	slt	v1,v1,s0
80008154:	1460fff6 	bnez	v1,80008130 <example+0xfc>
80008158:	00000000 	nop
   /*
    * READ ID Test:
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
8000815c:	12200005 	beqz	s1,80008174 <example+0x140>
80008160:	3c02b8b1 	lui	v0,0xb8b1
80008164:	24020002 	li	v0,2
80008168:	1622002b 	bne	s1,v0,80008218 <example+0x1e4>
8000816c:	2e420002 	sltiu	v0,s2,2
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
80008170:	3c02b8b1 	lui	v0,0xb8b1
80008174:	8c430000 	lw	v1,0(v0)
80008178:	8c440000 	lw	a0,0(v0)
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
8000817c:	8c450000 	lw	a1,0(v0)
    * Read 8111C Vendor/Device ID
    */
 
   if ( (portnum == 0) || (portnum== 2) )
   {
	  if ((READ_MEM32(PCIE1_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE1_EP_CFG) == 0x819210EC)|\
80008180:	3c028168 	lui	v0,0x8168
80008184:	344210ec 	ori	v0,v0,0x10ec
80008188:	10620009 	beq	v1,v0,800081b0 <example+0x17c>
8000818c:	3c148001 	lui	s4,0x8001
80008190:	3c028192 	lui	v0,0x8192
80008194:	344210ec 	ori	v0,v0,0x10ec
80008198:	10820005 	beq	a0,v0,800081b0 <example+0x17c>
8000819c:	00000000 	nop
800081a0:	3c028136 	lui	v0,0x8136
800081a4:	344210ec 	ori	v0,v0,0x10ec
800081a8:	14a2000f 	bne	a1,v0,800081e8 <example+0x1b4>
800081ac:	00000000 	nop
		(READ_MEM32(PCIE1_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 	     
	       #if DBG
		      dprintf("\n======================================\n");
800081b0:	0c001cc1 	jal	80007304 <dprintf>
800081b4:	26840c48 	addiu	a0,s4,3144
		      dprintf("\nRead 8111/8192/8102 ID PASS !");	      
800081b8:	3c048001 	lui	a0,0x8001
800081bc:	0c001cc1 	jal	80007304 <dprintf>
800081c0:	24840c74 	addiu	a0,a0,3188
		      dprintf("\n=>PASS,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 
800081c4:	3c02b8b1 	lui	v0,0xb8b1
800081c8:	8c450000 	lw	a1,0(v0)
800081cc:	3c048001 	lui	a0,0x8001
800081d0:	0c001cc1 	jal	80007304 <dprintf>
800081d4:	24840c94 	addiu	a0,a0,3220
		      dprintf("\n======================================\n");
800081d8:	0c001cc1 	jal	80007304 <dprintf>
800081dc:	26840c48 	addiu	a0,s4,3144
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
800081e0:	08002086 	j	80008218 <example+0x1e4>
800081e4:	2e420002 	sltiu	v0,s2,2
	   {

	      // Failed 
	     
	      #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail ! \n");				
800081e8:	3c048001 	lui	a0,0x8001
800081ec:	0c001cc1 	jal	80007304 <dprintf>
800081f0:	24840cbc 	addiu	a0,a0,3260
	      #endif
		  
		  if(quietmode==0)
800081f4:	1660006b 	bnez	s3,800083a4 <example+0x370>
800081f8:	00001021 	move	v0,zero
		 dprintf("\n=>Fail,PCIE P0's ID (0xb8b10000)=%x\n",READ_MEM32(PCIE1_EP_CFG)); 	
800081fc:	3c02b8b1 	lui	v0,0xb8b1
80008200:	8c450000 	lw	a1,0(v0)
80008204:	3c048001 	lui	a0,0x8001
80008208:	0c001cc1 	jal	80007304 <dprintf>
8000820c:	24840ce0 	addiu	a0,a0,3296
80008210:	080020e9 	j	800083a4 <example+0x370>
80008214:	00001021 	move	v0,zero
   }
//---------------------------------------------------------------------------------------------

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
80008218:	10400028 	beqz	v0,800082bc <example+0x288>
8000821c:	02202021 	move	a0,s1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
80008220:	3c02b8b3 	lui	v0,0xb8b3
80008224:	8c430000 	lw	v1,0(v0)
80008228:	8c440000 	lw	a0,0(v0)
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
8000822c:	8c450000 	lw	a1,0(v0)

 //Auto-test PCIE Port1 by recognize Bond_Option	
 #if (TEST_8196_PCIE_P1)	
	if ( (portnum == 1) || (portnum== 2) )//PORT1
	 {
	   if ((READ_MEM32(PCIE2_EP_CFG) == 0x816810EC) |(READ_MEM32(PCIE2_EP_CFG) == 0x819210EC)|\
80008230:	3c028168 	lui	v0,0x8168
80008234:	344210ec 	ori	v0,v0,0x10ec
80008238:	10620008 	beq	v1,v0,8000825c <example+0x228>
8000823c:	3c148001 	lui	s4,0x8001
80008240:	3c028192 	lui	v0,0x8192
80008244:	344210ec 	ori	v0,v0,0x10ec
80008248:	10820004 	beq	a0,v0,8000825c <example+0x228>
8000824c:	3c028136 	lui	v0,0x8136
80008250:	344210ec 	ori	v0,v0,0x10ec
80008254:	14a2000f 	bne	a1,v0,80008294 <example+0x260>
80008258:	00000000 	nop
			(READ_MEM32(PCIE2_EP_CFG) == 0x813610EC) )//  //
	   {
	      // Successful 

	       #if DBG
		      dprintf("\n======================================\n");
8000825c:	0c001cc1 	jal	80007304 <dprintf>
80008260:	26840c48 	addiu	a0,s4,3144
		      dprintf("\nRead 8111/8192/8102 ID PASS !");		
80008264:	3c048001 	lui	a0,0x8001
80008268:	0c001cc1 	jal	80007304 <dprintf>
8000826c:	24840c74 	addiu	a0,a0,3188
		      dprintf("\n=>PASS,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
80008270:	3c02b8b3 	lui	v0,0xb8b3
80008274:	8c450000 	lw	a1,0(v0)
80008278:	3c048001 	lui	a0,0x8001
8000827c:	0c001cc1 	jal	80007304 <dprintf>
80008280:	24840d08 	addiu	a0,a0,3336
		      dprintf("\n======================================\n");
80008284:	0c001cc1 	jal	80007304 <dprintf>
80008288:	26840c48 	addiu	a0,s4,3144
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
8000828c:	080020af 	j	800082bc <example+0x288>
80008290:	02202021 	move	a0,s1
	   else
	   {
	      // Failed 
	      
	       #if DBG
		      dprintf("\nRead 8111/8192/8102 ID Fail !\n");		     
80008294:	3c048001 	lui	a0,0x8001
80008298:	0c001cc1 	jal	80007304 <dprintf>
8000829c:	24840d30 	addiu	a0,a0,3376
		      dprintf("\n=>Fail,PCIE P1's ID (0xb8b30000)=%x\n",READ_MEM32(PCIE2_EP_CFG)); 	
800082a0:	3c02b8b3 	lui	v0,0xb8b3
800082a4:	8c450000 	lw	a1,0(v0)
800082a8:	3c048001 	lui	a0,0x8001
800082ac:	0c001cc1 	jal	80007304 <dprintf>
800082b0:	24840d50 	addiu	a0,a0,3408
			
	      #endif
			return 0;
800082b4:	080020e9 	j	800083a4 <example+0x370>
800082b8:	00001021 	move	v0,zero
	    * MAC Loopback Test:
	    * TX 1 Packet and then RX compare
	    */

	  /*"2"=test P1 and P0  , "1"=test P1 , "0"= test P0  */
	   rtl8168_init(portnum, en_loopback ); 
800082bc:	0c001ee7 	jal	80007b9c <rtl8168_init>
800082c0:	24050001 	li	a1,1
      for (i = 0; i < 64; i++)  //wei add
            rx1_str[i] = tx_buffer[i]; 
            
#endif    	  
	   //-------------------------------------------------------------------	
	  if ( (portnum == 0) || (portnum== 2) )
800082c4:	12200003 	beqz	s1,800082d4 <example+0x2a0>
800082c8:	24020002 	li	v0,2
800082cc:	16220006 	bne	s1,v0,800082e8 <example+0x2b4>
800082d0:	2e420002 	sltiu	v0,s2,2
	  {
	  	 rtl8168_tx(rx1_str, length1, portnum);
800082d4:	3c04a058 	lui	a0,0xa058
800082d8:	02002821 	move	a1,s0
800082dc:	0c001d50 	jal	80007540 <rtl8168_tx>
800082e0:	02203021 	move	a2,s1
	  }
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)
		if ( (portnum == 1) || (portnum== 2) )
800082e4:	2e420002 	sltiu	v0,s2,2
800082e8:	10400004 	beqz	v0,800082fc <example+0x2c8>
800082ec:	3c04a068 	lui	a0,0xa068
	   	  {
	 	  	rtl8168_tx(rx2_str, length1, portnum);
800082f0:	02002821 	move	a1,s0
800082f4:	0c001d50 	jal	80007540 <rtl8168_tx>
800082f8:	02203021 	move	a2,s1
	   	  }
	   #endif
	   //-------------------------------------------------------------------
	   rtl8168_tx_trigger(portnum);
800082fc:	0c001d8f 	jal	8000763c <rtl8168_tx_trigger>
80008300:	02202021 	move	a0,s1
	   //-------------------------------------------------------------------
	  if ( (portnum == 0) || (portnum== 2) )
80008304:	12200003 	beqz	s1,80008314 <example+0x2e0>
80008308:	24020002 	li	v0,2
8000830c:	16220011 	bne	s1,v0,80008354 <example+0x320>
80008310:	00000000 	nop
	   {
		   if (rtl8168_rx(rx1_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
80008314:	3c04a058 	lui	a0,0xa058
80008318:	02002821 	move	a1,s0
8000831c:	0c001ded 	jal	800077b4 <rtl8168_rx>
80008320:	02203021 	move	a2,s1
80008324:	14400006 	bnez	v0,80008340 <example+0x30c>
80008328:	00000000 	nop
		   {		      
			// if(quietmode==0)
			  dprintf("PCIE_P0 => PASS !\n");		
8000832c:	3c048001 	lui	a0,0x8001
80008330:	0c001cc1 	jal	80007304 <dprintf>
80008334:	24840d78 	addiu	a0,a0,3448
				return 0;
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
80008338:	080020d6 	j	80008358 <example+0x324>
8000833c:	2e520002 	sltiu	s2,s2,2
			  dprintf("PCIE_P0 => PASS !\n");		
		   }
		   else
		   {		      
			 //if(quietmode==0)			      
    			      dprintf("PCIE_P0 => Fail ! \n");			
80008340:	3c048001 	lui	a0,0x8001
80008344:	0c001cc1 	jal	80007304 <dprintf>
80008348:	24840d8c 	addiu	a0,a0,3468

				return 0;
8000834c:	080020e9 	j	800083a4 <example+0x370>
80008350:	00001021 	move	v0,zero
		   }
	   }	
	   //-------------------------------------------------------------------
	    #if (TEST_8196_PCIE_P1)		   	  
  		 if ( (portnum == 1) || (portnum== 2) )
80008354:	2e520002 	sltiu	s2,s2,2
80008358:	12400012 	beqz	s2,800083a4 <example+0x370>
8000835c:	24020001 	li	v0,1
	   	  {
			  if (rtl8168_rx(rx2_str, length1, portnum) == 0)   //"0"==compare OK,"-1"=fail
80008360:	3c04a068 	lui	a0,0xa068
80008364:	02002821 	move	a1,s0
80008368:	0c001ded 	jal	800077b4 <rtl8168_rx>
8000836c:	02203021 	move	a2,s1
80008370:	14400007 	bnez	v0,80008390 <example+0x35c>
80008374:	3c048001 	lui	a0,0x8001
			   {		
			 	if(quietmode==0)			   
80008378:	16600009 	bnez	s3,800083a0 <example+0x36c>
8000837c:	3c048001 	lui	a0,0x8001
				 	dprintf("PCIE_P1 => PASS !\n");				
80008380:	0c001cc1 	jal	80007304 <dprintf>
80008384:	24840da0 	addiu	a0,a0,3488
80008388:	080020e9 	j	800083a4 <example+0x370>
8000838c:	24020001 	li	v0,1
			   }
			   else
			   { 
			   	//if(quietmode==0)
					dprintf("PCIE_P1 => Fail !\n");					
80008390:	0c001cc1 	jal	80007304 <dprintf>
80008394:	24840db4 	addiu	a0,a0,3508
					return 0;
80008398:	080020e9 	j	800083a4 <example+0x370>
8000839c:	00001021 	move	v0,zero
800083a0:	24020001 	li	v0,1

		  return 1;
	

	
}
800083a4:	8fbf0024 	lw	ra,36(sp)
800083a8:	8fb40020 	lw	s4,32(sp)
800083ac:	8fb3001c 	lw	s3,28(sp)
800083b0:	8fb20018 	lw	s2,24(sp)
800083b4:	8fb10014 	lw	s1,20(sp)
800083b8:	8fb00010 	lw	s0,16(sp)
800083bc:	03e00008 	jr	ra
800083c0:	27bd0028 	addiu	sp,sp,40
	...

800083d0 <CmdCore1Wakeup>:
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555

	//Let Core 1 wakeup
	#define GIC_WAKEUP_IRQ 43
	REG32(GIC_BASE_ADDR+0x2000+GIC_WAKEUP_IRQ*0x20)=2;  //map2vpe
800083d0:	3c02bbdc 	lui	v0,0xbbdc
800083d4:	34432560 	ori	v1,v0,0x2560
800083d8:	24040002 	li	a0,2
800083dc:	ac640000 	sw	a0,0(v1)
	REG32(GIC_BASE_ADDR+0x184)=0x800;  //trg edge type 
800083e0:	34430184 	ori	v1,v0,0x184
800083e4:	24040800 	li	a0,2048
800083e8:	ac640000 	sw	a0,0(v1)
		
	REG32(GIC_BASE_ADDR+0x280)=0x80000000 | GIC_WAKEUP_IRQ;  //sw int
800083ec:	34420280 	ori	v0,v0,0x280
800083f0:	3c048000 	lui	a0,0x8000
800083f4:	3484002b 	ori	a0,a0,0x2b
800083f8:	ac440000 	sw	a0,0(v0)
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
800083fc:	2404002b 	li	a0,43
80008400:	ac440000 	sw	a0,0(v0)
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
80008404:	ac600000 	sw	zero,0(v1)
80008408:	24020063 	li	v0,99
#if 1
	int i=100;
	while(i--)
	{
		if(REG32(POLLING_REG)!=PATT_SLEEP)
8000840c:	3c05b800 	lui	a1,0xb800
80008410:	34a5006c 	ori	a1,a1,0x6c
80008414:	24043333 	li	a0,13107
80008418:	8ca30000 	lw	v1,0(a1)
8000841c:	14640005 	bne	v1,a0,80008434 <CmdCore1Wakeup+0x64>
80008420:	00000000 	nop
//	delay_ms(10);
	REG32(GIC_BASE_ADDR+0x280)=0x00000000 | GIC_WAKEUP_IRQ;	
	REG32(GIC_BASE_ADDR+0x184)=0x0;  //trg edge type 
#if 1
	int i=100;
	while(i--)
80008424:	10400003 	beqz	v0,80008434 <CmdCore1Wakeup+0x64>
80008428:	00000000 	nop
8000842c:	08002106 	j	80008418 <CmdCore1Wakeup+0x48>
80008430:	2442ffff 	addiu	v0,v0,-1
#endif

#ifdef _verbose
	printf("Core 1 cannot Wakeup, ret=%x\n", REG32(POLLING_REG));
#endif
}
80008434:	03e00008 	jr	ra
80008438:	00000000 	nop

8000843c <SPEED_isr>:
}
//==============================================================


static void SPEED_isr(void)
{
8000843c:	27bdffe0 	addiu	sp,sp,-32
80008440:	afbf001c 	sw	ra,28(sp)
80008444:	afb10018 	sw	s1,24(sp)
80008448:	afb00014 	sw	s0,20(sp)
	unsigned int isr=REG32(GISR_REG);
8000844c:	3c02b800 	lui	v0,0xb800
80008450:	34433004 	ori	v1,v0,0x3004
80008454:	8c700000 	lw	s0,0(v1)
	unsigned int cpu_status=REG32(SYS_INT_STATUS);
80008458:	34420004 	ori	v0,v0,0x4
8000845c:	8c510000 	lw	s1,0(v0)
	
	dprintf("=>CPU Wake-up interrupt happen! GISR=%08x \n", isr);
80008460:	3c048001 	lui	a0,0x8001
80008464:	24840dd0 	addiu	a0,a0,3536
80008468:	0c001cc1 	jal	80007304 <dprintf>
8000846c:	02002821 	move	a1,s0

	if( (isr & (1<<27))==0)   //check isr==1
80008470:	7e0206c0 	ext	v0,s0,0x1b,0x1
80008474:	14400008 	bnez	v0,80008498 <SPEED_isr+0x5c>
80008478:	32220002 	andi	v0,s1,0x2
	{	dprintf("Check Fail, GISR=%x bit %d is not 1\n", isr, 27);
8000847c:	3c048001 	lui	a0,0x8001
80008480:	24840dfc 	addiu	a0,a0,3580
80008484:	02002821 	move	a1,s0
80008488:	0c001cc1 	jal	80007304 <dprintf>
8000848c:	2406001b 	li	a2,27
80008490:	08002124 	j	80008490 <SPEED_isr+0x54>
80008494:	00000000 	nop
		while(1) ;
	}

	if((cpu_status & (1<<1))==0)  //check source==1
80008498:	14400008 	bnez	v0,800084bc <SPEED_isr+0x80>
8000849c:	24030002 	li	v1,2
	{	dprintf("Fail, Source=%x bit %d is not 1 \n", cpu_status, 1);
800084a0:	3c048001 	lui	a0,0x8001
800084a4:	24840e24 	addiu	a0,a0,3620
800084a8:	02202821 	move	a1,s1
800084ac:	0c001cc1 	jal	80007304 <dprintf>
800084b0:	24060001 	li	a2,1
800084b4:	0800212d 	j	800084b4 <SPEED_isr+0x78>
800084b8:	00000000 	nop
		while(1) ;
	}
		
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
800084bc:	3c02b800 	lui	v0,0xb800
800084c0:	34420004 	ori	v0,v0,0x4
800084c4:	ac430000 	sw	v1,0(v0)
//	REG32(GISR_REG)=1<<SPEED_IRQ_NO;	//write to clear, but cannot clear


//	REG32(GIMR_REG)= REG32(GIMR_REG) & ~(1<<SPEED_IRQ_NO);	//so, disable interrupt		
}
800084c8:	8fbf001c 	lw	ra,28(sp)
800084cc:	8fb10018 	lw	s1,24(sp)
800084d0:	8fb00014 	lw	s0,20(sp)
800084d4:	03e00008 	jr	ra
800084d8:	27bd0020 	addiu	sp,sp,32

800084dc <SettingM2xClk>:
extern unsigned long glexra_clock;

//---------------------------------------------------------------------------

int SettingM2xClk(int clk_sel)
{
800084dc:	27bdffe8 	addiu	sp,sp,-24
800084e0:	afbf0014 	sw	ra,20(sp)
	int	tmp=REG32(SYS_HW_STRAP) & ~(CK_M2X_FREQ_SEL);
800084e4:	3c02b800 	lui	v0,0xb800
800084e8:	34430008 	ori	v1,v0,0x8
800084ec:	8c660000 	lw	a2,0(v1)
	
		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
800084f0:	34420014 	ori	v0,v0,0x14
800084f4:	8c430000 	lw	v1,0(v0)
800084f8:	34630004 	ori	v1,v1,0x4
800084fc:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
80008500:	3c05b800 	lui	a1,0xb800
80008504:	34a50020 	ori	a1,a1,0x20
80008508:	8ca30000 	lw	v1,0(a1)
8000850c:	30630001 	andi	v1,v1,0x1
80008510:	1060fffd 	beqz	v1,80008508 <SettingM2xClk+0x2c>
80008514:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
80008518:	34420014 	ori	v0,v0,0x14
8000851c:	8c430000 	lw	v1,0(v0)
80008520:	34630008 	ori	v1,v1,0x8
80008524:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
80008528:	3c05b800 	lui	a1,0xb800
8000852c:	34a50020 	ori	a1,a1,0x20
80008530:	8ca30000 	lw	v1,0(a1)
80008534:	30630002 	andi	v1,v1,0x2
80008538:	1060fffd 	beqz	v1,80008530 <SettingM2xClk+0x54>
8000853c:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
80008540:	34420014 	ori	v0,v0,0x14
80008544:	8c430000 	lw	v1,0(v0)
80008548:	34630010 	ori	v1,v1,0x10
8000854c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok		
80008550:	3c05b800 	lui	a1,0xb800
80008554:	34a50020 	ori	a1,a1,0x20
80008558:	8ca30000 	lw	v1,0(a1)
8000855c:	30630004 	andi	v1,v1,0x4
80008560:	1060fffd 	beqz	v1,80008558 <SettingM2xClk+0x7c>
80008564:	00041280 	sll	v0,a0,0xa

			//add check transaction dram empty .
		#endif

	
	REG32(SYS_HW_STRAP)= tmp | (clk_sel) <<CK_M2X_FREQ_SEL_OFFSET ;
80008568:	240383ff 	li	v1,-31745
8000856c:	00c31824 	and	v1,a2,v1
80008570:	00431825 	or	v1,v0,v1
80008574:	3c02b800 	lui	v0,0xb800
80008578:	34420008 	ori	v0,v0,0x8
8000857c:	ac430000 	sw	v1,0(v0)
		
		#if 1   //check m2xusable and unlock bus
			while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
80008580:	3c06b800 	lui	a2,0xb800
80008584:	34c60020 	ori	a2,a2,0x20
80008588:	3c050004 	lui	a1,0x4
8000858c:	8cc30000 	lw	v1,0(a2)
80008590:	00651824 	and	v1,v1,a1
80008594:	1060fffd 	beqz	v1,8000858c <SettingM2xClk+0xb0>
80008598:	3c02b800 	lui	v0,0xb800
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000859c:	34420014 	ori	v0,v0,0x14
800085a0:	8c450000 	lw	a1,0(v0)
800085a4:	2403fffb 	li	v1,-5
800085a8:	00a31824 	and	v1,a1,v1
800085ac:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
800085b0:	3c05b800 	lui	a1,0xb800
800085b4:	34a50020 	ori	a1,a1,0x20
800085b8:	8ca30000 	lw	v1,0(a1)
800085bc:	30630001 	andi	v1,v1,0x1
800085c0:	1460fffd 	bnez	v1,800085b8 <SettingM2xClk+0xdc>
800085c4:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
800085c8:	34420014 	ori	v0,v0,0x14
800085cc:	8c450000 	lw	a1,0(v0)
800085d0:	2403fff7 	li	v1,-9
800085d4:	00a31824 	and	v1,a1,v1
800085d8:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
800085dc:	3c05b800 	lui	a1,0xb800
800085e0:	34a50020 	ori	a1,a1,0x20
800085e4:	8ca30000 	lw	v1,0(a1)
800085e8:	30630002 	andi	v1,v1,0x2
800085ec:	1460fffd 	bnez	v1,800085e4 <SettingM2xClk+0x108>
800085f0:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
800085f4:	34420014 	ori	v0,v0,0x14
800085f8:	8c450000 	lw	a1,0(v0)
800085fc:	2403ffef 	li	v1,-17
80008600:	00a31824 	and	v1,a1,v1
80008604:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
80008608:	3c05b800 	lui	a1,0xb800
8000860c:	34a50020 	ori	a1,a1,0x20
80008610:	8ca30000 	lw	v1,0(a1)
80008614:	30630004 	andi	v1,v1,0x4
80008618:	1460fffd 	bnez	v1,80008610 <SettingM2xClk+0x134>
8000861c:	3c028001 	lui	v0,0x8001
	{
		console_init(glexra_clock);
		timer_init(glexra_clock);
	}
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
80008620:	00042080 	sll	a0,a0,0x2
80008624:	2442eba0 	addiu	v0,v0,-5216
80008628:	00821021 	addu	v0,a0,v0
8000862c:	3c048001 	lui	a0,0x8001
80008630:	24840e48 	addiu	a0,a0,3656
80008634:	0c001cc1 	jal	80007304 <dprintf>
80008638:	8c450000 	lw	a1,0(v0)
}
8000863c:	8fbf0014 	lw	ra,20(sp)
80008640:	03e00008 	jr	ra
80008644:	27bd0018 	addiu	sp,sp,24

80008648 <LetCPUDoSomething>:

struct irqaction irq_SPEED = {SPEED_isr, (unsigned long)NULL, (unsigned long)SPEED_IRQ_NO,"SPEED", (void *)NULL, (struct irqaction *)NULL};   

//---------------------------------------------------------------------------
int LetCPUDoSomething()
{
80008648:	27bdfbe8 	addiu	sp,sp,-1048
8000864c:	afbf0414 	sw	ra,1044(sp)
      	{
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
80008650:	27a70010 	addiu	a3,sp,16
80008654:	3c02a000 	lui	v0,0xa000
80008658:	00e23825 	or	a3,a3,v0
8000865c:	00e02821 	move	a1,a3
80008660:	00e01821 	move	v1,a3
80008664:	00001021 	move	v0,zero
	for(i=0; i<256; i++)
80008668:	24040100 	li	a0,256
		p[i]=i;
8000866c:	ac620000 	sw	v0,0(v1)
		dprintf("FAIL! ,summation 1 to 100=%d \n",sum);
		while(1) {};
	  }

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
80008670:	24420001 	addiu	v0,v0,1
80008674:	1444fffd 	bne	v0,a0,8000866c <LetCPUDoSomething+0x24>
80008678:	24630004 	addiu	v1,v1,4
		p[i]=i;

	for(i=0; i<256;i++)
		if(p[i]!=i)
8000867c:	8ca60000 	lw	a2,0(a1)
80008680:	24050001 	li	a1,1
80008684:	10c00003 	beqz	a2,80008694 <LetCPUDoSomething+0x4c>
80008688:	24020100 	li	v0,256
8000868c:	080021a9 	j	800086a4 <LetCPUDoSomething+0x5c>
80008690:	00002821 	move	a1,zero
80008694:	8ce60004 	lw	a2,4(a3)
80008698:	10c50007 	beq	a2,a1,800086b8 <LetCPUDoSomething+0x70>
8000869c:	24a50001 	addiu	a1,a1,1
800086a0:	24a5ffff 	addiu	a1,a1,-1
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
800086a4:	3c048001 	lui	a0,0x8001
800086a8:	0c001cc1 	jal	80007304 <dprintf>
800086ac:	24840e64 	addiu	a0,a0,3684
800086b0:	080021ac 	j	800086b0 <LetCPUDoSomething+0x68>
800086b4:	00000000 	nop

	p=(unsigned int)buf|0xa0000000;
	for(i=0; i<256; i++)
		p[i]=i;

	for(i=0; i<256;i++)
800086b8:	14a2fff6 	bne	a1,v0,80008694 <LetCPUDoSomething+0x4c>
800086bc:	24e70004 	addiu	a3,a3,4
		if(p[i]!=i)
		{	dprintf("FAIL! idx=%x val=%x\n",i,p[i]);
			while(1) {};
		}

}
800086c0:	8fbf0414 	lw	ra,1044(sp)
800086c4:	03e00008 	jr	ra
800086c8:	27bd0418 	addiu	sp,sp,1048

800086cc <HS0_Control>:
}

//=================================================================================

void HS0_Control(unsigned int ocp, unsigned int lx, unsigned int mx, unsigned int sleep)
{
800086cc:	27bdffd8 	addiu	sp,sp,-40
800086d0:	afbf0024 	sw	ra,36(sp)
800086d4:	afb40020 	sw	s4,32(sp)
800086d8:	afb3001c 	sw	s3,28(sp)
800086dc:	afb20018 	sw	s2,24(sp)
800086e0:	afb10014 	sw	s1,20(sp)
800086e4:	afb00010 	sw	s0,16(sp)
800086e8:	00808821 	move	s1,a0
800086ec:	00c08021 	move	s0,a2
800086f0:	00e09821 	move	s3,a3
	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	#define RANG4  0x0f


	if(lx==0)	lx=200;
800086f4:	241400c8 	li	s4,200
	if(mx==0)
800086f8:	14c0000b 	bnez	a2,80008728 <HS0_Control+0x5c>
800086fc:	00a5a00b 	movn	s4,a1,a1
	{
		unsigned int m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), CK_M2X_FREQ_SEL_OFFSET, RANG5);
80008700:	3c02b800 	lui	v0,0xb800
80008704:	34420008 	ori	v0,v0,0x8
80008708:	8c430000 	lw	v1,0(v0)
		mx=(m2x_clksel_table[m2x_freq_sel])/2;
8000870c:	7c632280 	ext	v1,v1,0xa,0x5
80008710:	00031880 	sll	v1,v1,0x2
80008714:	3c028001 	lui	v0,0x8001
80008718:	2442eba0 	addiu	v0,v0,-5216
8000871c:	00621021 	addu	v0,v1,v0
80008720:	8c500000 	lw	s0,0(v0)
80008724:	00108042 	srl	s0,s0,0x1
	}
 	if(ocp==0)
80008728:	1620000d 	bnez	s1,80008760 <HS0_Control+0x94>
8000872c:	0290102b 	sltu	v0,s4,s0
 	{
		unsigned int cpu_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), ST_CPU_FREQ_SEL_OFFSET, RANG4);
80008730:	3c02b800 	lui	v0,0xb800
80008734:	34420008 	ori	v0,v0,0x8
80008738:	8c420000 	lw	v0,0(v0)
		ocp=cpu_clksel_table[cpu_freq_sel];
8000873c:	3c030007 	lui	v1,0x7
80008740:	34638000 	ori	v1,v1,0x8000
80008744:	00431824 	and	v1,v0,v1
80008748:	00031b42 	srl	v1,v1,0xd
8000874c:	3c028001 	lui	v0,0x8001
80008750:	2442eb60 	addiu	v0,v0,-5280
80008754:	00621021 	addu	v0,v1,v0
80008758:	8c510000 	lw	s1,0(v0)

	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	unsigned int v=0;
	if(lx<mx)		{	v|=BIT(0)| BIT(1) |BIT(2);   	printf("Lx<Mx\n");		}
8000875c:	0290102b 	sltu	v0,s4,s0
80008760:	10400005 	beqz	v0,80008778 <HS0_Control+0xac>
80008764:	00009021 	move	s2,zero
80008768:	3c048001 	lui	a0,0x8001
8000876c:	0c001cc1 	jal	80007304 <dprintf>
80008770:	24840e7c 	addiu	a0,a0,3708
80008774:	24120007 	li	s2,7
	if(ocp<mx)		{	v|=BIT(3);					printf("Ocp<Mx\n");	}
80008778:	0230802b 	sltu	s0,s1,s0
8000877c:	12000005 	beqz	s0,80008794 <HS0_Control+0xc8>
80008780:	00000000 	nop
80008784:	36520008 	ori	s2,s2,0x8
80008788:	3c048001 	lui	a0,0x8001
8000878c:	0c001cc1 	jal	80007304 <dprintf>
80008790:	24840e84 	addiu	a0,a0,3716
	if(ocp<lx)		{	v|=BIT(4);					printf("Ocp<Lx\n");	}
80008794:	0234882b 	sltu	s1,s1,s4
80008798:	12200006 	beqz	s1,800087b4 <HS0_Control+0xe8>
8000879c:	3c02b800 	lui	v0,0xb800
800087a0:	36520010 	ori	s2,s2,0x10
800087a4:	3c048001 	lui	a0,0x8001
800087a8:	0c001cc1 	jal	80007304 <dprintf>
800087ac:	24840e8c 	addiu	a0,a0,3724

	
	//REG32(SYS_HS0_CTRL) = v;
	REG32(SYS_HS0_CTRL) |= v;
800087b0:	3c02b800 	lui	v0,0xb800
800087b4:	344200a0 	ori	v0,v0,0xa0
800087b8:	8c430000 	lw	v1,0(v0)
800087bc:	02439025 	or	s2,s2,v1
800087c0:	ac520000 	sw	s2,0(v0)
	


	if(sleep)
800087c4:	12600012 	beqz	s3,80008810 <HS0_Control+0x144>
800087c8:	3c02b800 	lui	v0,0xb800
	{	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
800087cc:	34420014 	ori	v0,v0,0x14
800087d0:	8c430000 	lw	v1,0(v0)
800087d4:	34630004 	ori	v1,v1,0x4
800087d8:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  {}; //wait bit to 1, is mean lock ok	
800087dc:	00401821 	move	v1,v0
800087e0:	8c620000 	lw	v0,0(v1)
800087e4:	30421000 	andi	v0,v0,0x1000
800087e8:	1040fffd 	beqz	v0,800087e0 <HS0_Control+0x114>
800087ec:	00000000 	nop
			//REG32(SYS_BIST_CTRL) |= (1<<4) ;	  //lock bus arb6
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  {}; //wait bit to 1, is mean lock ok				
		#endif
		
		//__asm__ volatile("sleep");	 //need 10 usec to guaretee
		__asm__ volatile("nop");
800087f0:	00000000 	nop


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
800087f4:	3c02b800 	lui	v0,0xb800
800087f8:	34420014 	ori	v0,v0,0x14
800087fc:	8c440000 	lw	a0,0(v0)
80008800:	2403fffb 	li	v1,-5
80008804:	00831824 	and	v1,a0,v1
80008808:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) {};  //wait bit to 0  unlock
8000880c:	8c420000 	lw	v0,0(v0)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif
	}
			//printf("done\n");

}
80008810:	8fbf0024 	lw	ra,36(sp)
80008814:	8fb40020 	lw	s4,32(sp)
80008818:	8fb3001c 	lw	s3,28(sp)
8000881c:	8fb20018 	lw	s2,24(sp)
80008820:	8fb10014 	lw	s1,20(sp)
80008824:	8fb00010 	lw	s0,16(sp)
80008828:	03e00008 	jr	ra
8000882c:	27bd0028 	addiu	sp,sp,40

80008830 <ShowStrapMsg>:
#define printf dprintf


//=================================================================================
void ShowStrapMsg()
{
80008830:	27bdffa0 	addiu	sp,sp,-96
80008834:	afbf005c 	sw	ra,92(sp)
80008838:	afb50058 	sw	s5,88(sp)
8000883c:	afb40054 	sw	s4,84(sp)
80008840:	afb30050 	sw	s3,80(sp)
80008844:	afb2004c 	sw	s2,76(sp)
80008848:	afb10048 	sw	s1,72(sp)
8000884c:	afb00044 	sw	s0,68(sp)
	const unsigned char *boot_type_tab[]={ {"SPI3B"}, {"SPI4B"}, {"NFBI"}, {"NAND"}, {"ROM01"}, {"ROM02"}, {"ROM03"}, {"auto"} };
80008850:	3c028001 	lui	v0,0x8001
80008854:	24420e94 	addiu	v0,v0,3732
80008858:	afa20018 	sw	v0,24(sp)
8000885c:	3c028001 	lui	v0,0x8001
80008860:	24420e9c 	addiu	v0,v0,3740
80008864:	afa2001c 	sw	v0,28(sp)
80008868:	3c028001 	lui	v0,0x8001
8000886c:	24420ea4 	addiu	v0,v0,3748
80008870:	afa20020 	sw	v0,32(sp)
80008874:	3c028001 	lui	v0,0x8001
80008878:	24420eac 	addiu	v0,v0,3756
8000887c:	afa20024 	sw	v0,36(sp)
80008880:	3c028001 	lui	v0,0x8001
80008884:	24420eb4 	addiu	v0,v0,3764
80008888:	afa20028 	sw	v0,40(sp)
8000888c:	3c028001 	lui	v0,0x8001
80008890:	24420ebc 	addiu	v0,v0,3772
80008894:	afa2002c 	sw	v0,44(sp)
80008898:	3c028001 	lui	v0,0x8001
8000889c:	24420ec4 	addiu	v0,v0,3780
800088a0:	afa20030 	sw	v0,48(sp)
800088a4:	3c028001 	lui	v0,0x8001
800088a8:	24420ecc 	addiu	v0,v0,3788
800088ac:	afa20034 	sw	v0,52(sp)
	const unsigned char *dram_type_tab[]={  {"DDR2"}, {"DDR3"} };
800088b0:	3c028001 	lui	v0,0x8001
800088b4:	24420ed4 	addiu	v0,v0,3796
800088b8:	afa20038 	sw	v0,56(sp)
800088bc:	3c028001 	lui	v0,0x8001
800088c0:	24420edc 	addiu	v0,v0,3804
800088c4:	afa2003c 	sw	v0,60(sp)
	#define RANG2 3
	#define RANG3  7
	#define RANG4 0xf	
	#define RANG5 0x1f
	
	unsigned int v=REG32(SYS_HW_STRAP);
800088c8:	3c02b800 	lui	v0,0xb800
800088cc:	34420008 	ori	v0,v0,0x8
800088d0:	8c500000 	lw	s0,0(v0)

	unsigned int bootsel=GET_BITVAL(v, 0, RANG3);
800088d4:	32110007 	andi	s1,s0,0x7
	unsigned int dramtype=GET_BITVAL(v, 3, RANG1);
800088d8:	7e1200c0 	ext	s2,s0,0x3,0x1
	

	
	unsigned int ck_m2x_freq_sel=GET_BITVAL(v, 10, RANG5);
800088dc:	7e152280 	ext	s5,s0,0xa,0x5
	unsigned int ck_cpu_freq_sel=GET_BITVAL(v, 15, RANG4);
800088e0:	3c130007 	lui	s3,0x7
800088e4:	36738000 	ori	s3,s3,0x8000
800088e8:	02139824 	and	s3,s0,s3
800088ec:	00139bc2 	srl	s3,s3,0xf
	unsigned int ck_cpu_div_sel=GET_BITVAL(v, 19, RANG2);
800088f0:	7e140cc0 	ext	s4,s0,0x13,0x2



	
	printf("---------------------\n");
800088f4:	3c048001 	lui	a0,0x8001
800088f8:	0c001cc1 	jal	80007304 <dprintf>
800088fc:	24840ee4 	addiu	a0,a0,3812
	printf("HW_STRAP_VAL= 0x%08x \n", v);
80008900:	3c048001 	lui	a0,0x8001
80008904:	24840efc 	addiu	a0,a0,3836
80008908:	0c001cc1 	jal	80007304 <dprintf>
8000890c:	02002821 	move	a1,s0
	printf("[02:00] ST_BOOTPINSEL= 0x%x  \n", bootsel);		
80008910:	3c048001 	lui	a0,0x8001
80008914:	24840f14 	addiu	a0,a0,3860
80008918:	0c001cc1 	jal	80007304 <dprintf>
8000891c:	02202821 	move	a1,s1
	printf("[03:03] ST_DRAMTYPE= 0x%x      	\n", 	dramtype);	
80008920:	3c048001 	lui	a0,0x8001
80008924:	24840f34 	addiu	a0,a0,3892
80008928:	0c001cc1 	jal	80007304 <dprintf>
8000892c:	02402821 	move	a1,s2

	printf("[04:04] clklx_from_clkm= 0x%x \n",  	GET_BITVAL(v, 4, RANG1)  );	
80008930:	3c048001 	lui	a0,0x8001
80008934:	24840f58 	addiu	a0,a0,3928
80008938:	0c001cc1 	jal	80007304 <dprintf>
8000893c:	7e050100 	ext	a1,s0,0x4,0x1
	printf("[05:05] disable_ext_reset= 0x%x \n",  	GET_BITVAL(v, 5, RANG1)  );	
80008940:	3c048001 	lui	a0,0x8001
80008944:	24840f78 	addiu	a0,a0,3960
80008948:	0c001cc1 	jal	80007304 <dprintf>
8000894c:	7e050140 	ext	a1,s0,0x5,0x1
	printf("[06:06] ext_phy_mode= 0x%x \n",  	GET_BITVAL(v, 6, RANG1)  );		
80008950:	3c048001 	lui	a0,0x8001
80008954:	24840f9c 	addiu	a0,a0,3996
80008958:	0c001cc1 	jal	80007304 <dprintf>
8000895c:	7e050180 	ext	a1,s0,0x6,0x1


	printf("[14:10] CK_M2X_FREQ_SEL= 0x%x \n", ck_m2x_freq_sel);	
80008960:	3c048001 	lui	a0,0x8001
80008964:	24840fbc 	addiu	a0,a0,4028
80008968:	0c001cc1 	jal	80007304 <dprintf>
8000896c:	02a02821 	move	a1,s5
	printf("[18:15] ST_CPU_FREQ_SEL= 0x%x \n", ck_cpu_freq_sel);
80008970:	3c048001 	lui	a0,0x8001
80008974:	24840fdc 	addiu	a0,a0,4060
80008978:	0c001cc1 	jal	80007304 <dprintf>
8000897c:	02602821 	move	a1,s3
	
	printf("[20:19] ST_CPU_FREQDIV_SEL= 0x%x \n", ck_cpu_div_sel);
80008980:	3c048001 	lui	a0,0x8001
80008984:	24840ffc 	addiu	a0,a0,4092
80008988:	0c001cc1 	jal	80007304 <dprintf>
8000898c:	02802821 	move	a1,s4

	printf("[21:21] clklx_from_halfoc= 0x%x \n",  	GET_BITVAL(v, 21, RANG1)  );	
80008990:	3c048001 	lui	a0,0x8001
80008994:	24841020 	addiu	a0,a0,4128
80008998:	0c001cc1 	jal	80007304 <dprintf>
8000899c:	7e050540 	ext	a1,s0,0x15,0x1
	
	printf("[22:22] ever_reboot_once= 0x%x \n", 	GET_BITVAL(v, 22, RANG1)  );	
800089a0:	3c048001 	lui	a0,0x8001
800089a4:	24841044 	addiu	a0,a0,4164
800089a8:	0c001cc1 	jal	80007304 <dprintf>
800089ac:	7e050580 	ext	a1,s0,0x16,0x1
	printf("[23:23] clkoc_from_clkm= 0x%x \n", 	GET_BITVAL(v, 23, RANG1)  );			
800089b0:	3c048001 	lui	a0,0x8001
800089b4:	24841068 	addiu	a0,a0,4200
800089b8:	0c001cc1 	jal	80007304 <dprintf>
800089bc:	7e0505c0 	ext	a1,s0,0x17,0x1
	printf("[24:24] sel_40m= 0x%x \n", 	GET_BITVAL(v, 24, RANG1)  );		
800089c0:	3c048001 	lui	a0,0x8001
800089c4:	24841088 	addiu	a0,a0,4232
800089c8:	0c001cc1 	jal	80007304 <dprintf>
800089cc:	7e050600 	ext	a1,s0,0x18,0x1

	printf("\n");
800089d0:	3c048001 	lui	a0,0x8001
800089d4:	0c001cc1 	jal	80007304 <dprintf>
800089d8:	24840f54 	addiu	a0,a0,3924
	printf("%s mode, %s Ram,  CPU=%d MHz, Mem2x=%d MHz, \n", 
800089dc:	00118880 	sll	s1,s1,0x2
800089e0:	27a20018 	addiu	v0,sp,24
800089e4:	00518821 	addu	s1,v0,s1
800089e8:	8e250000 	lw	a1,0(s1)
800089ec:	00129080 	sll	s2,s2,0x2
800089f0:	00521021 	addu	v0,v0,s2
800089f4:	8c460020 	lw	a2,32(v0)
800089f8:	00139880 	sll	s3,s3,0x2
800089fc:	3c028001 	lui	v0,0x8001
80008a00:	2442eb60 	addiu	v0,v0,-5280
80008a04:	02629821 	addu	s3,s3,v0
80008a08:	0014a080 	sll	s4,s4,0x2
80008a0c:	3c028001 	lui	v0,0x8001
80008a10:	24422e10 	addiu	v0,v0,11792
80008a14:	0282a021 	addu	s4,s4,v0
80008a18:	8e670000 	lw	a3,0(s3)
80008a1c:	8e820000 	lw	v0,0(s4)
80008a20:	00e2001b 	divu	zero,a3,v0
80008a24:	004001f4 	teq	v0,zero,0x7
80008a28:	00003812 	mflo	a3
80008a2c:	0015a880 	sll	s5,s5,0x2
80008a30:	3c028001 	lui	v0,0x8001
80008a34:	2442eba0 	addiu	v0,v0,-5216
80008a38:	02a2a821 	addu	s5,s5,v0
80008a3c:	8ea20000 	lw	v0,0(s5)
80008a40:	afa20010 	sw	v0,16(sp)
80008a44:	3c048001 	lui	a0,0x8001
80008a48:	0c001cc1 	jal	80007304 <dprintf>
80008a4c:	248410a0 	addiu	a0,a0,4256
						dram_type_tab[dramtype],
						cpu_clksel_table[ck_cpu_freq_sel]/cpu_clkdiv_table[ck_cpu_div_sel] ,
						m2x_clksel_table[ck_m2x_freq_sel]
						);
					
}
80008a50:	8fbf005c 	lw	ra,92(sp)
80008a54:	8fb50058 	lw	s5,88(sp)
80008a58:	8fb40054 	lw	s4,84(sp)
80008a5c:	8fb30050 	lw	s3,80(sp)
80008a60:	8fb2004c 	lw	s2,76(sp)
80008a64:	8fb10048 	lw	s1,72(sp)
80008a68:	8fb00044 	lw	s0,68(sp)
80008a6c:	03e00008 	jr	ra
80008a70:	27bd0060 	addiu	sp,sp,96

80008a74 <Cmd_AllBistTest>:
}
		
		
//=============================================================================
int Cmd_AllBistTest(int argc, char* argv[])
{
80008a74:	27bdffd0 	addiu	sp,sp,-48
80008a78:	afbf002c 	sw	ra,44(sp)
80008a7c:	afb60028 	sw	s6,40(sp)
80008a80:	afb50024 	sw	s5,36(sp)
80008a84:	afb40020 	sw	s4,32(sp)
80008a88:	afb3001c 	sw	s3,28(sp)
80008a8c:	afb20018 	sw	s2,24(sp)
80008a90:	afb10014 	sw	s1,20(sp)
80008a94:	afb00010 	sw	s0,16(sp)
	#define HS0_DRF_FAIL4    0xb80002bc
	#define HS0_DRF_FAIL5    0xb80002c0
	#define HS0_DRF_FAIL6    0xb80002c4


	printf( "========================\n");
80008a98:	3c138001 	lui	s3,0x8001
80008a9c:	0c001cc1 	jal	80007304 <dprintf>
80008aa0:	266410d0 	addiu	a0,s3,4304
	printf( "Mode 1 BIST : cpu1 mbr \n");
80008aa4:	3c048001 	lui	a0,0x8001
80008aa8:	0c001cc1 	jal	80007304 <dprintf>
80008aac:	248410ec 	addiu	a0,a0,4332
	REG32(HS0_BIST_CTRL) = 0;
80008ab0:	3c10b800 	lui	s0,0xb800
80008ab4:	36110208 	ori	s1,s0,0x208
80008ab8:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
80008abc:	8e250000 	lw	a1,0(s1)
80008ac0:	3c128001 	lui	s2,0x8001
80008ac4:	0c001cc1 	jal	80007304 <dprintf>
80008ac8:	26441108 	addiu	a0,s2,4360

#if 0		
	REG32(HS0_BIST_CTRL) |=  (0x7f);
#else
	REG32(HS0_BIST_CTRL) |=  (0x7c);  //skip mbr0, mbr1
80008acc:	8e220000 	lw	v0,0(s1)
80008ad0:	3442007c 	ori	v0,v0,0x7c
80008ad4:	ae220000 	sw	v0,0(s1)
#endif
		printf( "W:HS0_BIST_CTRL=%08x \n", REG32(HS0_BIST_CTRL) );
80008ad8:	8e250000 	lw	a1,0(s1)
80008adc:	0c001cc1 	jal	80007304 <dprintf>
80008ae0:	26441108 	addiu	a0,s2,4360
	
	REG32(HS0_BIST_CTRL2) = 0;
80008ae4:	3611020c 	ori	s1,s0,0x20c
80008ae8:	ae200000 	sw	zero,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
80008aec:	8e250000 	lw	a1,0(s1)
80008af0:	3c128001 	lui	s2,0x8001
80008af4:	0c001cc1 	jal	80007304 <dprintf>
80008af8:	26441120 	addiu	a0,s2,4384
		
	REG32(HS0_BIST_CTRL2) |=  (0x1e0103ff);
80008afc:	8e230000 	lw	v1,0(s1)
80008b00:	3c021e01 	lui	v0,0x1e01
80008b04:	344203ff 	ori	v0,v0,0x3ff
80008b08:	00621025 	or	v0,v1,v0
80008b0c:	ae220000 	sw	v0,0(s1)
		printf( "W:HS0_BIST_CTRL2=%08x \n", REG32(HS0_BIST_CTRL2) );
80008b10:	8e250000 	lw	a1,0(s1)
80008b14:	0c001cc1 	jal	80007304 <dprintf>
80008b18:	26441120 	addiu	a0,s2,4384
	

	delay_ms(10);
80008b1c:	0c001bb5 	jal	80006ed4 <delay_ms>
80008b20:	2404000a 	li	a0,10

	printf( "\n");
80008b24:	3c048001 	lui	a0,0x8001
80008b28:	0c001cc1 	jal	80007304 <dprintf>
80008b2c:	24840f54 	addiu	a0,a0,3924
	printf( "R:HS0_BIST DONE=%08x \n",  REG32(HS0_BIST_DONE) );
80008b30:	36110218 	ori	s1,s0,0x218
80008b34:	8e250000 	lw	a1,0(s1)
80008b38:	3c048001 	lui	a0,0x8001
80008b3c:	0c001cc1 	jal	80007304 <dprintf>
80008b40:	24841138 	addiu	a0,a0,4408
	printf( "R:HS0_BIST FAIL1=%08x \n", REG32(HS0_BIST_FAIL1) );
80008b44:	36020230 	ori	v0,s0,0x230
80008b48:	8c450000 	lw	a1,0(v0)
80008b4c:	3c048001 	lui	a0,0x8001
80008b50:	0c001cc1 	jal	80007304 <dprintf>
80008b54:	24841150 	addiu	a0,a0,4432
	printf( "R:HS0_BIST FAIL2=%08x \n", REG32(HS0_BIST_FAIL2) );
80008b58:	36020234 	ori	v0,s0,0x234
80008b5c:	8c450000 	lw	a1,0(v0)
80008b60:	3c048001 	lui	a0,0x8001
80008b64:	0c001cc1 	jal	80007304 <dprintf>
80008b68:	24841168 	addiu	a0,a0,4456
	printf( "R:HS0_BIST FAIL3=%08x \n", REG32(HS0_BIST_FAIL3) );
80008b6c:	36020238 	ori	v0,s0,0x238
80008b70:	8c450000 	lw	a1,0(v0)
80008b74:	3c048001 	lui	a0,0x8001
80008b78:	0c001cc1 	jal	80007304 <dprintf>
80008b7c:	24841180 	addiu	a0,a0,4480
	printf( "R:HS0_BIST FAIL4=%08x \n", REG32(HS0_BIST_FAIL4) );
80008b80:	3602023c 	ori	v0,s0,0x23c
80008b84:	8c450000 	lw	a1,0(v0)
80008b88:	3c048001 	lui	a0,0x8001
80008b8c:	0c001cc1 	jal	80007304 <dprintf>
80008b90:	24841198 	addiu	a0,a0,4504
	printf( "R:HS0_BIST FAIL5=%08x \n", REG32(HS0_BIST_FAIL5) );
80008b94:	36020240 	ori	v0,s0,0x240
80008b98:	8c450000 	lw	a1,0(v0)
80008b9c:	3c048001 	lui	a0,0x8001
80008ba0:	0c001cc1 	jal	80007304 <dprintf>
80008ba4:	248411b0 	addiu	a0,a0,4528
		  (REG32(HS0_BIST_FAIL5)==0)  )
		  { printf( " ==>BIST PASS \n"); }	 
#endif		
	//============================================
	
	printf( "========================\n");
80008ba8:	0c001cc1 	jal	80007304 <dprintf>
80008bac:	266410d0 	addiu	a0,s3,4304
	printf( "Mode 2 BIST : L2,SRAM,ROM,CPU2 \n");
80008bb0:	3c048001 	lui	a0,0x8001
80008bb4:	0c001cc1 	jal	80007304 <dprintf>
80008bb8:	248411c8 	addiu	a0,a0,4552

	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));
80008bbc:	36100244 	ori	s0,s0,0x244
80008bc0:	8e050000 	lw	a1,0(s0)
80008bc4:	3c048001 	lui	a0,0x8001
80008bc8:	0c001cc1 	jal	80007304 <dprintf>
80008bcc:	248411ec 	addiu	a0,a0,4588

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
80008bd0:	8e230000 	lw	v1,0(s1)
80008bd4:	3c020001 	lui	v0,0x1
80008bd8:	3442e400 	ori	v0,v0,0xe400
80008bdc:	00621824 	and	v1,v1,v0
80008be0:	10620005 	beq	v1,v0,80008bf8 <Cmd_AllBistTest+0x184>
80008be4:	3c02b800 	lui	v0,0xb800
80008be8:	3c048001 	lui	a0,0x8001
80008bec:	0c001cc1 	jal	80007304 <dprintf>
80008bf0:	24841204 	addiu	a0,a0,4612
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	
80008bf4:	3c02b800 	lui	v0,0xb800
80008bf8:	34420244 	ori	v0,v0,0x244
80008bfc:	8c420000 	lw	v0,0(v0)
80008c00:	10400005 	beqz	v0,80008c18 <Cmd_AllBistTest+0x1a4>
80008c04:	3c02b800 	lui	v0,0xb800
80008c08:	3c048001 	lui	a0,0x8001
80008c0c:	0c001cc1 	jal	80007304 <dprintf>
80008c10:	24841214 	addiu	a0,a0,4628

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
80008c14:	3c02b800 	lui	v0,0xb800
80008c18:	34420218 	ori	v0,v0,0x218
80008c1c:	8c430000 	lw	v1,0(v0)
80008c20:	3c020001 	lui	v0,0x1
80008c24:	3442e400 	ori	v0,v0,0xe400
80008c28:	00621824 	and	v1,v1,v0
80008c2c:	1462000a 	bne	v1,v0,80008c58 <Cmd_AllBistTest+0x1e4>
80008c30:	3c02b800 	lui	v0,0xb800
		 ( REG32(HS0_BIST_FAIL6) == 0) )
80008c34:	34420244 	ori	v0,v0,0x244
80008c38:	8c420000 	lw	v0,0(v0)
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
80008c3c:	14400006 	bnez	v0,80008c58 <Cmd_AllBistTest+0x1e4>
80008c40:	00000000 	nop
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
80008c44:	3c048001 	lui	a0,0x8001
80008c48:	0c001cc1 	jal	80007304 <dprintf>
80008c4c:	24841224 	addiu	a0,a0,4644
	printf( "R:HS0_BIST FAIL6=%08x \n", REG32(HS0_BIST_FAIL6));

	if ( (REG32(HS0_BIST_DONE)&(0x79<<10)) != (0x79<<10)) { printf( " ==>DONE FAIL \n"); }	
	if (  REG32(HS0_BIST_FAIL6) != 0) { printf( " ==>FAIL FAIL \n"); }	

	if ((( REG32(HS0_BIST_DONE)&(0x79<<10)) == (0x79<<10)) && 
80008c50:	0800231a 	j	80008c68 <Cmd_AllBistTest+0x1f4>
80008c54:	00008821 	move	s1,zero
		 ( REG32(HS0_BIST_FAIL6) == 0) )
	{ printf( " ==>BIST PASS \n"); }
	else
	{ printf( " ==>BIST FAIL \n"); err++; }		
80008c58:	3c048001 	lui	a0,0x8001
80008c5c:	0c001cc1 	jal	80007304 <dprintf>
80008c60:	24841234 	addiu	a0,a0,4660
80008c64:	24110001 	li	s1,1
	//============================================
	printf( "========================\n");
80008c68:	3c048001 	lui	a0,0x8001
80008c6c:	0c001cc1 	jal	80007304 <dprintf>
80008c70:	248410d0 	addiu	a0,a0,4304
	printf( "Mode 3 BIST : NAND,FFT,SATA, PCS ROM, PCS RAM, USB3, OTG, PCIE(ep10),VOIP\n");
80008c74:	3c048001 	lui	a0,0x8001
80008c78:	0c001cc1 	jal	80007304 <dprintf>
80008c7c:	24841244 	addiu	a0,a0,4676
	REG32(BIST_CTRL) = 0;
80008c80:	3c13b800 	lui	s3,0xb800
80008c84:	36700200 	ori	s0,s3,0x200
80008c88:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
80008c8c:	8e050000 	lw	a1,0(s0)
80008c90:	3c128001 	lui	s2,0x8001
80008c94:	0c001cc1 	jal	80007304 <dprintf>
80008c98:	26441290 	addiu	a0,s2,4752
			
	REG32(BIST_CTRL) |=  (0x01);
80008c9c:	8e020000 	lw	v0,0(s0)
80008ca0:	34420001 	ori	v0,v0,0x1
80008ca4:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL));
80008ca8:	8e050000 	lw	a1,0(s0)
80008cac:	0c001cc1 	jal	80007304 <dprintf>
80008cb0:	26441290 	addiu	a0,s2,4752

	REG32(BIST_CTRL) |= (0x03ff0001);
80008cb4:	8e030000 	lw	v1,0(s0)
80008cb8:	3c0203ff 	lui	v0,0x3ff
80008cbc:	34420001 	ori	v0,v0,0x1
80008cc0:	00621025 	or	v0,v1,v0
80008cc4:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL   )); 
80008cc8:	8e050000 	lw	a1,0(s0)
80008ccc:	0c001cc1 	jal	80007304 <dprintf>
80008cd0:	26441290 	addiu	a0,s2,4752

	delay_ms(10);
80008cd4:	0c001bb5 	jal	80006ed4 <delay_ms>
80008cd8:	2404000a 	li	a0,10
	printf( "\n");
80008cdc:	3c048001 	lui	a0,0x8001
80008ce0:	0c001cc1 	jal	80007304 <dprintf>
80008ce4:	24840f54 	addiu	a0,a0,3924
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
80008ce8:	36700210 	ori	s0,s3,0x210
80008cec:	8e050000 	lw	a1,0(s0)
80008cf0:	3c048001 	lui	a0,0x8001
80008cf4:	0c001cc1 	jal	80007304 <dprintf>
80008cf8:	248412a4 	addiu	a0,a0,4772
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
80008cfc:	36730220 	ori	s3,s3,0x220
80008d00:	8e650000 	lw	a1,0(s3)
80008d04:	3c048001 	lui	a0,0x8001
80008d08:	0c001cc1 	jal	80007304 <dprintf>
80008d0c:	248412b8 	addiu	a0,a0,4792


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
80008d10:	8e030000 	lw	v1,0(s0)
80008d14:	3c02ffff 	lui	v0,0xffff
80008d18:	34423fff 	ori	v0,v0,0x3fff
80008d1c:	14620009 	bne	v1,v0,80008d44 <Cmd_AllBistTest+0x2d0>
80008d20:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
80008d24:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
80008d28:	14400006 	bnez	v0,80008d44 <Cmd_AllBistTest+0x2d0>
80008d2c:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
80008d30:	3c048001 	lui	a0,0x8001
80008d34:	0c001cc1 	jal	80007304 <dprintf>
80008d38:	24841224 	addiu	a0,a0,4644
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff3fff) && 
80008d3c:	08002368 	j	80008da0 <Cmd_AllBistTest+0x32c>
80008d40:	3c048001 	lui	a0,0x8001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else 								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
80008d44:	3c048001 	lui	a0,0x8001
80008d48:	0c001cc1 	jal	80007304 <dprintf>
80008d4c:	24841234 	addiu	a0,a0,4660
80008d50:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff3fff) { printf( " ==>DONE FAIL \n"); }
80008d54:	3c02b800 	lui	v0,0xb800
80008d58:	34420210 	ori	v0,v0,0x210
80008d5c:	8c430000 	lw	v1,0(v0)
80008d60:	3c02ffff 	lui	v0,0xffff
80008d64:	34423fff 	ori	v0,v0,0x3fff
80008d68:	10620005 	beq	v1,v0,80008d80 <Cmd_AllBistTest+0x30c>
80008d6c:	3c02b800 	lui	v0,0xb800
80008d70:	3c048001 	lui	a0,0x8001
80008d74:	0c001cc1 	jal	80007304 <dprintf>
80008d78:	24841204 	addiu	a0,a0,4612
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
80008d7c:	3c02b800 	lui	v0,0xb800
80008d80:	34420220 	ori	v0,v0,0x220
80008d84:	8c420000 	lw	v0,0(v0)
80008d88:	10400004 	beqz	v0,80008d9c <Cmd_AllBistTest+0x328>
80008d8c:	00000000 	nop
80008d90:	3c048001 	lui	a0,0x8001
80008d94:	0c001cc1 	jal	80007304 <dprintf>
80008d98:	24841214 	addiu	a0,a0,4628
	}	
		
	//============================================
	printf( "============================== \n");
80008d9c:	3c048001 	lui	a0,0x8001
80008da0:	0c001cc1 	jal	80007304 <dprintf>
80008da4:	248412cc 	addiu	a0,a0,4812
	printf( "Mode 4 BIST :switch\n");
80008da8:	3c048001 	lui	a0,0x8001
80008dac:	0c001cc1 	jal	80007304 <dprintf>
80008db0:	248412f0 	addiu	a0,a0,4848
	REG32(BIST_CTRL) = 0;
80008db4:	3c13b800 	lui	s3,0xb800
80008db8:	36700200 	ori	s0,s3,0x200
80008dbc:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );	
80008dc0:	8e050000 	lw	a1,0(s0)
80008dc4:	3c128001 	lui	s2,0x8001
80008dc8:	0c001cc1 	jal	80007304 <dprintf>
80008dcc:	26441290 	addiu	a0,s2,4752
	REG32(BIST_CTRL) |=  (0x01);
80008dd0:	8e020000 	lw	v0,0(s0)
80008dd4:	34420001 	ori	v0,v0,0x1
80008dd8:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
80008ddc:	8e050000 	lw	a1,0(s0)
80008de0:	0c001cc1 	jal	80007304 <dprintf>
80008de4:	26441290 	addiu	a0,s2,4752
	REG32(BIST_CTRL) |=  (1<<26);
80008de8:	8e030000 	lw	v1,0(s0)
80008dec:	3c020400 	lui	v0,0x400
80008df0:	00621025 	or	v0,v1,v0
80008df4:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
80008df8:	8e050000 	lw	a1,0(s0)
80008dfc:	0c001cc1 	jal	80007304 <dprintf>
80008e00:	26441290 	addiu	a0,s2,4752
	    
	delay_ms(10);  
80008e04:	0c001bb5 	jal	80006ed4 <delay_ms>
80008e08:	2404000a 	li	a0,10
	printf( "\n");
80008e0c:	3c048001 	lui	a0,0x8001
80008e10:	0c001cc1 	jal	80007304 <dprintf>
80008e14:	24840f54 	addiu	a0,a0,3924
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
80008e18:	36700210 	ori	s0,s3,0x210
80008e1c:	8e050000 	lw	a1,0(s0)
80008e20:	3c048001 	lui	a0,0x8001
80008e24:	0c001cc1 	jal	80007304 <dprintf>
80008e28:	248412a4 	addiu	a0,a0,4772
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));
80008e2c:	36730220 	ori	s3,s3,0x220
80008e30:	8e650000 	lw	a1,0(s3)
80008e34:	3c048001 	lui	a0,0x8001
80008e38:	0c001cc1 	jal	80007304 <dprintf>
80008e3c:	248412b8 	addiu	a0,a0,4792


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
80008e40:	8e030000 	lw	v1,0(s0)
80008e44:	3c02ffff 	lui	v0,0xffff
80008e48:	34424418 	ori	v0,v0,0x4418
80008e4c:	14620009 	bne	v1,v0,80008e74 <Cmd_AllBistTest+0x400>
80008e50:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
80008e54:	8e620000 	lw	v0,0(s3)
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
80008e58:	14400006 	bnez	v0,80008e74 <Cmd_AllBistTest+0x400>
80008e5c:	00000000 	nop
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
80008e60:	3c048001 	lui	a0,0x8001
80008e64:	0c001cc1 	jal	80007304 <dprintf>
80008e68:	24841224 	addiu	a0,a0,4644
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE));
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL));


	
	if ( (REG32(BIST_DONE) == 0xffff4418) && 
80008e6c:	080023b4 	j	80008ed0 <Cmd_AllBistTest+0x45c>
80008e70:	3c048001 	lui	a0,0x8001
		( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
	else								   
	{ 	printf( " ==>BIST FAIL \n"); err++;
80008e74:	3c048001 	lui	a0,0x8001
80008e78:	0c001cc1 	jal	80007304 <dprintf>
80008e7c:	24841234 	addiu	a0,a0,4660
80008e80:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff4418) { printf( " ==>DONE FAIL \n"); }
80008e84:	3c02b800 	lui	v0,0xb800
80008e88:	34420210 	ori	v0,v0,0x210
80008e8c:	8c430000 	lw	v1,0(v0)
80008e90:	3c02ffff 	lui	v0,0xffff
80008e94:	34424418 	ori	v0,v0,0x4418
80008e98:	10620005 	beq	v1,v0,80008eb0 <Cmd_AllBistTest+0x43c>
80008e9c:	3c02b800 	lui	v0,0xb800
80008ea0:	3c048001 	lui	a0,0x8001
80008ea4:	0c001cc1 	jal	80007304 <dprintf>
80008ea8:	24841204 	addiu	a0,a0,4612
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
80008eac:	3c02b800 	lui	v0,0xb800
80008eb0:	34420220 	ori	v0,v0,0x220
80008eb4:	8c420000 	lw	v0,0(v0)
80008eb8:	10400004 	beqz	v0,80008ecc <Cmd_AllBistTest+0x458>
80008ebc:	00000000 	nop
80008ec0:	3c048001 	lui	a0,0x8001
80008ec4:	0c001cc1 	jal	80007304 <dprintf>
80008ec8:	24841214 	addiu	a0,a0,4628
	}	 
	//============================================
	printf( "============================== \n");
80008ecc:	3c048001 	lui	a0,0x8001
80008ed0:	0c001cc1 	jal	80007304 <dprintf>
80008ed4:	248412cc 	addiu	a0,a0,4812
	printf( "Mode 5 BIST :switch bist-r \n");
80008ed8:	3c048001 	lui	a0,0x8001
80008edc:	0c001cc1 	jal	80007304 <dprintf>
80008ee0:	24841308 	addiu	a0,a0,4872
	REG32(BIST_CTRL) = 0;
80008ee4:	3c13b800 	lui	s3,0xb800
80008ee8:	36700200 	ori	s0,s3,0x200
80008eec:	ae000000 	sw	zero,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );		
80008ef0:	8e050000 	lw	a1,0(s0)
80008ef4:	3c128001 	lui	s2,0x8001
80008ef8:	0c001cc1 	jal	80007304 <dprintf>
80008efc:	26441290 	addiu	a0,s2,4752
	REG32(BIST_CTRL) |=  (0x01);
80008f00:	8e020000 	lw	v0,0(s0)
80008f04:	34420001 	ori	v0,v0,0x1
80008f08:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
80008f0c:	8e050000 	lw	a1,0(s0)
80008f10:	0c001cc1 	jal	80007304 <dprintf>
80008f14:	26441290 	addiu	a0,s2,4752
	REG32(BIST_CTRL) |= (1<<27);
80008f18:	8e030000 	lw	v1,0(s0)
80008f1c:	3c020800 	lui	v0,0x800
80008f20:	00621025 	or	v0,v1,v0
80008f24:	ae020000 	sw	v0,0(s0)
		printf( "W:BIST_CTRL=%08x \n", REG32(BIST_CTRL) );
80008f28:	8e050000 	lw	a1,0(s0)
80008f2c:	0c001cc1 	jal	80007304 <dprintf>
80008f30:	26441290 	addiu	a0,s2,4752
	    
	delay_ms(10);   
80008f34:	0c001bb5 	jal	80006ed4 <delay_ms>
80008f38:	2404000a 	li	a0,10
	printf( "\n");
80008f3c:	3c048001 	lui	a0,0x8001
80008f40:	0c001cc1 	jal	80007304 <dprintf>
80008f44:	24840f54 	addiu	a0,a0,3924
	printf( "R:BIST DONE=%08x \n", REG32(BIST_DONE) );
80008f48:	36700210 	ori	s0,s3,0x210
80008f4c:	8e050000 	lw	a1,0(s0)
80008f50:	3c048001 	lui	a0,0x8001
80008f54:	0c001cc1 	jal	80007304 <dprintf>
80008f58:	248412a4 	addiu	a0,a0,4772
	printf( "R:BIST FAIL=%08x \n", REG32(BIST_FAIL) );
80008f5c:	36730220 	ori	s3,s3,0x220
80008f60:	8e650000 	lw	a1,0(s3)
80008f64:	3c048001 	lui	a0,0x8001
80008f68:	0c001cc1 	jal	80007304 <dprintf>
80008f6c:	248412b8 	addiu	a0,a0,4792


	
	if ( (REG32(BIST_DONE) == 0xffff8418) && ( REG32(BIST_FAIL) == 0x00000000)) { printf( " ==>BIST PASS \n"); }	 
80008f70:	8e030000 	lw	v1,0(s0)
80008f74:	24028418 	li	v0,-31720
80008f78:	14620009 	bne	v1,v0,80008fa0 <Cmd_AllBistTest+0x52c>
80008f7c:	00000000 	nop
80008f80:	8e620000 	lw	v0,0(s3)
80008f84:	14400006 	bnez	v0,80008fa0 <Cmd_AllBistTest+0x52c>
80008f88:	00000000 	nop
80008f8c:	3c048001 	lui	a0,0x8001
80008f90:	0c001cc1 	jal	80007304 <dprintf>
80008f94:	24841224 	addiu	a0,a0,4644
80008f98:	080023fe 	j	80008ff8 <Cmd_AllBistTest+0x584>
80008f9c:	3c048001 	lui	a0,0x8001
	else 							
	{ 	printf( " ==>BIST FAIL \n");  err++;
80008fa0:	3c048001 	lui	a0,0x8001
80008fa4:	0c001cc1 	jal	80007304 <dprintf>
80008fa8:	24841234 	addiu	a0,a0,4660
80008fac:	26310001 	addiu	s1,s1,1
		if ( REG32(BIST_DONE) != 0xffff8418) { printf( " ==>DONE FAIL \n"); }
80008fb0:	3c02b800 	lui	v0,0xb800
80008fb4:	34420210 	ori	v0,v0,0x210
80008fb8:	8c430000 	lw	v1,0(v0)
80008fbc:	24028418 	li	v0,-31720
80008fc0:	10620005 	beq	v1,v0,80008fd8 <Cmd_AllBistTest+0x564>
80008fc4:	3c02b800 	lui	v0,0xb800
80008fc8:	3c048001 	lui	a0,0x8001
80008fcc:	0c001cc1 	jal	80007304 <dprintf>
80008fd0:	24841204 	addiu	a0,a0,4612
		if ( REG32(BIST_FAIL) != 0x00000000) { printf( " ==>FAIL FAIL \n"); }	
80008fd4:	3c02b800 	lui	v0,0xb800
80008fd8:	34420220 	ori	v0,v0,0x220
80008fdc:	8c420000 	lw	v0,0(v0)
80008fe0:	10400004 	beqz	v0,80008ff4 <Cmd_AllBistTest+0x580>
80008fe4:	00000000 	nop
80008fe8:	3c048001 	lui	a0,0x8001
80008fec:	0c001cc1 	jal	80007304 <dprintf>
80008ff0:	24841214 	addiu	a0,a0,4628
		{ printf( " ==>DRF PASS \n"); }	 
	printf( "============================== \n");	    
#endif
		
		
	printf( "============================== \n");
80008ff4:	3c048001 	lui	a0,0x8001
80008ff8:	0c001cc1 	jal	80007304 <dprintf>
80008ffc:	248412cc 	addiu	a0,a0,4812
	printf( "Mode x DRF_BIST TEST : IP \n");
80009000:	3c048001 	lui	a0,0x8001
80009004:	0c001cc1 	jal	80007304 <dprintf>
80009008:	24841328 	addiu	a0,a0,4904
	REG32( 0xb800020c)=0x001e0000;
8000900c:	3c10b800 	lui	s0,0xb800
80009010:	3602020c 	ori	v0,s0,0x20c
80009014:	3c03001e 	lui	v1,0x1e
80009018:	ac430000 	sw	v1,0(v0)
	REG32( 0xb8000200)=0x00000002;
8000901c:	36020200 	ori	v0,s0,0x200
80009020:	24030002 	li	v1,2
80009024:	ac430000 	sw	v1,0(v0)
//	REG32( 0xb8000208)=0x007f007f;   //skip mbr
	//
	REG32( 0xb8000200)=0x0fff0002;
80009028:	3c030fff 	lui	v1,0xfff
8000902c:	34630002 	ori	v1,v1,0x2
80009030:	ac430000 	sw	v1,0(v0)


	printf( "4.pause\n");    
80009034:	3c048001 	lui	a0,0x8001
80009038:	0c001cc1 	jal	80007304 <dprintf>
8000903c:	24841344 	addiu	a0,a0,4932
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE    ));
80009040:	36140270 	ori	s4,s0,0x270
80009044:	8e850000 	lw	a1,0(s4)
80009048:	3c158001 	lui	s5,0x8001
8000904c:	0c001cc1 	jal	80007304 <dprintf>
80009050:	26a41350 	addiu	a0,s5,4944
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif


	printf( "5.resume\n");   
80009054:	3c048001 	lui	a0,0x8001
80009058:	0c001cc1 	jal	80007304 <dprintf>
8000905c:	24841364 	addiu	a0,a0,4964
	REG32(DRF_RESUME) = 0xffffffff;
80009060:	36120280 	ori	s2,s0,0x280
80009064:	2413ffff 	li	s3,-1
80009068:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME) );    
8000906c:	8e450000 	lw	a1,0(s2)
80009070:	3c168001 	lui	s6,0x8001
80009074:	0c001cc1 	jal	80007304 <dprintf>
80009078:	26c41370 	addiu	a0,s6,4976

	printf( "6.two pause\n");      
8000907c:	3c048001 	lui	a0,0x8001
80009080:	0c001cc1 	jal	80007304 <dprintf>
80009084:	24841388 	addiu	a0,a0,5000
	printf( " R:DRF_PAUSE=%08x \n", REG32(DRF_PAUSE) );    
80009088:	8e850000 	lw	a1,0(s4)
8000908c:	0c001cc1 	jal	80007304 <dprintf>
80009090:	26a41350 	addiu	a0,s5,4944
#if 0 //skip mbr	 
	printf( " R:HS0_DRF_PAUSE=%08x \n", REG32(HS0_DRF_PAUSE ));
	if ( REG32(HS0_DRF_PAUSE) == 0xffffffff) { printf( " ==>PAUSE PASS \n"); }
	if ( REG32(HS0_DRF_PAUSE) != 0xffffffff) { printf( " ==>PAUSE FAIL \n"); }
#endif	    
	printf( "7.two resume\n");    
80009094:	3c048001 	lui	a0,0x8001
80009098:	0c001cc1 	jal	80007304 <dprintf>
8000909c:	24841398 	addiu	a0,a0,5016
	REG32(DRF_RESUME) = 0xffffffff;
800090a0:	ae530000 	sw	s3,0(s2)
		printf( " W:DRF_RESUME=%08x \n", REG32(DRF_RESUME ) ); 
800090a4:	8e450000 	lw	a1,0(s2)
800090a8:	0c001cc1 	jal	80007304 <dprintf>
800090ac:	26c41370 	addiu	a0,s6,4976
	  
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
800090b0:	36120290 	ori	s2,s0,0x290
800090b4:	8e450000 	lw	a1,0(s2)
800090b8:	3c048001 	lui	a0,0x8001
800090bc:	0c001cc1 	jal	80007304 <dprintf>
800090c0:	248413a8 	addiu	a0,a0,5032
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );
800090c4:	361002a0 	ori	s0,s0,0x2a0
800090c8:	8e050000 	lw	a1,0(s0)
800090cc:	3c048001 	lui	a0,0x8001
800090d0:	0c001cc1 	jal	80007304 <dprintf>
800090d4:	248413bc 	addiu	a0,a0,5052



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
800090d8:	8e420000 	lw	v0,0(s2)
800090dc:	14530009 	bne	v0,s3,80009104 <Cmd_AllBistTest+0x690>
800090e0:	00000000 	nop
800090e4:	8e020000 	lw	v0,0(s0)
800090e8:	14400006 	bnez	v0,80009104 <Cmd_AllBistTest+0x690>
800090ec:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
800090f0:	3c048001 	lui	a0,0x8001
800090f4:	0c001cc1 	jal	80007304 <dprintf>
800090f8:	248413d0 	addiu	a0,a0,5072
	printf( " R:DRF_DONE=%08x \n", REG32(DRF_DONE) );
	printf( " R:DRF_FAIL=%08x \n", REG32(DRF_FAIL) );



	if ( (REG32(DRF_DONE)==0xffffffff) &&( REG32(DRF_FAIL)==0) ) 
800090fc:	08002456 	j	80009158 <Cmd_AllBistTest+0x6e4>
80009100:	00000000 	nop
		{ printf( " ==>DRF PASS \n"); }	 
	else	
	{ 
		printf( " ==>DRF FAIL \n");  err++;
80009104:	3c048001 	lui	a0,0x8001
80009108:	0c001cc1 	jal	80007304 <dprintf>
8000910c:	248413e0 	addiu	a0,a0,5088
80009110:	26310001 	addiu	s1,s1,1
		if ( REG32(DRF_DONE) != 0xffffffff) { printf( " ==>DRF DONE FAIL \n"); }	    
80009114:	3c02b800 	lui	v0,0xb800
80009118:	34420290 	ori	v0,v0,0x290
8000911c:	8c430000 	lw	v1,0(v0)
80009120:	2402ffff 	li	v0,-1
80009124:	10620005 	beq	v1,v0,8000913c <Cmd_AllBistTest+0x6c8>
80009128:	3c02b800 	lui	v0,0xb800
8000912c:	3c048001 	lui	a0,0x8001
80009130:	0c001cc1 	jal	80007304 <dprintf>
80009134:	248413f0 	addiu	a0,a0,5104
		if ( REG32(DRF_FAIL) != 0) { printf( " ==>FAIL FAIL \n"); }		
80009138:	3c02b800 	lui	v0,0xb800
8000913c:	344202a0 	ori	v0,v0,0x2a0
80009140:	8c420000 	lw	v0,0(v0)
80009144:	10400004 	beqz	v0,80009158 <Cmd_AllBistTest+0x6e4>
80009148:	00000000 	nop
8000914c:	3c048001 	lui	a0,0x8001
80009150:	0c001cc1 	jal	80007304 <dprintf>
80009154:	24841214 	addiu	a0,a0,4628
	}	


	if(err==0)
80009158:	16200005 	bnez	s1,80009170 <Cmd_AllBistTest+0x6fc>
8000915c:	3c048001 	lui	a0,0x8001
		printf("==> IP BIST ALL PASS <== \n");
80009160:	0c001cc1 	jal	80007304 <dprintf>
80009164:	24841404 	addiu	a0,a0,5124
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		

}
80009168:	08002461 	j	80009184 <Cmd_AllBistTest+0x710>
8000916c:	8fbf002c 	lw	ra,44(sp)


	if(err==0)
		printf("==> IP BIST ALL PASS <== \n");
	else
		printf("==> IP BIST FAIL count=%d <== \n", err);		
80009170:	3c048001 	lui	a0,0x8001
80009174:	24841420 	addiu	a0,a0,5152
80009178:	0c001cc1 	jal	80007304 <dprintf>
8000917c:	02202821 	move	a1,s1

}
80009180:	8fbf002c 	lw	ra,44(sp)
80009184:	8fb60028 	lw	s6,40(sp)
80009188:	8fb50024 	lw	s5,36(sp)
8000918c:	8fb40020 	lw	s4,32(sp)
80009190:	8fb3001c 	lw	s3,28(sp)
80009194:	8fb20018 	lw	s2,24(sp)
80009198:	8fb10014 	lw	s1,20(sp)
8000919c:	8fb00010 	lw	s0,16(sp)
800091a0:	03e00008 	jr	ra
800091a4:	27bd0030 	addiu	sp,sp,48

800091a8 <GPHY_DRF_BIST>:
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
//=============================================================================
int GPHY_DRF_BIST(int argc, char* argv[])
{
800091a8:	27bdffb0 	addiu	sp,sp,-80
800091ac:	afbf004c 	sw	ra,76(sp)
800091b0:	afbe0048 	sw	s8,72(sp)
800091b4:	afb70044 	sw	s7,68(sp)
800091b8:	afb60040 	sw	s6,64(sp)
800091bc:	afb5003c 	sw	s5,60(sp)
800091c0:	afb40038 	sw	s4,56(sp)
800091c4:	afb30034 	sw	s3,52(sp)
800091c8:	afb20030 	sw	s2,48(sp)
800091cc:	afb1002c 	sw	s1,44(sp)
800091d0:	afb00028 	sw	s0,40(sp)
	volatile unsigned int phyid=4,rdat=0;
800091d4:	24020004 	li	v0,4
800091d8:	afa20018 	sw	v0,24(sp)
800091dc:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

//	dprintf("Set P0-P4 force mode...... \n");
	REG32(0xbb804104)= 0x427f0038;
800091e0:	3c02bb80 	lui	v0,0xbb80
800091e4:	34434104 	ori	v1,v0,0x4104
800091e8:	3c04427f 	lui	a0,0x427f
800091ec:	34840038 	ori	a0,a0,0x38
800091f0:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
800091f4:	34434108 	ori	v1,v0,0x4108
800091f8:	3c04467f 	lui	a0,0x467f
800091fc:	34840038 	ori	a0,a0,0x38
80009200:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
80009204:	3443410c 	ori	v1,v0,0x410c
80009208:	3c044a7f 	lui	a0,0x4a7f
8000920c:	34840038 	ori	a0,a0,0x38
80009210:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
80009214:	34434110 	ori	v1,v0,0x4110
80009218:	3c044e7f 	lui	a0,0x4e7f
8000921c:	34840038 	ori	a0,a0,0x38
80009220:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
80009224:	34434114 	ori	v1,v0,0x4114
80009228:	3c04527f 	lui	a0,0x527f
8000922c:	34840038 	ori	a0,a0,0x38
80009230:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;
80009234:	34424118 	ori	v0,v0,0x4118
80009238:	3c03566f 	lui	v1,0x566f
8000923c:	34630038 	ori	v1,v1,0x38
80009240:	ac430000 	sw	v1,0(v0)
	
//	void Set_GPHYWB(unsigned int phyid, unsigned int page, unsigned int reg, unsigned int mask, unsigned int val)
//	Set_GPHYWB(8, 24, 22, 0, 0x5bd5);
	
		
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
80009244:	3410c000 	li	s0,0xc000
80009248:	afb00010 	sw	s0,16(sp)
8000924c:	00002021 	move	a0,zero
80009250:	24050c40 	li	a1,3136
80009254:	24060015 	li	a2,21
80009258:	0c000a35 	jal	800028d4 <Set_GPHYWB>
8000925c:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xa00, 23, 0, 0xc000);
80009260:	afb00010 	sw	s0,16(sp)
80009264:	00002021 	move	a0,zero
80009268:	24050a00 	li	a1,2560
8000926c:	24060017 	li	a2,23
80009270:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009274:	00003821 	move	a3,zero

	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0120 );		
80009278:	00002021 	move	a0,zero
8000927c:	24050017 	li	a1,23
80009280:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009284:	24060120 	li	a2,288
	
	//
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
80009288:	afa00010 	sw	zero,16(sp)
8000928c:	00002021 	move	a0,zero
80009290:	24050b81 	li	a1,2945
80009294:	24060012 	li	a2,18
80009298:	0c000a35 	jal	800028d4 <Set_GPHYWB>
8000929c:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x0005 );		
800092a0:	00002021 	move	a0,zero
800092a4:	24050012 	li	a1,18
800092a8:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800092ac:	24060005 	li	a2,5

	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);			
800092b0:	afa00010 	sw	zero,16(sp)
800092b4:	00002021 	move	a0,zero
800092b8:	24050c84 	li	a1,3204
800092bc:	24060016 	li	a2,22
800092c0:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800092c4:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0007 );		
800092c8:	00002021 	move	a0,zero
800092cc:	24050016 	li	a1,22
800092d0:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800092d4:	24060007 	li	a2,7


	delay_ms(1000);
800092d8:	0c001bb5 	jal	80006ed4 <delay_ms>
800092dc:	240403e8 	li	a0,1000

	
	//resume
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
800092e0:	24100040 	li	s0,64
800092e4:	afb00010 	sw	s0,16(sp)
800092e8:	00002021 	move	a0,zero
800092ec:	24050a00 	li	a1,2560
800092f0:	24060017 	li	a2,23
800092f4:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800092f8:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
800092fc:	afa00010 	sw	zero,16(sp)
80009300:	00002021 	move	a0,zero
80009304:	24050a00 	li	a1,2560
80009308:	24060017 	li	a2,23
8000930c:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009310:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
80009314:	24110400 	li	s1,1024
80009318:	afb10010 	sw	s1,16(sp)
8000931c:	00002021 	move	a0,zero
80009320:	24050b81 	li	a1,2945
80009324:	24060012 	li	a2,18
80009328:	0c000a35 	jal	800028d4 <Set_GPHYWB>
8000932c:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);			
80009330:	24121000 	li	s2,4096
80009334:	afb20010 	sw	s2,16(sp)
80009338:	00002021 	move	a0,zero
8000933c:	24050c84 	li	a1,3204
80009340:	24060017 	li	a2,23
80009344:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009348:	3407ffff 	li	a3,0xffff
	
	
	delay_ms(1000);
8000934c:	0c001bb5 	jal	80006ed4 <delay_ms>
80009350:	240403e8 	li	a0,1000
	Set_GPHYWB(0, 0xa00, 23, 0xffff, 0x0040);
80009354:	afb00010 	sw	s0,16(sp)
80009358:	00002021 	move	a0,zero
8000935c:	24050a00 	li	a1,2560
80009360:	24060017 	li	a2,23
80009364:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009368:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xa00, 23, 0xffbf, 0x0000);
8000936c:	afa00010 	sw	zero,16(sp)
80009370:	00002021 	move	a0,zero
80009374:	24050a00 	li	a1,2560
80009378:	24060017 	li	a2,23
8000937c:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009380:	3407ffbf 	li	a3,0xffbf
	Set_GPHYWB(0, 0xb81, 18, 0xffff, 0x0400);
80009384:	afb10010 	sw	s1,16(sp)
80009388:	00002021 	move	a0,zero
8000938c:	24050b81 	li	a1,2945
80009390:	24060012 	li	a2,18
80009394:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009398:	3407ffff 	li	a3,0xffff
	Set_GPHYWB(0, 0xc84, 23, 0xffff, 0x1000);
8000939c:	afb20010 	sw	s2,16(sp)
800093a0:	00002021 	move	a0,zero
800093a4:	24050c84 	li	a1,3204
800093a8:	24060017 	li	a2,23
800093ac:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800093b0:	3407ffff 	li	a3,0xffff
	
	delay_ms(1000);
800093b4:	0c001bb5 	jal	80006ed4 <delay_ms>
800093b8:	240403e8 	li	a0,1000
800093bc:	00008821 	move	s1,zero
800093c0:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
800093c4:	27b3001c 	addiu	s3,sp,28
		printf("get data=%x\n", rdat);
800093c8:	3c128001 	lui	s2,0x8001
800093cc:	26521440 	addiu	s2,s2,5184
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
800093d0:	24150800 	li	s5,2048
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
800093d4:	3c148001 	lui	s4,0x8001
800093d8:	26941464 	addiu	s4,s4,5220
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
800093dc:	3c028001 	lui	v0,0x8001
800093e0:	24421450 	addiu	v0,v0,5200
800093e4:	afa20020 	sw	v0,32(sp)
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
800093e8:	24164000 	li	s6,16384
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
800093ec:	24170004 	li	s7,4
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
800093f0:	241e0005 	li	s8,5
	{	
		if(i==0) phyid=8;
800093f4:	16000004 	bnez	s0,80009408 <GPHY_DRF_BIST+0x260>
800093f8:	24020008 	li	v0,8
800093fc:	afa20018 	sw	v0,24(sp)
80009400:	08002503 	j	8000940c <GPHY_DRF_BIST+0x264>
80009404:	00000000 	nop
		else phyid=i;
80009408:	afb00018 	sw	s0,24(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
8000940c:	8fa40018 	lw	a0,24(sp)
80009410:	2405001f 	li	a1,31
80009414:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009418:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
8000941c:	8fa40018 	lw	a0,24(sp)
80009420:	24050017 	li	a1,23
80009424:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80009428:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
8000942c:	8fa5001c 	lw	a1,28(sp)
80009430:	0c001cc1 	jal	80007304 <dprintf>
80009434:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<9))== (0x4<<9)) 	printf("Port %d BIST PASS\n",i);
80009438:	8fa2001c 	lw	v0,28(sp)
8000943c:	30421e00 	andi	v0,v0,0x1e00
80009440:	14550006 	bne	v0,s5,8000945c <GPHY_DRF_BIST+0x2b4>
80009444:	00000000 	nop
80009448:	8fa40020 	lw	a0,32(sp)
8000944c:	0c001cc1 	jal	80007304 <dprintf>
80009450:	02002821 	move	a1,s0
80009454:	0800251b 	j	8000946c <GPHY_DRF_BIST+0x2c4>
80009458:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);  err++; }
8000945c:	02802021 	move	a0,s4
80009460:	0c001cc1 	jal	80007304 <dprintf>
80009464:	02002821 	move	a1,s0
80009468:	26310001 	addiu	s1,s1,1
			
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
8000946c:	8fa40018 	lw	a0,24(sp)
80009470:	2405001f 	li	a1,31
80009474:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009478:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );	
8000947c:	8fa40018 	lw	a0,24(sp)
80009480:	24050012 	li	a1,18
80009484:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80009488:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
8000948c:	8fa5001c 	lw	a1,28(sp)
80009490:	0c001cc1 	jal	80007304 <dprintf>
80009494:	02402021 	move	a0,s2
		
		if((rdat&(0xf<<12))== (0x4<<12)) 	printf("Port %d BIST PASS\n",i);
80009498:	8fa2001c 	lw	v0,28(sp)
8000949c:	3042f000 	andi	v0,v0,0xf000
800094a0:	14560006 	bne	v0,s6,800094bc <GPHY_DRF_BIST+0x314>
800094a4:	00000000 	nop
800094a8:	8fa40020 	lw	a0,32(sp)
800094ac:	0c001cc1 	jal	80007304 <dprintf>
800094b0:	02002821 	move	a1,s0
800094b4:	08002533 	j	800094cc <GPHY_DRF_BIST+0x324>
800094b8:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
800094bc:	02802021 	move	a0,s4
800094c0:	0c001cc1 	jal	80007304 <dprintf>
800094c4:	02002821 	move	a1,s0
800094c8:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
800094cc:	8fa40018 	lw	a0,24(sp)
800094d0:	2405001f 	li	a1,31
800094d4:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800094d8:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
800094dc:	8fa40018 	lw	a0,24(sp)
800094e0:	24050017 	li	a1,23
800094e4:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
800094e8:	02603021 	move	a2,s3
		printf("get data=%x\n", rdat);
800094ec:	8fa5001c 	lw	a1,28(sp)
800094f0:	0c001cc1 	jal	80007304 <dprintf>
800094f4:	02402021 	move	a0,s2
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
800094f8:	8fa2001c 	lw	v0,28(sp)
800094fc:	30420007 	andi	v0,v0,0x7
80009500:	14570006 	bne	v0,s7,8000951c <GPHY_DRF_BIST+0x374>
80009504:	02802021 	move	a0,s4
80009508:	8fa40020 	lw	a0,32(sp)
8000950c:	0c001cc1 	jal	80007304 <dprintf>
80009510:	02002821 	move	a1,s0
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
80009514:	0800254b 	j	8000952c <GPHY_DRF_BIST+0x384>
80009518:	26100001 	addiu	s0,s0,1
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
8000951c:	0c001cc1 	jal	80007304 <dprintf>
80009520:	02002821 	move	a1,s0
80009524:	26310001 	addiu	s1,s1,1
	
	delay_ms(1000);
	

	
	for(i=0;i<5;i++)
80009528:	26100001 	addiu	s0,s0,1
8000952c:	161effb1 	bne	s0,s8,800093f4 <GPHY_DRF_BIST+0x24c>
80009530:	24050c40 	li	a1,3136
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i);	err++; }
		
	}	
	
	Set_GPHYWB(0, 0xc40, 21, 0, 0x0000);
80009534:	afa00010 	sw	zero,16(sp)
80009538:	00002021 	move	a0,zero
8000953c:	24060015 	li	a2,21
80009540:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009544:	00003821 	move	a3,zero

	
	//=================
	if(err==0)
80009548:	16200005 	bnez	s1,80009560 <GPHY_DRF_BIST+0x3b8>
8000954c:	3c048001 	lui	a0,0x8001
		printf("==> GPHY BIST ALL PASS <== \n");
80009550:	0c001cc1 	jal	80007304 <dprintf>
80009554:	24841478 	addiu	a0,a0,5240
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
			
}
80009558:	0800255d 	j	80009574 <GPHY_DRF_BIST+0x3cc>
8000955c:	8fbf004c 	lw	ra,76(sp)
	
	//=================
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);	
80009560:	3c048001 	lui	a0,0x8001
80009564:	24841498 	addiu	a0,a0,5272
80009568:	0c001cc1 	jal	80007304 <dprintf>
8000956c:	02202821 	move	a1,s1
			
}
80009570:	8fbf004c 	lw	ra,76(sp)
80009574:	8fbe0048 	lw	s8,72(sp)
80009578:	8fb70044 	lw	s7,68(sp)
8000957c:	8fb60040 	lw	s6,64(sp)
80009580:	8fb5003c 	lw	s5,60(sp)
80009584:	8fb40038 	lw	s4,56(sp)
80009588:	8fb30034 	lw	s3,52(sp)
8000958c:	8fb20030 	lw	s2,48(sp)
80009590:	8fb1002c 	lw	s1,44(sp)
80009594:	8fb00028 	lw	s0,40(sp)
80009598:	03e00008 	jr	ra
8000959c:	27bd0050 	addiu	sp,sp,80

800095a0 <GPHY_BIST>:

//=========================================================

//=========================================================
int GPHY_BIST(int argc, char* argv[])
{
800095a0:	27bdffa8 	addiu	sp,sp,-88
800095a4:	afbf0054 	sw	ra,84(sp)
800095a8:	afbe0050 	sw	s8,80(sp)
800095ac:	afb7004c 	sw	s7,76(sp)
800095b0:	afb60048 	sw	s6,72(sp)
800095b4:	afb50044 	sw	s5,68(sp)
800095b8:	afb40040 	sw	s4,64(sp)
800095bc:	afb3003c 	sw	s3,60(sp)
800095c0:	afb20038 	sw	s2,56(sp)
800095c4:	afb10034 	sw	s1,52(sp)
800095c8:	afb00030 	sw	s0,48(sp)
	volatile unsigned int phyid=4,rdat=0;
800095cc:	24020004 	li	v0,4
800095d0:	afa20018 	sw	v0,24(sp)
800095d4:	afa0001c 	sw	zero,28(sp)
	int i;
	int err=0;

	dprintf("Set P0-P4 force mode...... \n");
800095d8:	3c048001 	lui	a0,0x8001
800095dc:	0c001cc1 	jal	80007304 <dprintf>
800095e0:	248414bc 	addiu	a0,a0,5308
	REG32(0xbb804104)= 0x427f0038;
800095e4:	3c02bb80 	lui	v0,0xbb80
800095e8:	34434104 	ori	v1,v0,0x4104
800095ec:	3c04427f 	lui	a0,0x427f
800095f0:	34840038 	ori	a0,a0,0x38
800095f4:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804108)= 0x467f0038;
800095f8:	34434108 	ori	v1,v0,0x4108
800095fc:	3c04467f 	lui	a0,0x467f
80009600:	34840038 	ori	a0,a0,0x38
80009604:	ac640000 	sw	a0,0(v1)
	REG32(0xbb80410c)= 0x4a7f0038;
80009608:	3443410c 	ori	v1,v0,0x410c
8000960c:	3c044a7f 	lui	a0,0x4a7f
80009610:	34840038 	ori	a0,a0,0x38
80009614:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804110)= 0x4e7f0038;
80009618:	34434110 	ori	v1,v0,0x4110
8000961c:	3c044e7f 	lui	a0,0x4e7f
80009620:	34840038 	ori	a0,a0,0x38
80009624:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804114)= 0x527f0038;
80009628:	34434114 	ori	v1,v0,0x4114
8000962c:	3c04527f 	lui	a0,0x527f
80009630:	34840038 	ori	a0,a0,0x38
80009634:	ac640000 	sw	a0,0(v1)
	REG32(0xbb804118)= 0x566f0038;	
80009638:	34424118 	ori	v0,v0,0x4118
8000963c:	3c03566f 	lui	v1,0x566f
80009640:	34630038 	ori	v1,v1,0x38
80009644:	ac430000 	sw	v1,0(v0)
	
	//
	rtl8651_setAsicEthernetPHYReg(8, 24, 0x2198 );		
80009648:	24040008 	li	a0,8
8000964c:	24050018 	li	a1,24
80009650:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009654:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(1, 24, 0x2198 );	
80009658:	24040001 	li	a0,1
8000965c:	24050018 	li	a1,24
80009660:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009664:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(2, 24, 0x2198 );	
80009668:	24040002 	li	a0,2
8000966c:	24050018 	li	a1,24
80009670:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009674:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(3, 24, 0x2198 );
80009678:	24040003 	li	a0,3
8000967c:	24050018 	li	a1,24
80009680:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009684:	24062198 	li	a2,8600
	rtl8651_setAsicEthernetPHYReg(4, 24, 0x2198 );	
80009688:	24040004 	li	a0,4
8000968c:	24050018 	li	a1,24
80009690:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009694:	24062198 	li	a2,8600
	
	//
	Set_GPHYWB(0, 0xA40, 0, 0, 0x1140);
80009698:	24021140 	li	v0,4416
8000969c:	afa20010 	sw	v0,16(sp)
800096a0:	00002021 	move	a0,zero
800096a4:	24050a40 	li	a1,2624
800096a8:	00003021 	move	a2,zero
800096ac:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800096b0:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA46, 20, 0, 0x0003);	
800096b4:	24020003 	li	v0,3
800096b8:	afa20010 	sw	v0,16(sp)
800096bc:	00002021 	move	a0,zero
800096c0:	24050a46 	li	a1,2630
800096c4:	24060014 	li	a2,20
800096c8:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800096cc:	00003821 	move	a3,zero
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
800096d0:	00002021 	move	a0,zero
800096d4:	2405001f 	li	a1,31
800096d8:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800096dc:	24060a42 	li	a2,2626
800096e0:	00008821 	move	s1,zero
800096e4:	00008021 	move	s0,zero
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
800096e8:	24170008 	li	s7,8
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
800096ec:	27b5001c 	addiu	s5,sp,28
		printf("get data=%x\n", rdat);
800096f0:	3c128001 	lui	s2,0x8001
800096f4:	26521440 	addiu	s2,s2,5184
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
800096f8:	24130003 	li	s3,3
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
800096fc:	3c168001 	lui	s6,0x8001
80009700:	26d614f4 	addiu	s6,s6,5364
	for(i=0;i<5;i++)
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
80009704:	3c1e8001 	lui	s8,0x8001
80009708:	27de14dc 	addiu	s8,s8,5340
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
8000970c:	24140005 	li	s4,5
	{
		if(i==0) phyid=8;
80009710:	16000002 	bnez	s0,8000971c <GPHY_BIST+0x17c>
80009714:	00000000 	nop
80009718:	afb70018 	sw	s7,24(sp)
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
8000971c:	8fa40018 	lw	a0,24(sp)
80009720:	24050010 	li	a1,16
80009724:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80009728:	02a03021 	move	a2,s5
		printf("get data=%x\n", rdat);
8000972c:	8fa5001c 	lw	a1,28(sp)
80009730:	0c001cc1 	jal	80007304 <dprintf>
80009734:	02402021 	move	a0,s2
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
80009738:	8fa2001c 	lw	v0,28(sp)
8000973c:	30420007 	andi	v0,v0,0x7
80009740:	14530006 	bne	v0,s3,8000975c <GPHY_BIST+0x1bc>
80009744:	02c02021 	move	a0,s6
80009748:	03c02021 	move	a0,s8
8000974c:	0c001cc1 	jal	80007304 <dprintf>
80009750:	02002821 	move	a1,s0
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
80009754:	080025db 	j	8000976c <GPHY_BIST+0x1cc>
80009758:	26100001 	addiu	s0,s0,1
	{
		if(i==0) phyid=8;
		rtl8651_getAsicEthernetPHYReg(phyid, 16, &rdat );
		printf("get data=%x\n", rdat);
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
8000975c:	0c001cc1 	jal	80007304 <dprintf>
80009760:	02002821 	move	a1,s0
80009764:	26310001 	addiu	s1,s1,1
//	Set_GPHYWB(0, 0xA4A, 19, 0, 0x001f);	
//	Set_GPHYWB(0, 0xB80, 23, 0, 0x000e);	
	
	//
	rtl8651_setAsicEthernetPHYReg(0, 31,0x0a42 );		
	for(i=0;i<5;i++)
80009768:	26100001 	addiu	s0,s0,1
8000976c:	1614ffe8 	bne	s0,s4,80009710 <GPHY_BIST+0x170>
80009770:	3402c000 	li	v0,0xc000
		if((rdat&0x7)==	0x3) 	printf("Port %d PCS ready PASS\n",i);
		else 			{ printf("Port %d PCS ready FAIL\n",i); err++; }
	}
	
	//3. m3 bist
	Set_GPHYWB(0, 0xc40, 21, 0, 0xc000);
80009774:	afa20010 	sw	v0,16(sp)
80009778:	00002021 	move	a0,zero
8000977c:	24050c40 	li	a1,3136
80009780:	24060015 	li	a2,21
80009784:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009788:	00003821 	move	a3,zero
	Set_GPHYWB(0, 0xA00, 20, 0, 0x0000);	
8000978c:	afa00010 	sw	zero,16(sp)
80009790:	00002021 	move	a0,zero
80009794:	24050a00 	li	a1,2560
80009798:	24060014 	li	a2,20
8000979c:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800097a0:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 20, 0x0060 );			
800097a4:	00002021 	move	a0,zero
800097a8:	24050014 	li	a1,20
800097ac:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800097b0:	24060060 	li	a2,96
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x0000 );	
800097b4:	00002021 	move	a0,zero
800097b8:	24050017 	li	a1,23
800097bc:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800097c0:	00003021 	move	a2,zero
	rtl8651_setAsicEthernetPHYReg(0, 23, 0x00a0 );	
800097c4:	00002021 	move	a0,zero
800097c8:	24050017 	li	a1,23
800097cc:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800097d0:	240600a0 	li	a2,160
	Set_GPHYWB(0, 0xb81, 18, 0, 0x0000);
800097d4:	afa00010 	sw	zero,16(sp)
800097d8:	00002021 	move	a0,zero
800097dc:	24050b81 	li	a1,2945
800097e0:	24060012 	li	a2,18
800097e4:	0c000a35 	jal	800028d4 <Set_GPHYWB>
800097e8:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 18, 0x001b );					
800097ec:	00002021 	move	a0,zero
800097f0:	24050012 	li	a1,18
800097f4:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800097f8:	2406001b 	li	a2,27
	Set_GPHYWB(0, 0xc84, 22, 0, 0x0000);	
800097fc:	afa00010 	sw	zero,16(sp)
80009800:	00002021 	move	a0,zero
80009804:	24050c84 	li	a1,3204
80009808:	24060016 	li	a2,22
8000980c:	0c000a35 	jal	800028d4 <Set_GPHYWB>
80009810:	00003821 	move	a3,zero
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
80009814:	00002021 	move	a0,zero
80009818:	24050016 	li	a1,22
8000981c:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009820:	24060005 	li	a2,5
	
	delay_ms(100);
80009824:	0c001bb5 	jal	80006ed4 <delay_ms>
80009828:	24040064 	li	a0,100
	printf("\n");
8000982c:	3c048001 	lui	a0,0x8001
80009830:	0c001cc1 	jal	80007304 <dprintf>
80009834:	24840f54 	addiu	a0,a0,3924
80009838:	00008021 	move	s0,zero
	{	
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
8000983c:	3c128001 	lui	s2,0x8001
80009840:	26521440 	addiu	s2,s2,5184
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
80009844:	3c148001 	lui	s4,0x8001
80009848:	26941464 	addiu	s4,s4,5220
		if(i==0) phyid=8;
		else phyid=i;		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
8000984c:	3c028001 	lui	v0,0x8001
80009850:	24421450 	addiu	v0,v0,5200
80009854:	afa20020 	sw	v0,32(sp)
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
80009858:	3c158001 	lui	s5,0x8001
8000985c:	26b5152c 	addiu	s5,s5,5420
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
80009860:	3c028001 	lui	v0,0x8001
80009864:	2442150c 	addiu	v0,v0,5388
80009868:	afa20024 	sw	v0,36(sp)
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
8000986c:	3c168001 	lui	s6,0x8001
80009870:	26d6156c 	addiu	s6,s6,5484
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
		printf("get data=%x\n", rdat);
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
80009874:	3c028001 	lui	v0,0x8001
80009878:	2442154c 	addiu	v0,v0,5452
8000987c:	afa20028 	sw	v0,40(sp)
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
80009880:	3c138001 	lui	s3,0x8001
80009884:	267315a4 	addiu	s3,s3,5540
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
80009888:	3c1e8001 	lui	s8,0x8001
8000988c:	27de158c 	addiu	s8,s8,5516
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
80009890:	3c178001 	lui	s7,0x8001
80009894:	26f715d8 	addiu	s7,s7,5592
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
		printf("get data=%x\n", rdat);
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
80009898:	3c028001 	lui	v0,0x8001
8000989c:	244215bc 	addiu	v0,v0,5564
800098a0:	afa2002c 	sw	v0,44(sp)
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
	{	
		if(i==0) phyid=8;
800098a4:	16000004 	bnez	s0,800098b8 <GPHY_BIST+0x318>
800098a8:	24020008 	li	v0,8
800098ac:	afa20018 	sw	v0,24(sp)
800098b0:	0800262f 	j	800098bc <GPHY_BIST+0x31c>
800098b4:	00000000 	nop
		else phyid=i;		
800098b8:	afb00018 	sw	s0,24(sp)
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0a00 );
800098bc:	8fa40018 	lw	a0,24(sp)
800098c0:	2405001f 	li	a1,31
800098c4:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800098c8:	24060a00 	li	a2,2560
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );	
800098cc:	8fa40018 	lw	a0,24(sp)
800098d0:	24050017 	li	a1,23
800098d4:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
800098d8:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
800098dc:	8fa5001c 	lw	a1,28(sp)
800098e0:	0c001cc1 	jal	80007304 <dprintf>
800098e4:	02402021 	move	a0,s2
		if((rdat&(0xf<<9))== (0x8<<9)) 	printf("Port %d BIST PASS\n",i);
800098e8:	8fa3001c 	lw	v1,28(sp)
800098ec:	30631e00 	andi	v1,v1,0x1e00
800098f0:	24021000 	li	v0,4096
800098f4:	14620006 	bne	v1,v0,80009910 <GPHY_BIST+0x370>
800098f8:	00000000 	nop
800098fc:	8fa40020 	lw	a0,32(sp)
80009900:	0c001cc1 	jal	80007304 <dprintf>
80009904:	02002821 	move	a1,s0
80009908:	08002648 	j	80009920 <GPHY_BIST+0x380>
8000990c:	00000000 	nop
		else 			{ printf("Port %d BIST FAIL\n",i); err++; }
80009910:	02802021 	move	a0,s4
80009914:	0c001cc1 	jal	80007304 <dprintf>
80009918:	02002821 	move	a1,s0
8000991c:	26310001 	addiu	s1,s1,1
			
			
		//	
		rtl8651_getAsicEthernetPHYReg(phyid, 22, &rdat );	
80009920:	8fa40018 	lw	a0,24(sp)
80009924:	24050016 	li	a1,22
80009928:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000992c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
80009930:	8fa5001c 	lw	a1,28(sp)
80009934:	0c001cc1 	jal	80007304 <dprintf>
80009938:	02402021 	move	a0,s2
		if(rdat== 0xd279) 	printf("Port %d BIST_ROM [31:16] PASS\n",i);
8000993c:	8fa3001c 	lw	v1,28(sp)
80009940:	3402d279 	li	v0,0xd279
80009944:	14620006 	bne	v1,v0,80009960 <GPHY_BIST+0x3c0>
80009948:	00000000 	nop
8000994c:	8fa40024 	lw	a0,36(sp)
80009950:	0c001cc1 	jal	80007304 <dprintf>
80009954:	02002821 	move	a1,s0
80009958:	0800265c 	j	80009970 <GPHY_BIST+0x3d0>
8000995c:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [31:16] FAIL\n",i);	err++; }
80009960:	02a02021 	move	a0,s5
80009964:	0c001cc1 	jal	80007304 <dprintf>
80009968:	02002821 	move	a1,s0
8000996c:	26310001 	addiu	s1,s1,1
			
		//
		rtl8651_getAsicEthernetPHYReg(phyid, 21, &rdat );	
80009970:	8fa40018 	lw	a0,24(sp)
80009974:	24050015 	li	a1,21
80009978:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000997c:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
80009980:	8fa5001c 	lw	a1,28(sp)
80009984:	0c001cc1 	jal	80007304 <dprintf>
80009988:	02402021 	move	a0,s2
		if(rdat== 0xa555) 	printf("Port %d BIST_ROM [15:0] PASS\n",i);
8000998c:	8fa3001c 	lw	v1,28(sp)
80009990:	3402a555 	li	v0,0xa555
80009994:	14620006 	bne	v1,v0,800099b0 <GPHY_BIST+0x410>
80009998:	00000000 	nop
8000999c:	8fa40028 	lw	a0,40(sp)
800099a0:	0c001cc1 	jal	80007304 <dprintf>
800099a4:	02002821 	move	a1,s0
800099a8:	08002670 	j	800099c0 <GPHY_BIST+0x420>
800099ac:	00000000 	nop
		else 			{ printf("Port %d BIST_ROM [15:0] FAIL\n",i);	err++; }
800099b0:	02c02021 	move	a0,s6
800099b4:	0c001cc1 	jal	80007304 <dprintf>
800099b8:	02002821 	move	a1,s0
800099bc:	26310001 	addiu	s1,s1,1
		
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0b81 );
800099c0:	8fa40018 	lw	a0,24(sp)
800099c4:	2405001f 	li	a1,31
800099c8:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
800099cc:	24060b81 	li	a2,2945
		rtl8651_getAsicEthernetPHYReg(phyid, 18, &rdat );				
800099d0:	8fa40018 	lw	a0,24(sp)
800099d4:	24050012 	li	a1,18
800099d8:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
800099dc:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
800099e0:	8fa5001c 	lw	a1,28(sp)
800099e4:	0c001cc1 	jal	80007304 <dprintf>
800099e8:	02402021 	move	a0,s2
		if((rdat&(0xf<<12))== (0x1<<12)) 	printf("Port %d GPHY BIST PASS\n",i);
800099ec:	8fa3001c 	lw	v1,28(sp)
800099f0:	3063f000 	andi	v1,v1,0xf000
800099f4:	24021000 	li	v0,4096
800099f8:	14620006 	bne	v1,v0,80009a14 <GPHY_BIST+0x474>
800099fc:	00000000 	nop
80009a00:	03c02021 	move	a0,s8
80009a04:	0c001cc1 	jal	80007304 <dprintf>
80009a08:	02002821 	move	a1,s0
80009a0c:	08002689 	j	80009a24 <GPHY_BIST+0x484>
80009a10:	00000000 	nop
		else 			{		printf("Port %d GPHY BIST FAIL\n",i);	err++; }
80009a14:	02602021 	move	a0,s3
80009a18:	0c001cc1 	jal	80007304 <dprintf>
80009a1c:	02002821 	move	a1,s0
80009a20:	26310001 	addiu	s1,s1,1
			
			
		rtl8651_getAsicEthernetPHYReg(phyid, 19, &rdat );				
80009a24:	8fa40018 	lw	a0,24(sp)
80009a28:	24050013 	li	a1,19
80009a2c:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80009a30:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
80009a34:	8fa5001c 	lw	a1,28(sp)
80009a38:	0c001cc1 	jal	80007304 <dprintf>
80009a3c:	02402021 	move	a0,s2
		if(rdat== 0x2c34) 	printf("Port %d GPHY BIST_ROM PASS\n",i);
80009a40:	8fa3001c 	lw	v1,28(sp)
80009a44:	24022c34 	li	v0,11316
80009a48:	14620006 	bne	v1,v0,80009a64 <GPHY_BIST+0x4c4>
80009a4c:	00000000 	nop
80009a50:	8fa4002c 	lw	a0,44(sp)
80009a54:	0c001cc1 	jal	80007304 <dprintf>
80009a58:	02002821 	move	a1,s0
80009a5c:	0800269d 	j	80009a74 <GPHY_BIST+0x4d4>
80009a60:	00000000 	nop
		else 			{ printf("Port %d GPHY BIST_ROM FAIL\n",i);	err++; }
80009a64:	02e02021 	move	a0,s7
80009a68:	0c001cc1 	jal	80007304 <dprintf>
80009a6c:	02002821 	move	a1,s0
80009a70:	26310001 	addiu	s1,s1,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
80009a74:	8fa40018 	lw	a0,24(sp)
80009a78:	2405001f 	li	a1,31
80009a7c:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
80009a80:	24060c84 	li	a2,3204
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
80009a84:	8fa40018 	lw	a0,24(sp)
80009a88:	24050017 	li	a1,23
80009a8c:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
80009a90:	27a6001c 	addiu	a2,sp,28
		printf("get data=%x\n", rdat);
80009a94:	8fa5001c 	lw	a1,28(sp)
80009a98:	0c001cc1 	jal	80007304 <dprintf>
80009a9c:	02402021 	move	a0,s2
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
80009aa0:	8fa3001c 	lw	v1,28(sp)
80009aa4:	30630007 	andi	v1,v1,0x7
80009aa8:	24020004 	li	v0,4
80009aac:	14620006 	bne	v1,v0,80009ac8 <GPHY_BIST+0x528>
80009ab0:	02602021 	move	a0,s3
80009ab4:	03c02021 	move	a0,s8
80009ab8:	0c001cc1 	jal	80007304 <dprintf>
80009abc:	02002821 	move	a1,s0
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
80009ac0:	080026b6 	j	80009ad8 <GPHY_BIST+0x538>
80009ac4:	26100001 	addiu	s0,s0,1
			
		rtl8651_setAsicEthernetPHYReg(phyid, 31,0x0c84 );
		rtl8651_getAsicEthernetPHYReg(phyid, 23, &rdat );				
		printf("get data=%x\n", rdat);
		if((rdat&(0x7<<0))== (0x4<<0)) 	printf("Port %d GPHY BIST PASS\n",i);
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
80009ac8:	0c001cc1 	jal	80007304 <dprintf>
80009acc:	02002821 	move	a1,s0
80009ad0:	26310001 	addiu	s1,s1,1
	rtl8651_setAsicEthernetPHYReg(0, 22, 0x0005 );	
	
	delay_ms(100);
	printf("\n");
	
	for(i=0;i<5;i++)
80009ad4:	26100001 	addiu	s0,s0,1
80009ad8:	24020005 	li	v0,5
80009adc:	1602ff71 	bne	s0,v0,800098a4 <GPHY_BIST+0x304>
80009ae0:	00000000 	nop
		else 			{	printf("Port %d GPHY BIST FAIL\n",i);	err++; }
					
						
	}	
	
	if(err==0)
80009ae4:	16200005 	bnez	s1,80009afc <GPHY_BIST+0x55c>
80009ae8:	3c048001 	lui	a0,0x8001
		printf("==> GPHY BIST ALL PASS <== \n");
80009aec:	0c001cc1 	jal	80007304 <dprintf>
80009af0:	24841478 	addiu	a0,a0,5240
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
}
80009af4:	080026c4 	j	80009b10 <GPHY_BIST+0x570>
80009af8:	8fbf0054 	lw	ra,84(sp)
	}	
	
	if(err==0)
		printf("==> GPHY BIST ALL PASS <== \n");
	else
		printf("==> GPHY BIST FAIL count=%d <== \n", err);				
80009afc:	3c048001 	lui	a0,0x8001
80009b00:	24841498 	addiu	a0,a0,5272
80009b04:	0c001cc1 	jal	80007304 <dprintf>
80009b08:	02202821 	move	a1,s1
}
80009b0c:	8fbf0054 	lw	ra,84(sp)
80009b10:	8fbe0050 	lw	s8,80(sp)
80009b14:	8fb7004c 	lw	s7,76(sp)
80009b18:	8fb60048 	lw	s6,72(sp)
80009b1c:	8fb50044 	lw	s5,68(sp)
80009b20:	8fb40040 	lw	s4,64(sp)
80009b24:	8fb3003c 	lw	s3,60(sp)
80009b28:	8fb20038 	lw	s2,56(sp)
80009b2c:	8fb10034 	lw	s1,52(sp)
80009b30:	8fb00030 	lw	s0,48(sp)
80009b34:	03e00008 	jr	ra
80009b38:	27bd0058 	addiu	sp,sp,88

80009b3c <ExtractACmdLine>:

};  

//return position 
unsigned int ExtractACmdLine(const char *pPattScript,  char *pOneCmdString, int first)
{
80009b3c:	27bdffe0 	addiu	sp,sp,-32
80009b40:	afbf001c 	sw	ra,28(sp)
80009b44:	afb20018 	sw	s2,24(sp)
80009b48:	afb10014 	sw	s1,20(sp)
80009b4c:	afb00010 	sw	s0,16(sp)
80009b50:	00809021 	move	s2,a0
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
80009b54:	3c028001 	lui	v0,0x8001
80009b58:	8c504130 	lw	s0,16688(v0)
	int push=0;
	
	if(first==1)
80009b5c:	24020001 	li	v0,1
80009b60:	14c20005 	bne	a2,v0,80009b78 <ExtractACmdLine+0x3c>
80009b64:	00a08821 	move	s1,a1
	{	idx=0;
80009b68:	3c028001 	lui	v0,0x8001
80009b6c:	ac404130 	sw	zero,16688(v0)
		return 0;
80009b70:	0800272f 	j	80009cbc <ExtractACmdLine+0x180>
80009b74:	00001021 	move	v0,zero
{
	//first=1 reset index, to buffer head
	//first=0 continue read a line

	static unsigned int idx=0;
	unsigned char *p=pPattScript+idx;
80009b78:	00908021 	addu	s0,a0,s0
	if(first==1)
	{	idx=0;
		return 0;
	}
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );
80009b7c:	00a02021 	move	a0,a1
80009b80:	00002821 	move	a1,zero
80009b84:	0c0019d9 	jal	80006764 <memset>
80009b88:	24060080 	li	a2,128
80009b8c:	02204821 	move	t1,s1
80009b90:	240a0001 	li	t2,1
80009b94:	00004021 	move	t0,zero
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
80009b98:	2403000d 	li	v1,13
80009b9c:	2404000a 	li	a0,10
80009ba0:	24060009 	li	a2,9
80009ba4:	24070020 	li	a3,32
				p++;
		}

		if ((n==0) && (*p =='~') )
80009ba8:	240b007e 	li	t3,126


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
80009bac:	240c0023 	li	t4,35
		}
	
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
80009bb0:	240d0050 	li	t5,80
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
80009bb4:	08002716 	j	80009c58 <ExtractACmdLine+0x11c>
80009bb8:	240e0020 	li	t6,32
	{
		if(n==0)
80009bbc:	10a00007 	beqz	a1,80009bdc <ExtractACmdLine+0xa0>
80009bc0:	00000000 	nop
80009bc4:	08002702 	j	80009c08 <ExtractACmdLine+0xcc>
80009bc8:	00000000 	nop
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
80009bcc:	26100001 	addiu	s0,s0,1
	while( *p )
	{
		if(n==0)
		{
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
80009bd0:	92020000 	lbu	v0,0(s0)
80009bd4:	1040003f 	beqz	v0,80009cd4 <ExtractACmdLine+0x198>
80009bd8:	00000000 	nop
80009bdc:	1043fffb 	beq	v0,v1,80009bcc <ExtractACmdLine+0x90>
80009be0:	00000000 	nop
80009be4:	1044fff9 	beq	v0,a0,80009bcc <ExtractACmdLine+0x90>
80009be8:	00000000 	nop
80009bec:	1046fff7 	beq	v0,a2,80009bcc <ExtractACmdLine+0x90>
80009bf0:	00000000 	nop
80009bf4:	1047fff6 	beq	v0,a3,80009bd0 <ExtractACmdLine+0x94>
80009bf8:	26100001 	addiu	s0,s0,1
80009bfc:	2610ffff 	addiu	s0,s0,-1
				p++;
		}

		if ((n==0) && (*p =='~') )
80009c00:	08002735 	j	80009cd4 <ExtractACmdLine+0x198>
80009c04:	92020000 	lbu	v0,0(s0)


		//end
		if(n!=0)
		{
			if( (*p == 0x0d)  || (*p == 0x0a)  || (*p == '#'))
80009c08:	10430005 	beq	v0,v1,80009c20 <ExtractACmdLine+0xe4>
80009c0c:	00000000 	nop
80009c10:	10440003 	beq	v0,a0,80009c20 <ExtractACmdLine+0xe4>
80009c14:	00000000 	nop
80009c18:	144c0004 	bne	v0,t4,80009c2c <ExtractACmdLine+0xf0>
80009c1c:	00000000 	nop
			{	pOneCmdString[n] = 0 ;
80009c20:	02251021 	addu	v0,s1,a1
				break;
80009c24:	08002719 	j	80009c64 <ExtractACmdLine+0x128>
80009c28:	a0400000 	sb	zero,0(v0)
			}
			if(*p==0x09) //TAB->SPACE
80009c2c:	14460002 	bne	v0,a2,80009c38 <ExtractACmdLine+0xfc>
80009c30:	00000000 	nop
				*p=' ';
80009c34:	a20e0000 	sb	t6,0(s0)
		}
	
		pOneCmdString[n] = *p ;
80009c38:	92020000 	lbu	v0,0(s0)
80009c3c:	a1220000 	sb	v0,0(t1)
80009c40:	01402821 	move	a1,t2
		n++;		
		p++;	
		if (n == 80) break;
80009c44:	114d002a 	beq	t2,t5,80009cf0 <ExtractACmdLine+0x1b4>
80009c48:	26100001 	addiu	s0,s0,1
80009c4c:	25080001 	addiu	t0,t0,1
80009c50:	254a0001 	addiu	t2,t2,1
80009c54:	25290001 	addiu	t1,t1,1
	
	memset( pOneCmdString, 0, MAX_MONITOR_BUFFER );


	int n=0;
	while( *p )
80009c58:	92020000 	lbu	v0,0(s0)
80009c5c:	1440ffd7 	bnez	v0,80009bbc <ExtractACmdLine+0x80>
80009c60:	01002821 	move	a1,t0
		pOneCmdString[n] = *p ;
		n++;		
		p++;	
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
80009c64:	02121023 	subu	v0,s0,s2
80009c68:	24420001 	addiu	v0,v0,1
80009c6c:	3c038001 	lui	v1,0x8001
80009c70:	ac624130 	sw	v0,16688(v1)

	//thrim last space
	for(;n>1;n--)
80009c74:	28a30002 	slti	v1,a1,2
80009c78:	10600021 	beqz	v1,80009d00 <ExtractACmdLine+0x1c4>
80009c7c:	8fbf001c 	lw	ra,28(sp)
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
80009c80:	08002731 	j	80009cc4 <ExtractACmdLine+0x188>
80009c84:	8fb20018 	lw	s2,24(sp)
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
80009c88:	8064ffff 	lb	a0,-1(v1)
80009c8c:	10860007 	beq	a0,a2,80009cac <ExtractACmdLine+0x170>
80009c90:	00000000 	nop
80009c94:	10880006 	beq	a0,t0,80009cb0 <ExtractACmdLine+0x174>
80009c98:	24a5ffff 	addiu	a1,a1,-1
80009c9c:	24a50001 	addiu	a1,a1,1
		{	pOneCmdString[n]=0;
80009ca0:	02253821 	addu	a3,s1,a1
			break;
80009ca4:	0800272f 	j	80009cbc <ExtractACmdLine+0x180>
80009ca8:	a0e00000 	sb	zero,0(a3)
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;

	//thrim last space
	for(;n>1;n--)
80009cac:	24a5ffff 	addiu	a1,a1,-1
80009cb0:	28a40002 	slti	a0,a1,2
80009cb4:	1080fff4 	beqz	a0,80009c88 <ExtractACmdLine+0x14c>
80009cb8:	2463ffff 	addiu	v1,v1,-1
		}

	//dprintf("test=> %s \r\n", pOneCmdString);
	return idx;	

}
80009cbc:	8fbf001c 	lw	ra,28(sp)
80009cc0:	8fb20018 	lw	s2,24(sp)
80009cc4:	8fb10014 	lw	s1,20(sp)
80009cc8:	8fb00010 	lw	s0,16(sp)
80009ccc:	03e00008 	jr	ra
80009cd0:	27bd0020 	addiu	sp,sp,32
			//skip first return-line
			while( *p && ((*p == 0x0d) ||(*p==0x0a) ||(*p=='\t') ||(*p==' ') ) )
				p++;
		}

		if ((n==0) && (*p =='~') )
80009cd4:	144b0003 	bne	v0,t3,80009ce4 <ExtractACmdLine+0x1a8>
80009cd8:	00000000 	nop
80009cdc:	0800272f 	j	80009cbc <ExtractACmdLine+0x180>
80009ce0:	00001021 	move	v0,zero
			}
			if(*p==0x09) //TAB->SPACE
				*p=' ';
		}
	
		pOneCmdString[n] = *p ;
80009ce4:	a1220000 	sb	v0,0(t1)
		n++;		
		p++;	
80009ce8:	08002713 	j	80009c4c <ExtractACmdLine+0x110>
80009cec:	26100001 	addiu	s0,s0,1
		if (n == 80) break;
	}
	idx= (int)p-(int)pPattScript+1;
80009cf0:	02121023 	subu	v0,s0,s2
80009cf4:	24420001 	addiu	v0,v0,1
80009cf8:	3c038001 	lui	v1,0x8001
80009cfc:	ac624130 	sw	v0,16688(v1)
80009d00:	02251821 	addu	v1,s1,a1

	//thrim last space
	for(;n>1;n--)
		if( (pOneCmdString[n-1]!=' ')  &&  (pOneCmdString[n-1]!='\t') )
80009d04:	24060020 	li	a2,32
80009d08:	08002722 	j	80009c88 <ExtractACmdLine+0x14c>
80009d0c:	24080009 	li	t0,9

80009d10 <CmdMEMCLK>:
#endif		
	dprintf("Change M2x clock freq=%d \n", m2x_clksel_table[clk_sel] );
}
//---------------------------------------------------------------------------
int CmdMEMCLK(int argc, char* argv[])
{
80009d10:	27bdffd8 	addiu	sp,sp,-40
80009d14:	afbf0024 	sw	ra,36(sp)
80009d18:	afb30020 	sw	s3,32(sp)
80009d1c:	afb2001c 	sw	s2,28(sp)
80009d20:	afb10018 	sw	s1,24(sp)
80009d24:	afb00014 	sw	s0,20(sp)

	int clk_sel=0;
	int tmp;
	if( argc < 1 ) 
80009d28:	1c80001f 	bgtz	a0,80009da8 <CmdMEMCLK+0x98>
80009d2c:	00000000 	nop
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
80009d30:	3c048001 	lui	a0,0x8001
80009d34:	0c001cc1 	jal	80007304 <dprintf>
80009d38:	248415f4 	addiu	a0,a0,5620
80009d3c:	3c118001 	lui	s1,0x8001
80009d40:	2631eba0 	addiu	s1,s1,-5216
80009d44:	00008021 	move	s0,zero
		int i;
		for(i=0; i<8;i++)
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
80009d48:	3c128001 	lui	s2,0x8001
80009d4c:	26521610 	addiu	s2,s2,5648
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
80009d50:	24130008 	li	s3,8
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
80009d54:	02402021 	move	a0,s2
80009d58:	02002821 	move	a1,s0
80009d5c:	0c001cc1 	jal	80007304 <dprintf>
80009d60:	8e260000 	lw	a2,0(s1)
	int tmp;
	if( argc < 1 ) 
	{
		dprintf("Usage: MEMCLK <sel>: 0-7  \n");		
		int i;
		for(i=0; i<8;i++)
80009d64:	26100001 	addiu	s0,s0,1
80009d68:	1613fffa 	bne	s0,s3,80009d54 <CmdMEMCLK+0x44>
80009d6c:	26310004 	addiu	s1,s1,4
		dprintf(" %d : %d MHz \n", i, m2x_clksel_table[i]);
		
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>10;
80009d70:	3c02b800 	lui	v0,0xb800
80009d74:	34420008 	ori	v0,v0,0x8
80009d78:	8c450000 	lw	a1,0(v0)
80009d7c:	7ca52280 	ext	a1,a1,0xa,0x5
		dprintf("status: %d = %d Mhz \n",  m2xsel, m2x_clksel_table[m2xsel] );
80009d80:	00051880 	sll	v1,a1,0x2
80009d84:	3c028001 	lui	v0,0x8001
80009d88:	2442eba0 	addiu	v0,v0,-5216
80009d8c:	00621021 	addu	v0,v1,v0
80009d90:	3c048001 	lui	a0,0x8001
80009d94:	24841620 	addiu	a0,a0,5664
80009d98:	0c001cc1 	jal	80007304 <dprintf>
80009d9c:	8c460000 	lw	a2,0(v0)
		return;	
80009da0:	08002771 	j	80009dc4 <CmdMEMCLK+0xb4>
80009da4:	8fbf0024 	lw	ra,36(sp)
	}
	

	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
80009da8:	8ca40000 	lw	a0,0(a1)
80009dac:	00002821 	move	a1,zero
80009db0:	0c001a60 	jal	80006980 <strtoul>
80009db4:	24060010 	li	a2,16
		SettingM2xClk(clk_sel);
80009db8:	0c002137 	jal	800084dc <SettingM2xClk>
80009dbc:	00402021 	move	a0,v0


}
80009dc0:	8fbf0024 	lw	ra,36(sp)
80009dc4:	8fb30020 	lw	s3,32(sp)
80009dc8:	8fb2001c 	lw	s2,28(sp)
80009dcc:	8fb10018 	lw	s1,24(sp)
80009dd0:	8fb00014 	lw	s0,20(sp)
80009dd4:	03e00008 	jr	ra
80009dd8:	27bd0028 	addiu	sp,sp,40

80009ddc <TestStrapPin>:
}

//=================================================================================

int TestStrapPin(int argc, char* argv[])
{
80009ddc:	27bdffe0 	addiu	sp,sp,-32
80009de0:	afbf001c 	sw	ra,28(sp)
80009de4:	afb10018 	sw	s1,24(sp)
80009de8:	afb00014 	sw	s0,20(sp)

	if(argc < 2) 
80009dec:	28840002 	slti	a0,a0,2
80009df0:	10800008 	beqz	a0,80009e14 <TestStrapPin+0x38>
80009df4:	00a08021 	move	s0,a1
	{	ShowStrapMsg();
80009df8:	0c00220c 	jal	80008830 <ShowStrapMsg>
80009dfc:	00000000 	nop
		dprintf("Usage: strap bit value \n\n");	
80009e00:	3c048001 	lui	a0,0x8001
80009e04:	0c001cc1 	jal	80007304 <dprintf>
80009e08:	24841638 	addiu	a0,a0,5688
	{
		dprintf("Unsupport value \n");	
	}
	ShowStrapMsg();
	
}
80009e0c:	080027a9 	j	80009ea4 <TestStrapPin+0xc8>
80009e10:	24020001 	li	v0,1
	if(argc < 2) 
	{	ShowStrapMsg();
		dprintf("Usage: strap bit value \n\n");	
		return 1;
	}
	unsigned int bit = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
80009e14:	8ca40000 	lw	a0,0(a1)
80009e18:	00002821 	move	a1,zero
80009e1c:	0c001a60 	jal	80006980 <strtoul>
80009e20:	2406000a 	li	a2,10
80009e24:	00408821 	move	s1,v0
	unsigned int val = strtoul((const char*)(argv[1]), (char **)NULL, 16);		
80009e28:	8e040004 	lw	a0,4(s0)
80009e2c:	00002821 	move	a1,zero
80009e30:	0c001a60 	jal	80006980 <strtoul>
80009e34:	24060010 	li	a2,16


	if(val==0)
80009e38:	1440000b 	bnez	v0,80009e68 <TestStrapPin+0x8c>
80009e3c:	24030001 	li	v1,1
	{		
		REG32(SYS_HW_STRAP) &= ~(1<<bit);		
80009e40:	3c02b800 	lui	v0,0xb800
80009e44:	34420008 	ori	v0,v0,0x8
80009e48:	8c430000 	lw	v1,0(v0)
80009e4c:	24040001 	li	a0,1
80009e50:	02248804 	sllv	s1,a0,s1
80009e54:	00118827 	nor	s1,zero,s1
80009e58:	02238824 	and	s1,s1,v1
80009e5c:	ac510000 	sw	s1,0(v0)
80009e60:	080027a7 	j	80009e9c <TestStrapPin+0xc0>
80009e64:	00000000 	nop
	}
	else if(val==1)
80009e68:	1443000a 	bne	v0,v1,80009e94 <TestStrapPin+0xb8>
80009e6c:	3c048001 	lui	a0,0x8001
	{			
		REG32(SYS_HW_STRAP) |= (1<<bit);		
80009e70:	3c02b800 	lui	v0,0xb800
80009e74:	34420008 	ori	v0,v0,0x8
80009e78:	8c430000 	lw	v1,0(v0)
80009e7c:	24040001 	li	a0,1
80009e80:	02248804 	sllv	s1,a0,s1
80009e84:	02238825 	or	s1,s1,v1
80009e88:	ac510000 	sw	s1,0(v0)
80009e8c:	080027a7 	j	80009e9c <TestStrapPin+0xc0>
80009e90:	00000000 	nop
	}
	else
	{
		dprintf("Unsupport value \n");	
80009e94:	0c001cc1 	jal	80007304 <dprintf>
80009e98:	24841654 	addiu	a0,a0,5716
	}
	ShowStrapMsg();
80009e9c:	0c00220c 	jal	80008830 <ShowStrapMsg>
80009ea0:	00000000 	nop
	
}
80009ea4:	8fbf001c 	lw	ra,28(sp)
80009ea8:	8fb10018 	lw	s1,24(sp)
80009eac:	8fb00014 	lw	s0,20(sp)
80009eb0:	03e00008 	jr	ra
80009eb4:	27bd0020 	addiu	sp,sp,32

80009eb8 <SettingLxClk>:

}
//---------------------------------------------------------------------------

int SettingLxClk(int clklx_from_clkm)
{	
80009eb8:	27bdffc0 	addiu	sp,sp,-64
80009ebc:	afbf003c 	sw	ra,60(sp)
80009ec0:	afb20038 	sw	s2,56(sp)
80009ec4:	afb10034 	sw	s1,52(sp)
80009ec8:	afb00030 	sw	s0,48(sp)
80009ecc:	00808821 	move	s1,a0
	
	int	tmp=REG32(SYS_HW_STRAP) & ~(ST_CLKLX_FROM_HALFOC);
80009ed0:	3c02b800 	lui	v0,0xb800
80009ed4:	34420008 	ori	v0,v0,0x8
80009ed8:	8c450000 	lw	a1,0(v0)
	int strap_newval= tmp | ((clklx_from_clkm&0x01) <<ST_CLKLX_FROM_HALFOC_OFFSET) ;

	//--------------------------------------
	//int lexra_newval;

	if(clklx_from_clkm==0)
80009edc:	14800006 	bnez	a0,80009ef8 <SettingLxClk+0x40>
80009ee0:	3c0207d2 	lui	v0,0x7d2
	{	
		glexra_clock=200*1000*1000;
80009ee4:	3c030beb 	lui	v1,0xbeb
80009ee8:	3463c200 	ori	v1,v1,0xc200
80009eec:	3c028001 	lui	v0,0x8001
80009ef0:	080027df 	j	80009f7c <SettingLxClk+0xc4>
80009ef4:	ac432f00 	sw	v1,12032(v0)
	}
	else
	{
		//prepare uart 
		unsigned long mem2x_clksel_table[]={ 131250000, 156250000, 300000000, 250000000,  312500000, 337500000, 475000000, 387500000 	};
80009ef8:	3442b750 	ori	v0,v0,0xb750
80009efc:	afa20010 	sw	v0,16(sp)
80009f00:	3c020950 	lui	v0,0x950
80009f04:	34422f90 	ori	v0,v0,0x2f90
80009f08:	afa20014 	sw	v0,20(sp)
80009f0c:	3c0211e1 	lui	v0,0x11e1
80009f10:	3442a300 	ori	v0,v0,0xa300
80009f14:	afa20018 	sw	v0,24(sp)
80009f18:	3c020ee6 	lui	v0,0xee6
80009f1c:	3442b280 	ori	v0,v0,0xb280
80009f20:	afa2001c 	sw	v0,28(sp)
80009f24:	3c0212a0 	lui	v0,0x12a0
80009f28:	34425f20 	ori	v0,v0,0x5f20
80009f2c:	afa20020 	sw	v0,32(sp)
80009f30:	3c02141d 	lui	v0,0x141d
80009f34:	3442d760 	ori	v0,v0,0xd760
80009f38:	afa20024 	sw	v0,36(sp)
80009f3c:	3c021c4f 	lui	v0,0x1c4f
80009f40:	3442ecc0 	ori	v0,v0,0xecc0
80009f44:	afa20028 	sw	v0,40(sp)
80009f48:	3c021718 	lui	v0,0x1718
80009f4c:	3442c7e0 	ori	v0,v0,0xc7e0
80009f50:	afa2002c 	sw	v0,44(sp)
		int	m2xsel=(REG32(SYS_HW_STRAP) & (CK_M2X_FREQ_SEL))>>CK_M2X_FREQ_SEL_OFFSET;
80009f54:	3c02b800 	lui	v0,0xb800
80009f58:	34420008 	ori	v0,v0,0x8
80009f5c:	8c420000 	lw	v0,0(v0)
	       glexra_clock=mem2x_clksel_table[m2xsel] /2;
80009f60:	7c422280 	ext	v0,v0,0xa,0x5
80009f64:	00021080 	sll	v0,v0,0x2
80009f68:	03a21021 	addu	v0,sp,v0
80009f6c:	8c430010 	lw	v1,16(v0)
80009f70:	00031842 	srl	v1,v1,0x1
80009f74:	3c028001 	lui	v0,0x8001
80009f78:	ac432f00 	sw	v1,12032(v0)

	}
	//--------------------------------------
	int gimr_tmp=REG32(GIMR_REG);
80009f7c:	3c02b800 	lui	v0,0xb800
80009f80:	34433000 	ori	v1,v0,0x3000
80009f84:	8c720000 	lw	s2,0(v1)
	REG32(GIMR_REG)=0;
80009f88:	ac600000 	sw	zero,0(v1)
	

		#if 1  //lock bus			
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
80009f8c:	34420014 	ori	v0,v0,0x14
80009f90:	8c430000 	lw	v1,0(v0)
80009f94:	34630004 	ori	v1,v1,0x4
80009f98:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  ; //wait bit to 1, is mean lock ok	
80009f9c:	3c03b800 	lui	v1,0xb800
80009fa0:	34630020 	ori	v1,v1,0x20
80009fa4:	8c620000 	lw	v0,0(v1)
80009fa8:	30420001 	andi	v0,v0,0x1
80009fac:	1040fffd 	beqz	v0,80009fa4 <SettingLxClk+0xec>
80009fb0:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
80009fb4:	34420014 	ori	v0,v0,0x14
80009fb8:	8c430000 	lw	v1,0(v0)
80009fbc:	34630008 	ori	v1,v1,0x8
80009fc0:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==0)  ; //wait bit to 1, is mean lock ok		
80009fc4:	3c03b800 	lui	v1,0xb800
80009fc8:	34630020 	ori	v1,v1,0x20
80009fcc:	8c620000 	lw	v0,0(v1)
80009fd0:	30420002 	andi	v0,v0,0x2
80009fd4:	1040fffd 	beqz	v0,80009fcc <SettingLxClk+0x114>
80009fd8:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
80009fdc:	34420014 	ori	v0,v0,0x14
80009fe0:	8c430000 	lw	v1,0(v0)
80009fe4:	34630010 	ori	v1,v1,0x10
80009fe8:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==0)  ; //wait bit to 1, is mean lock ok	
80009fec:	3c03b800 	lui	v1,0xb800
80009ff0:	34630020 	ori	v1,v1,0x20
80009ff4:	8c620000 	lw	v0,0(v1)
80009ff8:	30420004 	andi	v0,v0,0x4
80009ffc:	1040fffd 	beqz	v0,80009ff4 <SettingLxClk+0x13c>
8000a000:	32220001 	andi	v0,s1,0x1
		#endif
	


	//go
	REG32(SYS_HW_STRAP)=strap_newval;    //change lx clk
8000a004:	00021540 	sll	v0,v0,0x15
8000a008:	3c04ffdf 	lui	a0,0xffdf
8000a00c:	3484ffff 	ori	a0,a0,0xffff
8000a010:	00a42024 	and	a0,a1,a0
8000a014:	00442025 	or	a0,v0,a0
8000a018:	3c02b800 	lui	v0,0xb800
8000a01c:	34430008 	ori	v1,v0,0x8
8000a020:	ac640000 	sw	a0,0(v1)


		#if 1   //check m2xusable and unlock bus
			//while( (REG32(SYS_BIST_DONE)&(1<<18))==0)  ;   //wait to 1, mean m2x is usable
	
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000a024:	34420014 	ori	v0,v0,0x14
8000a028:	8c440000 	lw	a0,0(v0)
8000a02c:	2403fffb 	li	v1,-5
8000a030:	00831824 	and	v1,a0,v1
8000a034:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) ;  //wait bit to 0  unlock
8000a038:	3c03b800 	lui	v1,0xb800
8000a03c:	34630020 	ori	v1,v1,0x20
8000a040:	8c620000 	lw	v0,0(v1)
8000a044:	30420001 	andi	v0,v0,0x1
8000a048:	1440fffd 	bnez	v0,8000a040 <SettingLxClk+0x188>
8000a04c:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
8000a050:	34420014 	ori	v0,v0,0x14
8000a054:	8c440000 	lw	a0,0(v0)
8000a058:	2403fff7 	li	v1,-9
8000a05c:	00831824 	and	v1,a0,v1
8000a060:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<1))==(1<<1)) ;  //wait bit to 0  unlock
8000a064:	3c03b800 	lui	v1,0xb800
8000a068:	34630020 	ori	v1,v1,0x20
8000a06c:	8c620000 	lw	v0,0(v1)
8000a070:	30420002 	andi	v0,v0,0x2
8000a074:	1440fffd 	bnez	v0,8000a06c <SettingLxClk+0x1b4>
8000a078:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
8000a07c:	34420014 	ori	v0,v0,0x14
8000a080:	8c440000 	lw	a0,0(v0)
8000a084:	2403ffef 	li	v1,-17
8000a088:	00831824 	and	v1,a0,v1
8000a08c:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) ;  //wait bit to 0  unlock	
8000a090:	3c03b800 	lui	v1,0xb800
8000a094:	34630020 	ori	v1,v1,0x20
8000a098:	8c620000 	lw	v0,0(v1)
8000a09c:	30420004 	andi	v0,v0,0x4
8000a0a0:	1440fffd 	bnez	v0,8000a098 <SettingLxClk+0x1e0>
8000a0a4:	3c108001 	lui	s0,0x8001
		#endif

		
	console_init(glexra_clock);
8000a0a8:	0c00301d 	jal	8000c074 <console_init>
8000a0ac:	8e042f00 	lw	a0,12032(s0)
	timer_init(glexra_clock);
8000a0b0:	0c003260 	jal	8000c980 <timer_init>
8000a0b4:	8e042f00 	lw	a0,12032(s0)

		
	REG32(GIMR_REG)=gimr_tmp;
8000a0b8:	3c02b800 	lui	v0,0xb800
8000a0bc:	34423000 	ori	v0,v0,0x3000
8000a0c0:	ac520000 	sw	s2,0(v0)



	

	dprintf("clklx_from_clkm=%d \n", clklx_from_clkm );
8000a0c4:	3c048001 	lui	a0,0x8001
8000a0c8:	24841668 	addiu	a0,a0,5736
8000a0cc:	0c001cc1 	jal	80007304 <dprintf>
8000a0d0:	02202821 	move	a1,s1
	
}
8000a0d4:	8fbf003c 	lw	ra,60(sp)
8000a0d8:	8fb20038 	lw	s2,56(sp)
8000a0dc:	8fb10034 	lw	s1,52(sp)
8000a0e0:	8fb00030 	lw	s0,48(sp)
8000a0e4:	03e00008 	jr	ra
8000a0e8:	27bd0040 	addiu	sp,sp,64

8000a0ec <CmdLXCLK>:

int CmdLXCLK(int argc, char* argv[])
{
8000a0ec:	27bdffe8 	addiu	sp,sp,-24
8000a0f0:	afbf0014 	sw	ra,20(sp)
	if( argc < 1 ) 
8000a0f4:	1c80000d 	bgtz	a0,8000a12c <CmdLXCLK+0x40>
8000a0f8:	00000000 	nop
	{
		dprintf("Usage: LXCLK <sel>: 0-1  \r\n");		
8000a0fc:	3c048001 	lui	a0,0x8001
8000a100:	0c001cc1 	jal	80007304 <dprintf>
8000a104:	24841680 	addiu	a0,a0,5760
		int	lxsel=(REG32(SYS_HW_STRAP) & (ST_CLKLX_FROM_HALFOC))>>ST_CLKLX_FROM_HALFOC_OFFSET;
8000a108:	3c02b800 	lui	v0,0xb800
8000a10c:	34420008 	ori	v0,v0,0x8
8000a110:	8c450000 	lw	a1,0(v0)
		dprintf("status: %d \n", lxsel );		
8000a114:	3c048001 	lui	a0,0x8001
8000a118:	2484169c 	addiu	a0,a0,5788
8000a11c:	0c001cc1 	jal	80007304 <dprintf>
8000a120:	7ca50540 	ext	a1,a1,0x15,0x1
		return;	
8000a124:	08002852 	j	8000a148 <CmdLXCLK+0x5c>
8000a128:	8fbf0014 	lw	ra,20(sp)
	}

	
	int clklx_from_clkm = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000a12c:	8ca40000 	lw	a0,0(a1)
8000a130:	00002821 	move	a1,zero
8000a134:	0c001a60 	jal	80006980 <strtoul>
8000a138:	24060010 	li	a2,16
	SettingLxClk(clklx_from_clkm);
8000a13c:	0c0027ae 	jal	80009eb8 <SettingLxClk>
8000a140:	00402021 	move	a0,v0


	//--------------------------------------


};  
8000a144:	8fbf0014 	lw	ra,20(sp)
8000a148:	03e00008 	jr	ra
8000a14c:	27bd0018 	addiu	sp,sp,24

8000a150 <SettingCPUClk>:
#endif
}
//---------------------------------------------------------------------------

int SettingCPUClk(int clk_sel, int clk_div)
{
8000a150:	27bdffe0 	addiu	sp,sp,-32
8000a154:	afbf001c 	sw	ra,28(sp)
8000a158:	afb20018 	sw	s2,24(sp)
8000a15c:	afb10014 	sw	s1,20(sp)
8000a160:	afb00010 	sw	s0,16(sp)
8000a164:	00808021 	move	s0,a0
8000a168:	00a08821 	move	s1,a1
	int clk_curr, clk_exp;	
	unsigned int old_clk_sel;
	unsigned int mask;
	unsigned int sysreg;

	REG32(SYS_INT_STATUS)=(1<<1);  //clear cpu wakeup.
8000a16c:	3c02b800 	lui	v0,0xb800
8000a170:	34430004 	ori	v1,v0,0x4
8000a174:	24040002 	li	a0,2
8000a178:	ac640000 	sw	a0,0(v1)

#if 1  //check core 1 exist
		#define POLLING_REG 0xb800006c
  		#define PATT_SLEEP  0x3333		
  		#define PATT_READY  0x5555
	if(REG32(POLLING_REG)!=PATT_SLEEP)
8000a17c:	3442006c 	ori	v0,v0,0x6c
8000a180:	8c440000 	lw	a0,0(v0)
8000a184:	24033333 	li	v1,13107
8000a188:	14830074 	bne	a0,v1,8000a35c <SettingCPUClk+0x20c>
8000a18c:	00001021 	move	v0,zero
	}


#endif
	
	clk_curr = check_cpu_speed();
8000a190:	0c0036fd 	jal	8000dbf4 <check_cpu_speed>
8000a194:	3c12b800 	lui	s2,0xb800
#ifdef _verbose
	dprintf("Now CPU Speed=%d \n",clk_curr);	
#endif
	//----------------------------
	REG32(SYS_INT_STATUS)=(1<<1);  //enable cpu wakeup interrupt mask
8000a198:	36420004 	ori	v0,s2,0x4
8000a19c:	24030002 	li	v1,2
8000a1a0:	ac430000 	sw	v1,0(v0)

	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 	
8000a1a4:	2404002b 	li	a0,43
8000a1a8:	3c058001 	lui	a1,0x8001
8000a1ac:	24a52e20 	addiu	a1,a1,11808
8000a1b0:	0c000274 	jal	800009d0 <request_IRQ>
8000a1b4:	00003021 	move	a2,zero

	//-------------
	sysreg=REG32(SYS_HW_STRAP);
8000a1b8:	36520008 	ori	s2,s2,0x8
8000a1bc:	8e430000 	lw	v1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x\r\n", sysreg);	
	old_clk_sel=(sysreg & ST_CPU_FREQ_SEL) >>ST_CPU_FREQ_SEL_OFFSET;

	sysreg&= ~(ST_FW_CPU_FREQDIV_SEL);
	sysreg&= ~(ST_CK_CPU_FREQDIV_SEL);	
	sysreg&= ~(ST_CPU_FREQ_SEL);
8000a1c0:	3c02ffe0 	lui	v0,0xffe0
8000a1c4:	34427fff 	ori	v0,v0,0x7fff
8000a1c8:	00621024 	and	v0,v1,v0

	sysreg|=  (clk_div & 0x03) <<ST_CPU_FREQDIV_SEL_OFFSET ;
8000a1cc:	3205000f 	andi	a1,s0,0xf
8000a1d0:	00052bc0 	sll	a1,a1,0xf
8000a1d4:	00a22825 	or	a1,a1,v0
	sysreg|=	 (clk_sel&0x0f)<<ST_CPU_FREQ_SEL_OFFSET ;
8000a1d8:	32220003 	andi	v0,s1,0x3
8000a1dc:	000214c0 	sll	v0,v0,0x13
8000a1e0:	00a22825 	or	a1,a1,v0
	//-------------------------

	clk_exp=cpu_clksel_table[clk_sel] / cpu_clkdiv_table[clk_div];
8000a1e4:	00102080 	sll	a0,s0,0x2
8000a1e8:	3c028001 	lui	v0,0x8001
8000a1ec:	2442eb60 	addiu	v0,v0,-5280
8000a1f0:	00821021 	addu	v0,a0,v0
8000a1f4:	8c440000 	lw	a0,0(v0)
8000a1f8:	00118880 	sll	s1,s1,0x2
8000a1fc:	3c028001 	lui	v0,0x8001
8000a200:	24422e10 	addiu	v0,v0,11792
8000a204:	02228821 	addu	s1,s1,v0
8000a208:	8e220000 	lw	v0,0(s1)
	
#ifdef _verbose
	dprintf("Write SYS_HW_STRAP=%08x \n", sysreg);
#endif	

	REG32(SYS_HW_STRAP)=sysreg  ;
8000a20c:	ae450000 	sw	a1,0(s2)
	//dprintf("Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));
	
	//--------------
	if(old_clk_sel != clk_sel)
8000a210:	3c050007 	lui	a1,0x7
8000a214:	34a58000 	ori	a1,a1,0x8000
8000a218:	00651824 	and	v1,v1,a1
8000a21c:	00031bc2 	srl	v1,v1,0xf
8000a220:	1203004a 	beq	s0,v1,8000a34c <SettingCPUClk+0x1fc>
8000a224:	00002821 	move	a1,zero
	{
#if 1
	HS0_Control(clk_exp, 0, 0, 0);
8000a228:	0082001b 	divu	zero,a0,v0
8000a22c:	004001f4 	teq	v0,zero,0x7
8000a230:	00002012 	mflo	a0
8000a234:	00003021 	move	a2,zero
8000a238:	0c0021b3 	jal	800086cc <HS0_Control>
8000a23c:	00003821 	move	a3,zero
#endif	
		REG32(GISR_REG)=0xffffffff;	
8000a240:	3c02b800 	lui	v0,0xb800
8000a244:	34433004 	ori	v1,v0,0x3004
8000a248:	2404ffff 	li	a0,-1
8000a24c:	ac640000 	sw	a0,0(v1)
		//dprintf("before sleep, Read  SYS_HW_STRAP=%08x \n", REG32(SYS_HW_STRAP));	
		//dprintf("GISR=%08x \n",REG32(GISR_REG));
		//dprintf("GIMR=%08x \n",REG32(GIMR_REG));	

		#if 1	
			REG32(SYS_CLKMANAGE) |= (1<<12)|(1<<13)|(1<<19)|(1<<20);  //active lx1 lx2
8000a250:	34430010 	ori	v1,v0,0x10
8000a254:	8c650000 	lw	a1,0(v1)
8000a258:	3c040018 	lui	a0,0x18
8000a25c:	34843000 	ori	a0,a0,0x3000
8000a260:	00a42025 	or	a0,a1,a0
8000a264:	ac640000 	sw	a0,0(v1)
		
			REG32(SYS_LX_CTRL) |= (1<<2) ;	  //lock bus arb2
8000a268:	34420014 	ori	v0,v0,0x14
8000a26c:	8c430000 	lw	v1,0(v0)
8000a270:	34630004 	ori	v1,v1,0x4
8000a274:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==0)  ; //wait bit to 1, is mean lock ok	
8000a278:	00401821 	move	v1,v0
8000a27c:	8c620000 	lw	v0,0(v1)
8000a280:	30421000 	andi	v0,v0,0x1000
8000a284:	1040fffd 	beqz	v0,8000a27c <SettingCPUClk+0x12c>
8000a288:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<3) ;	  //lock bus arb4
8000a28c:	34420014 	ori	v0,v0,0x14
8000a290:	8c430000 	lw	v1,0(v0)
8000a294:	34630008 	ori	v1,v1,0x8
8000a298:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==0)  ; //wait bit to 1, is mean lock ok		
8000a29c:	00401821 	move	v1,v0
8000a2a0:	8c620000 	lw	v0,0(v1)
8000a2a4:	30422000 	andi	v0,v0,0x2000
8000a2a8:	1040fffd 	beqz	v0,8000a2a0 <SettingCPUClk+0x150>
8000a2ac:	3c02b800 	lui	v0,0xb800

			REG32(SYS_LX_CTRL) |= (1<<4) ;	  //lock bus arb6
8000a2b0:	34420014 	ori	v0,v0,0x14
8000a2b4:	8c430000 	lw	v1,0(v0)
8000a2b8:	34630010 	ori	v1,v1,0x10
8000a2bc:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==0)  ; //wait bit to 1, is mean lock ok				
8000a2c0:	00401821 	move	v1,v0
8000a2c4:	8c620000 	lw	v0,0(v1)
8000a2c8:	30424000 	andi	v0,v0,0x4000
8000a2cc:	1040fffd 	beqz	v0,8000a2c4 <SettingCPUClk+0x174>
8000a2d0:	00000000 	nop
	...
		
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("wait");	
8000a2e4:	42000020 	wait
	...
		__asm__ volatile("nop");
		__asm__ volatile("nop");
		__asm__ volatile("nop");

		#if 1
			REG32(SYS_LX_CTRL) &= ~(1<<2);	//unlock
8000a300:	3c03b800 	lui	v1,0xb800
8000a304:	34620014 	ori	v0,v1,0x14
8000a308:	8c450000 	lw	a1,0(v0)
8000a30c:	2404fffb 	li	a0,-5
8000a310:	00a42024 	and	a0,a1,a0
8000a314:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<12))==(1<<0)) ;  //wait bit to 0  unlock
8000a318:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<3);	//unlock
8000a31c:	8c450000 	lw	a1,0(v0)
8000a320:	2404fff7 	li	a0,-9
8000a324:	00a42024 	and	a0,a1,a0
8000a328:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<13))==(1<<1)) ;  //wait bit to 0  unlock
8000a32c:	8c440000 	lw	a0,0(v0)

			REG32(SYS_LX_CTRL) &= ~(1<<4);	//unlock
8000a330:	8c450000 	lw	a1,0(v0)
8000a334:	2404ffef 	li	a0,-17
8000a338:	00a42024 	and	a0,a1,a0
8000a33c:	ac440000 	sw	a0,0(v0)
			while( (REG32(SYS_LX_CTRL)&(1<<14))==(1<<2)) ;  //wait bit to 0  unlock				
8000a340:	8c420000 	lw	v0,0(v0)
		#endif

		int strap_new=REG32(SYS_HW_STRAP) ;
8000a344:	34630008 	ori	v1,v1,0x8
8000a348:	8c620000 	lw	v0,0(v1)

	}
	
	//-----------------------
	//test cpu can work
	LetCPUDoSomething();
8000a34c:	0c002192 	jal	80008648 <LetCPUDoSomething>
8000a350:	00000000 	nop

	//-----------------------
	clk_curr = check_cpu_speed();
8000a354:	0c0036fd 	jal	8000dbf4 <check_cpu_speed>
8000a358:	00000000 	nop
	{	dprintf("Test FAIL! Curr_speed=%d but Exp_speed=%d \n", clk_curr, clk_exp);
		//while(1) ;
	}
#endif

}
8000a35c:	8fbf001c 	lw	ra,28(sp)
8000a360:	8fb20018 	lw	s2,24(sp)
8000a364:	8fb10014 	lw	s1,20(sp)
8000a368:	8fb00010 	lw	s0,16(sp)
8000a36c:	03e00008 	jr	ra
8000a370:	27bd0020 	addiu	sp,sp,32

8000a374 <CmdCPUCLK>:
//---------------------------------------------------------------------------
int CmdCPUCLK(int argc, char* argv[])
{
8000a374:	27bdffd0 	addiu	sp,sp,-48
8000a378:	afbf002c 	sw	ra,44(sp)
8000a37c:	afb50028 	sw	s5,40(sp)
8000a380:	afb40024 	sw	s4,36(sp)
8000a384:	afb30020 	sw	s3,32(sp)
8000a388:	afb2001c 	sw	s2,28(sp)
8000a38c:	afb10018 	sw	s1,24(sp)
8000a390:	afb00014 	sw	s0,20(sp)
	int clk_curr;	


	
	int i;
	if( argc <1 )	//read
8000a394:	1c80002b 	bgtz	a0,8000a444 <CmdCPUCLK+0xd0>
8000a398:	00a08021 	move	s0,a1
	{
		clk_curr = check_cpu_speed();
8000a39c:	0c0036fd 	jal	8000dbf4 <check_cpu_speed>
8000a3a0:	3c118001 	lui	s1,0x8001
		dprintf("Now CPU Speed=%d \n",clk_curr);			
8000a3a4:	3c048001 	lui	a0,0x8001
8000a3a8:	248416ac 	addiu	a0,a0,5804
8000a3ac:	0c001cc1 	jal	80007304 <dprintf>
8000a3b0:	00402821 	move	a1,v0
		ShowStrapMsg();	
8000a3b4:	0c00220c 	jal	80008830 <ShowStrapMsg>
8000a3b8:	2631eb64 	addiu	s1,s1,-5276
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
8000a3bc:	3c048001 	lui	a0,0x8001
8000a3c0:	0c001cc1 	jal	80007304 <dprintf>
8000a3c4:	248416c0 	addiu	a0,a0,5824
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		
8000a3c8:	3c048001 	lui	a0,0x8001
8000a3cc:	0c001cc1 	jal	80007304 <dprintf>
8000a3d0:	248416f0 	addiu	a0,a0,5872


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000a3d4:	3c048001 	lui	a0,0x8001
8000a3d8:	24841718 	addiu	a0,a0,5912
8000a3dc:	00002821 	move	a1,zero
8000a3e0:	0c001cc1 	jal	80007304 <dprintf>
8000a3e4:	240601c2 	li	a2,450
8000a3e8:	00008021 	move	s0,zero
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
8000a3ec:	24120010 	li	s2,16
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000a3f0:	3c138001 	lui	s3,0x8001
8000a3f4:	26731718 	addiu	s3,s3,5912
		  if( (i&0x3) ==0x3) dprintf("\n");
8000a3f8:	24140003 	li	s4,3
8000a3fc:	3c158001 	lui	s5,0x8001
8000a400:	0800290c 	j	8000a430 <CmdCPUCLK+0xbc>
8000a404:	26b50f54 	addiu	s5,s5,3924
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
		{ dprintf(" %x : %d MHz,  ", i, cpu_clksel_table[i]);
8000a408:	02602021 	move	a0,s3
8000a40c:	02002821 	move	a1,s0
8000a410:	0c001cc1 	jal	80007304 <dprintf>
8000a414:	8e260000 	lw	a2,0(s1)
		  if( (i&0x3) ==0x3) dprintf("\n");
8000a418:	32020003 	andi	v0,s0,0x3
8000a41c:	14540003 	bne	v0,s4,8000a42c <CmdCPUCLK+0xb8>
8000a420:	00000000 	nop
8000a424:	0c001cc1 	jal	80007304 <dprintf>
8000a428:	02a02021 	move	a0,s5
8000a42c:	26310004 	addiu	s1,s1,4
		dprintf("Usage: CPUCLK clk_sel div_value : 0-f, 0-3  \n");	
		dprintf("Usage: CPUCLK 999 999: test all freq  \n");		


		int i;
		for(i=0; i<16;i++)
8000a430:	26100001 	addiu	s0,s0,1
8000a434:	1612fff4 	bne	s0,s2,8000a408 <CmdCPUCLK+0x94>
8000a438:	8fbf002c 	lw	ra,44(sp)
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000a43c:	0800294a 	j	8000a528 <CmdCPUCLK+0x1b4>
8000a440:	8fb50028 	lw	s5,40(sp)
		return;	
	}


	
	if(argv[0])	clk_sel = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000a444:	8ca40000 	lw	a0,0(a1)
8000a448:	10800005 	beqz	a0,8000a460 <CmdCPUCLK+0xec>
8000a44c:	00009021 	move	s2,zero
8000a450:	00002821 	move	a1,zero
8000a454:	0c001a60 	jal	80006980 <strtoul>
8000a458:	24060010 	li	a2,16
8000a45c:	00409021 	move	s2,v0
	if(argv[1])	clk_div = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000a460:	8e040004 	lw	a0,4(s0)
8000a464:	10800005 	beqz	a0,8000a47c <CmdCPUCLK+0x108>
8000a468:	00008821 	move	s1,zero
8000a46c:	00002821 	move	a1,zero
8000a470:	0c001a60 	jal	80006980 <strtoul>
8000a474:	24060010 	li	a2,16
8000a478:	00408821 	move	s1,v0
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
8000a47c:	24020999 	li	v0,2457
8000a480:	16420025 	bne	s2,v0,8000a518 <CmdCPUCLK+0x1a4>
8000a484:	02402021 	move	a0,s2
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a488:	00008021 	move	s0,zero
//	if(argv[2])	sync_oc = strtoul((const char*)(argv[2]), (char **)NULL, 16);


	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
8000a48c:	1622001a 	bne	s1,v0,8000a4f8 <CmdCPUCLK+0x184>
8000a490:	24120010 	li	s2,16
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a494:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 3);
8000a498:	02002021 	move	a0,s0
8000a49c:	0c002854 	jal	8000a150 <SettingCPUClk>
8000a4a0:	24050003 	li	a1,3

	if(clk_sel==0x999)
	{
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a4a4:	26100001 	addiu	s0,s0,1
8000a4a8:	1611fffc 	bne	s0,s1,8000a49c <CmdCPUCLK+0x128>
8000a4ac:	02002021 	move	a0,s0
8000a4b0:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a4b4:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 2);
8000a4b8:	02002021 	move	a0,s0
8000a4bc:	0c002854 	jal	8000a150 <SettingCPUClk>
8000a4c0:	24050002 	li	a1,2
		if(clk_div==0x999)
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a4c4:	26100001 	addiu	s0,s0,1
8000a4c8:	1611fffc 	bne	s0,s1,8000a4bc <CmdCPUCLK+0x148>
8000a4cc:	02002021 	move	a0,s0
8000a4d0:	00008021 	move	s0,zero
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a4d4:	24110010 	li	s1,16
				SettingCPUClk(clk_sel, 0);
8000a4d8:	02002021 	move	a0,s0
8000a4dc:	0c002854 	jal	8000a150 <SettingCPUClk>
8000a4e0:	00002821 	move	a1,zero
				SettingCPUClk(clk_sel, 3);

			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 2);
			
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a4e4:	26100001 	addiu	s0,s0,1
8000a4e8:	1611fffc 	bne	s0,s1,8000a4dc <CmdCPUCLK+0x168>
8000a4ec:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000a4f0:	08002949 	j	8000a524 <CmdCPUCLK+0x1b0>
8000a4f4:	8fbf002c 	lw	ra,44(sp)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, clk_div);
8000a4f8:	02002021 	move	a0,s0
8000a4fc:	0c002854 	jal	8000a150 <SettingCPUClk>
8000a500:	02202821 	move	a1,s1
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
				SettingCPUClk(clk_sel, 0);
		}
		else
		{
			for(clk_sel=0; clk_sel<=0x0f; clk_sel++)
8000a504:	26100001 	addiu	s0,s0,1
8000a508:	1612fffc 	bne	s0,s2,8000a4fc <CmdCPUCLK+0x188>
8000a50c:	02002021 	move	a0,s0
			
	}
	else
		SettingCPUClk(clk_sel, clk_div);

}
8000a510:	08002949 	j	8000a524 <CmdCPUCLK+0x1b0>
8000a514:	8fbf002c 	lw	ra,44(sp)
		}

			
	}
	else
		SettingCPUClk(clk_sel, clk_div);
8000a518:	0c002854 	jal	8000a150 <SettingCPUClk>
8000a51c:	02202821 	move	a1,s1

}
8000a520:	8fbf002c 	lw	ra,44(sp)
8000a524:	8fb50028 	lw	s5,40(sp)
8000a528:	8fb40024 	lw	s4,36(sp)
8000a52c:	8fb30020 	lw	s3,32(sp)
8000a530:	8fb2001c 	lw	s2,28(sp)
8000a534:	8fb10018 	lw	s1,24(sp)
8000a538:	8fb00014 	lw	s0,20(sp)
8000a53c:	03e00008 	jr	ra
8000a540:	27bd0030 	addiu	sp,sp,48

8000a544 <CPUWAKEUP>:

}

//------------------------------------------------------------------------------
void CPUWAKEUP(void)
{
8000a544:	27bdffe8 	addiu	sp,sp,-24
8000a548:	afbf0014 	sw	ra,20(sp)
	request_IRQ(SPEED_IRQ_NO, &irq_SPEED, NULL); 
8000a54c:	2404002b 	li	a0,43
8000a550:	3c058001 	lui	a1,0x8001
8000a554:	24a52e20 	addiu	a1,a1,11808
8000a558:	0c000274 	jal	800009d0 <request_IRQ>
8000a55c:	00003021 	move	a2,zero
}
8000a560:	8fbf0014 	lw	ra,20(sp)
8000a564:	03e00008 	jr	ra
8000a568:	27bd0018 	addiu	sp,sp,24
8000a56c:	00000000 	nop

8000a570 <Enable_SRAM>:

//------------------------------------------------------------------------
void Enable_SRAM(unsigned int paddr)
{
	//unmap
	REG32(0xb8001304)=0x5;   //unmap seg len=4K
8000a570:	3c02b800 	lui	v0,0xb800
8000a574:	34451304 	ori	a1,v0,0x1304
8000a578:	24030005 	li	v1,5
8000a57c:	aca30000 	sw	v1,0(a1)
	REG32(0xb8001300)=(unsigned int)paddr |1;   //unmap seg addr
8000a580:	34840001 	ori	a0,a0,0x1
8000a584:	34451300 	ori	a1,v0,0x1300
8000a588:	aca40000 	sw	a0,0(a1)

	//enable sram
	REG32(0xb8004004)=0x05;   //sram seg len=4K		
8000a58c:	34454004 	ori	a1,v0,0x4004
8000a590:	aca30000 	sw	v1,0(a1)
	REG32(0xb8004000)=(unsigned int)paddr |1;   //sram seg addr
8000a594:	34424000 	ori	v0,v0,0x4000
8000a598:	ac440000 	sw	a0,0(v0)
}
8000a59c:	03e00008 	jr	ra
8000a5a0:	00000000 	nop

8000a5a4 <Disable_SRAM>:

void Disable_SRAM()
{
	//unmap
	REG32(0xb8001300)=0;   //unmap seg addr
8000a5a4:	3c02b800 	lui	v0,0xb800
8000a5a8:	34431300 	ori	v1,v0,0x1300
8000a5ac:	ac600000 	sw	zero,0(v1)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
8000a5b0:	34424000 	ori	v0,v0,0x4000
8000a5b4:	ac400000 	sw	zero,0(v0)
}
8000a5b8:	03e00008 	jr	ra
8000a5bc:	00000000 	nop

8000a5c0 <PCIE_MDIO_Reset>:
        #define SYS_PCIE_PHY0   (0xb8000000 +0x50)
        #define SYS_PCIE_PHY1   (0xb8000000 +0x54)	
	 
	unsigned int sys_pcie_phy;

	if(portnum==0)	sys_pcie_phy=SYS_PCIE_PHY0;
8000a5c0:	14800003 	bnez	a0,8000a5d0 <PCIE_MDIO_Reset+0x10>
8000a5c4:	3c02b800 	lui	v0,0xb800
8000a5c8:	08002978 	j	8000a5e0 <PCIE_MDIO_Reset+0x20>
8000a5cc:	34420050 	ori	v0,v0,0x50
	else if(portnum==1)	sys_pcie_phy=SYS_PCIE_PHY1;
8000a5d0:	24020001 	li	v0,1
8000a5d4:	14820008 	bne	a0,v0,8000a5f8 <PCIE_MDIO_Reset+0x38>
8000a5d8:	3c02b800 	lui	v0,0xb800
8000a5dc:	34420054 	ori	v0,v0,0x54
	else return;
		
       // 3.MDIO Reset
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (0<<0);     //mdio reset=0,     	    //0x088
8000a5e0:	24030008 	li	v1,8
8000a5e4:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(0<<1) | (1<<0);     //mdio reset=1,           //0x09
8000a5e8:	24030009 	li	v1,9
8000a5ec:	ac430000 	sw	v1,0(v0)
 	   REG32(sys_pcie_phy) = (1<<3) |(1<<1) | (1<<0);     //bit1 load_done=1       //0x0b
8000a5f0:	2403000b 	li	v1,11
8000a5f4:	ac430000 	sw	v1,0(v0)
8000a5f8:	03e00008 	jr	ra
8000a5fc:	00000000 	nop

8000a600 <PCIE_PHY_Reset>:
	 #define PCIE_PHY0 	0xb8b01008
	 #define PCIE_PHY1 	0xb8b21008
	 
	unsigned int pcie_phy;

	if(portnum==0)	pcie_phy=PCIE_PHY0;
8000a600:	14800003 	bnez	a0,8000a610 <PCIE_PHY_Reset+0x10>
8000a604:	3c02b8b0 	lui	v0,0xb8b0
8000a608:	08002988 	j	8000a620 <PCIE_PHY_Reset+0x20>
8000a60c:	34421008 	ori	v0,v0,0x1008
	else if(portnum==1)	pcie_phy=PCIE_PHY1;
8000a610:	24020001 	li	v0,1
8000a614:	14820006 	bne	a0,v0,8000a630 <PCIE_PHY_Reset+0x30>
8000a618:	3c02b8b2 	lui	v0,0xb8b2
8000a61c:	34421008 	ori	v0,v0,0x1008
	else return;

        //4. PCIE PHY Reset       
	REG32(pcie_phy) = 0x01;	//bit7:PHY reset=0   bit0: Enable LTSSM=1
8000a620:	24030001 	li	v1,1
8000a624:	ac430000 	sw	v1,0(v0)
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
8000a628:	24030081 	li	v1,129
8000a62c:	ac430000 	sw	v1,0(v0)
8000a630:	03e00008 	jr	ra
8000a634:	00000000 	nop

8000a638 <HostPCIe_SetPhyMdioRead>:
//------------------------------------------------------------------------
unsigned int HostPCIe_SetPhyMdioRead(unsigned int portnum, unsigned int regaddr)
{
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
8000a638:	14800004 	bnez	a0,8000a64c <HostPCIe_SetPhyMdioRead+0x14>
8000a63c:	27bdfff8 	addiu	sp,sp,-8
8000a640:	3c03b8b0 	lui	v1,0xb8b0
8000a644:	0800299d 	j	8000a674 <HostPCIe_SetPhyMdioRead+0x3c>
8000a648:	34631000 	ori	v1,v1,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
8000a64c:	24020001 	li	v0,1
8000a650:	14820003 	bne	a0,v0,8000a660 <HostPCIe_SetPhyMdioRead+0x28>
8000a654:	3c03b8b2 	lui	v1,0xb8b2
8000a658:	0800299d 	j	8000a674 <HostPCIe_SetPhyMdioRead+0x3c>
8000a65c:	34631000 	ori	v1,v1,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO
8000a660:	24030002 	li	v1,2
8000a664:	14830014 	bne	a0,v1,8000a6b8 <HostPCIe_SetPhyMdioRead+0x80>
8000a668:	00001021 	move	v0,zero
8000a66c:	3c03b8b4 	lui	v1,0xb8b4
8000a670:	346310c0 	ori	v1,v1,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ((regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET)  | (0<<PCIE_MDIO_RDWR_OFFSET); 
8000a674:	30a5001f 	andi	a1,a1,0x1f
8000a678:	00052a00 	sll	a1,a1,0x8
8000a67c:	ac650000 	sw	a1,0(v1)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
8000a680:	afa00000 	sw	zero,0(sp)
8000a684:	8fa20000 	lw	v0,0(sp)
8000a688:	284215b3 	slti	v0,v0,5555
8000a68c:	10400008 	beqz	v0,8000a6b0 <HostPCIe_SetPhyMdioRead+0x78>
8000a690:	00000000 	nop
8000a694:	8fa20000 	lw	v0,0(sp)
8000a698:	24420001 	addiu	v0,v0,1
8000a69c:	afa20000 	sw	v0,0(sp)
8000a6a0:	8fa20000 	lw	v0,0(sp)
8000a6a4:	284215b3 	slti	v0,v0,5555
8000a6a8:	1440fffa 	bnez	v0,8000a694 <HostPCIe_SetPhyMdioRead+0x5c>
8000a6ac:	00000000 	nop

	int val;
	val=REG32(mdioaddr)&  (0xffff <<PCIE_MDIO_DATA_OFFSET) ;
8000a6b0:	8c620000 	lw	v0,0(v1)
	return ((val>>PCIE_MDIO_DATA_OFFSET)&0xffff);
8000a6b4:	00021402 	srl	v0,v0,0x10
	
}
8000a6b8:	27bd0008 	addiu	sp,sp,8
8000a6bc:	03e00008 	jr	ra
8000a6c0:	00000000 	nop

8000a6c4 <HostPCIe_SetPhyMdioWrite>:


void HostPCIe_SetPhyMdioWrite(unsigned int portnum, unsigned int regaddr, unsigned short val)
{
8000a6c4:	27bdfff8 	addiu	sp,sp,-8
	unsigned int mdioaddr;

	if(portnum==0)		mdioaddr=PCIE0_MDIO;	
8000a6c8:	14800004 	bnez	a0,8000a6dc <HostPCIe_SetPhyMdioWrite+0x18>
8000a6cc:	30c6ffff 	andi	a2,a2,0xffff
8000a6d0:	3c02b8b0 	lui	v0,0xb8b0
8000a6d4:	080029c0 	j	8000a700 <HostPCIe_SetPhyMdioWrite+0x3c>
8000a6d8:	34421000 	ori	v0,v0,0x1000
	else if(portnum==1)	mdioaddr=PCIE1_MDIO;
8000a6dc:	24020001 	li	v0,1
8000a6e0:	14820003 	bne	a0,v0,8000a6f0 <HostPCIe_SetPhyMdioWrite+0x2c>
8000a6e4:	3c02b8b2 	lui	v0,0xb8b2
8000a6e8:	080029c0 	j	8000a700 <HostPCIe_SetPhyMdioWrite+0x3c>
8000a6ec:	34421000 	ori	v0,v0,0x1000
	else if(portnum==2)	mdioaddr=0xb8b410c0;	  //EP MDIO	
8000a6f0:	24020002 	li	v0,2
8000a6f4:	14820014 	bne	a0,v0,8000a748 <HostPCIe_SetPhyMdioWrite+0x84>
8000a6f8:	3c02b8b4 	lui	v0,0xb8b4
8000a6fc:	344210c0 	ori	v0,v0,0x10c0
	else return 0;
	
	REG32(mdioaddr)= ( (regaddr&0x1f)<<PCIE_MDIO_REG_OFFSET) | ((val&0xffff)<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ; 
8000a700:	30a5001f 	andi	a1,a1,0x1f
8000a704:	00052a00 	sll	a1,a1,0x8
8000a708:	34a50001 	ori	a1,a1,0x1
8000a70c:	00063400 	sll	a2,a2,0x10
8000a710:	00a63025 	or	a2,a1,a2
8000a714:	ac460000 	sw	a2,0(v0)
	//delay 
	volatile int i;
	for(i=0;i<5555;i++)  ;
8000a718:	afa00000 	sw	zero,0(sp)
8000a71c:	8fa20000 	lw	v0,0(sp)
8000a720:	284215b3 	slti	v0,v0,5555
8000a724:	10400008 	beqz	v0,8000a748 <HostPCIe_SetPhyMdioWrite+0x84>
8000a728:	00000000 	nop
8000a72c:	8fa20000 	lw	v0,0(sp)
8000a730:	24420001 	addiu	v0,v0,1
8000a734:	afa20000 	sw	v0,0(sp)
8000a738:	8fa20000 	lw	v0,0(sp)
8000a73c:	284215b3 	slti	v0,v0,5555
8000a740:	1440fffa 	bnez	v0,8000a72c <HostPCIe_SetPhyMdioWrite+0x68>
8000a744:	00000000 	nop
}
8000a748:	27bd0008 	addiu	sp,sp,8
8000a74c:	03e00008 	jr	ra
8000a750:	00000000 	nop

8000a754 <HostPCIe_TestINT>:

}; 

//---------------------------------------------------------------------------
int  HostPCIe_TestINT(int argc, char* argv[])
{
8000a754:	27bdffc8 	addiu	sp,sp,-56
8000a758:	afbf0034 	sw	ra,52(sp)
8000a75c:	afbe0030 	sw	s8,48(sp)
8000a760:	afb7002c 	sw	s7,44(sp)
8000a764:	afb60028 	sw	s6,40(sp)
8000a768:	afb50024 	sw	s5,36(sp)
8000a76c:	afb40020 	sw	s4,32(sp)
8000a770:	afb3001c 	sw	s3,28(sp)
8000a774:	afb20018 	sw	s2,24(sp)
8000a778:	afb10014 	sw	s1,20(sp)
8000a77c:	afb00010 	sw	s0,16(sp)
	if( argc < 2 ) 
8000a780:	28820002 	slti	v0,a0,2
8000a784:	10400006 	beqz	v0,8000a7a0 <HostPCIe_TestINT+0x4c>
8000a788:	00a08021 	move	s0,a1
	{
		dprintf("eint <portnum> <loops>.\n");	
8000a78c:	3c048001 	lui	a0,0x8001
8000a790:	0c001cc1 	jal	80007304 <dprintf>
8000a794:	24841730 	addiu	a0,a0,5936
8000a798:	08002a41 	j	8000a904 <HostPCIe_TestINT+0x1b0>
8000a79c:	00001021 	move	v0,zero
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000a7a0:	18800052 	blez	a0,8000a8ec <HostPCIe_TestINT+0x198>
8000a7a4:	00000000 	nop
8000a7a8:	8ca40000 	lw	a0,0(a1)
8000a7ac:	00002821 	move	a1,zero
8000a7b0:	0c001a60 	jal	80006980 <strtoul>
8000a7b4:	24060010 	li	a2,16
8000a7b8:	00408821 	move	s1,v0
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000a7bc:	8e040004 	lw	a0,4(s0)
8000a7c0:	00002821 	move	a1,zero
8000a7c4:	0c001a60 	jal	80006980 <strtoul>
8000a7c8:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;
	
	if(portnum==0)
8000a7cc:	1620003e 	bnez	s1,8000a8c8 <HostPCIe_TestINT+0x174>
8000a7d0:	0040b821 	move	s7,v0
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
8000a7d4:	3c10b900 	lui	s0,0xb900
8000a7d8:	3610003c 	ori	s0,s0,0x3c
8000a7dc:	8e020000 	lw	v0,0(s0)
8000a7e0:	34420100 	ori	v0,v0,0x100
8000a7e4:	ae020000 	sw	v0,0(s0)
8000a7e8:	0200b021 	move	s6,s0
8000a7ec:	3c15b900 	lui	s5,0xb900
8000a7f0:	3c130020 	lui	s3,0x20

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
8000a7f4:	12e00032 	beqz	s7,8000a8c0 <HostPCIe_TestINT+0x16c>
8000a7f8:	0000a021 	move	s4,zero
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
8000a7fc:	26b50038 	addiu	s5,s5,56
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
8000a800:	3c120100 	lui	s2,0x100
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000a804:	3c1e8001 	lui	s8,0x8001
8000a808:	27de174c 	addiu	s8,s8,5964

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
8000a80c:	3c11b800 	lui	s1,0xb800
8000a810:	36313004 	ori	s1,s1,0x3004
	
	int i;
	for(i=0; i<loops; i++)
	{

		REG32(memmapaddr + 0x38) |= (1<<0);  //kick swint
8000a814:	8ea20000 	lw	v0,0(s5)
8000a818:	34420001 	ori	v0,v0,0x1
8000a81c:	aea20000 	sw	v0,0(s5)
		
		while(1) 
		{
			if( REG32(memmapaddr + 0x3c) & SWINT)   //check interrupt status swINT=1
8000a820:	8e020000 	lw	v0,0(s0)
8000a824:	00521024 	and	v0,v0,s2
8000a828:	1040fffd 	beqz	v0,8000a820 <HostPCIe_TestINT+0xcc>
8000a82c:	00000000 	nop
				break;
		}

		dprintf("Got   SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000a830:	8e060000 	lw	a2,0(s0)
8000a834:	03c02021 	move	a0,s8
8000a838:	0c001cc1 	jal	80007304 <dprintf>
8000a83c:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( REG32(GISR) & PCIEISR )  //check pcie port 0
8000a840:	8e220000 	lw	v0,0(s1)
8000a844:	02621024 	and	v0,s3,v0
8000a848:	1040fffd 	beqz	v0,8000a840 <HostPCIe_TestINT+0xec>
8000a84c:	00000000 	nop
				break;
		}
		dprintf("Got   GISR=%x \n", REG32(0xb8003004) );
8000a850:	8e250000 	lw	a1,0(s1)
8000a854:	3c048001 	lui	a0,0x8001
8000a858:	0c001cc1 	jal	80007304 <dprintf>
8000a85c:	24841760 	addiu	a0,a0,5984


		//-----------------
		REG32(memmapaddr + 0x3c) |= SWINT;  //write to clear
8000a860:	8e020000 	lw	v0,0(s0)
8000a864:	00521025 	or	v0,v0,s2
8000a868:	ae020000 	sw	v0,0(s0)



		while(1) 
		{
			if( (REG32(memmapaddr + 0x3c) & SWINT) ==0)  //check interrupt status swINT=1
8000a86c:	8e020000 	lw	v0,0(s0)
8000a870:	00521024 	and	v0,v0,s2
8000a874:	1440fffd 	bnez	v0,8000a86c <HostPCIe_TestINT+0x118>
8000a878:	00000000 	nop
				break;
		}

		dprintf("Clear SWINT %x=%x \n",memmapaddr + 0x3c, REG32(memmapaddr + 0x3c) );
8000a87c:	8e060000 	lw	a2,0(s0)
8000a880:	3c048001 	lui	a0,0x8001
8000a884:	24841770 	addiu	a0,a0,6000
8000a888:	0c001cc1 	jal	80007304 <dprintf>
8000a88c:	02c02821 	move	a1,s6

		
		while(1) 
		{
			if( (REG32(GISR) & PCIEISR )==0)  //check pcie port 0
8000a890:	8e220000 	lw	v0,0(s1)
8000a894:	02621024 	and	v0,s3,v0
8000a898:	1440fffd 	bnez	v0,8000a890 <HostPCIe_TestINT+0x13c>
8000a89c:	00000000 	nop
				break;
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
8000a8a0:	8e250000 	lw	a1,0(s1)
8000a8a4:	3c048001 	lui	a0,0x8001
8000a8a8:	0c001cc1 	jal	80007304 <dprintf>
8000a8ac:	24841784 	addiu	a0,a0,6020

	
	#define GISR (0xb8003004)
	
	int i;
	for(i=0; i<loops; i++)
8000a8b0:	26940001 	addiu	s4,s4,1
8000a8b4:	0297102b 	sltu	v0,s4,s7
8000a8b8:	1440ffd6 	bnez	v0,8000a814 <HostPCIe_TestINT+0xc0>
8000a8bc:	00000000 	nop
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
8000a8c0:	08002a42 	j	8000a908 <HostPCIe_TestINT+0x1b4>
8000a8c4:	8fbf0034 	lw	ra,52(sp)
		cfgaddr=PCIE1_EP_CFG_BASE;
		iomapaddr=PCIE1_MAP_IO_BASE;
		memmapaddr=PCIE1_MAP_MEM_BASE;	
	}

	REG32(memmapaddr + 0x3c) |= (1<<8);  //swint mask
8000a8c8:	3c10ba00 	lui	s0,0xba00
8000a8cc:	3610003c 	ori	s0,s0,0x3c
8000a8d0:	8e020000 	lw	v0,0(s0)
8000a8d4:	34420100 	ori	v0,v0,0x100
8000a8d8:	ae020000 	sw	v0,0(s0)
8000a8dc:	0200b021 	move	s6,s0
8000a8e0:	3c15ba00 	lui	s5,0xba00
8000a8e4:	080029fd 	j	8000a7f4 <HostPCIe_TestINT+0xa0>
8000a8e8:	3c130040 	lui	s3,0x40
	
		return 0;
	}
	unsigned int portnum=0, loops=10;
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   loops = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000a8ec:	8ca40004 	lw	a0,4(a1)
8000a8f0:	00002821 	move	a1,zero
8000a8f4:	0c001a60 	jal	80006980 <strtoul>
8000a8f8:	24060010 	li	a2,16
8000a8fc:	080029f5 	j	8000a7d4 <HostPCIe_TestINT+0x80>
8000a900:	0040b821 	move	s7,v0
		}
		dprintf("Clear GISR=%x \n", REG32(0xb8003004) );
	}
	

}
8000a904:	8fbf0034 	lw	ra,52(sp)
8000a908:	8fbe0030 	lw	s8,48(sp)
8000a90c:	8fb7002c 	lw	s7,44(sp)
8000a910:	8fb60028 	lw	s6,40(sp)
8000a914:	8fb50024 	lw	s5,36(sp)
8000a918:	8fb40020 	lw	s4,32(sp)
8000a91c:	8fb3001c 	lw	s3,28(sp)
8000a920:	8fb20018 	lw	s2,24(sp)
8000a924:	8fb10014 	lw	s1,20(sp)
8000a928:	8fb00010 	lw	s0,16(sp)
8000a92c:	03e00008 	jr	ra
8000a930:	27bd0038 	addiu	sp,sp,56

8000a934 <HostPCIe_MDIOWrite>:


}; 
//----------------------------------------------------------------------------
int HostPCIe_MDIOWrite(int argc, char* argv[])
{
8000a934:	27bdffe0 	addiu	sp,sp,-32
8000a938:	afbf001c 	sw	ra,28(sp)
8000a93c:	afb20018 	sw	s2,24(sp)
8000a940:	afb10014 	sw	s1,20(sp)
8000a944:	afb00010 	sw	s0,16(sp)

	if(argc<3)
8000a948:	28840003 	slti	a0,a0,3
8000a94c:	10800009 	beqz	a0,8000a974 <HostPCIe_MDIOWrite+0x40>
8000a950:	00a08021 	move	s0,a1
	{	 
		dprintf("mdiow <portnum> <addr> <val> \n");		
8000a954:	3c048001 	lui	a0,0x8001
8000a958:	0c001cc1 	jal	80007304 <dprintf>
8000a95c:	24841794 	addiu	a0,a0,6036
		dprintf("ex: mdiow 0 00  ffff \n");			
8000a960:	3c048001 	lui	a0,0x8001
8000a964:	0c001cc1 	jal	80007304 <dprintf>
8000a968:	248417b4 	addiu	a0,a0,6068
		return;	
8000a96c:	08002a70 	j	8000a9c0 <HostPCIe_MDIOWrite+0x8c>
8000a970:	8fbf001c 	lw	ra,28(sp)
	}

	unsigned int portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000a974:	8ca40000 	lw	a0,0(a1)
8000a978:	00002821 	move	a1,zero
8000a97c:	0c001a60 	jal	80006980 <strtoul>
8000a980:	24060010 	li	a2,16
8000a984:	00408821 	move	s1,v0
	unsigned int addr = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000a988:	8e040004 	lw	a0,4(s0)
8000a98c:	00002821 	move	a1,zero
8000a990:	0c001a60 	jal	80006980 <strtoul>
8000a994:	24060010 	li	a2,16
8000a998:	00409021 	move	s2,v0
	unsigned int val = strtoul((const char*)(argv[2]), (char **)NULL, 16);	
8000a99c:	8e040008 	lw	a0,8(s0)
8000a9a0:	00002821 	move	a1,zero
8000a9a4:	0c001a60 	jal	80006980 <strtoul>
8000a9a8:	24060010 	li	a2,16
/*
	REG32(PCIE0_MDIO)= (addr<<PCIE_MDIO_REG_OFFSET) | (val<<PCIE_MDIO_DATA_OFFSET)  | (1<<PCIE_MDIO_RDWR_OFFSET) ;   ;   
*/
	HostPCIe_SetPhyMdioWrite(portnum, addr, val);
8000a9ac:	02202021 	move	a0,s1
8000a9b0:	02402821 	move	a1,s2
8000a9b4:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000a9b8:	3046ffff 	andi	a2,v0,0xffff

}; 
8000a9bc:	8fbf001c 	lw	ra,28(sp)
8000a9c0:	8fb20018 	lw	s2,24(sp)
8000a9c4:	8fb10014 	lw	s1,20(sp)
8000a9c8:	8fb00010 	lw	s0,16(sp)
8000a9cc:	03e00008 	jr	ra
8000a9d0:	27bd0020 	addiu	sp,sp,32

8000a9d4 <HostPCIe_MDIORead>:
}


//----------------------------------------------------------------------------
int HostPCIe_MDIORead(int argc, char* argv[])
{
8000a9d4:	27bdffd8 	addiu	sp,sp,-40
8000a9d8:	afbf0024 	sw	ra,36(sp)
8000a9dc:	afb30020 	sw	s3,32(sp)
8000a9e0:	afb2001c 	sw	s2,28(sp)
8000a9e4:	afb10018 	sw	s1,24(sp)
8000a9e8:	afb00014 	sw	s0,20(sp)
		return;
	}
*/	
	unsigned int portnum=0;
	
	if(argc>=1)
8000a9ec:	18800006 	blez	a0,8000aa08 <HostPCIe_MDIORead+0x34>
8000a9f0:	00008821 	move	s1,zero
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000a9f4:	8ca40000 	lw	a0,0(a1)
8000a9f8:	00002821 	move	a1,zero
8000a9fc:	0c001a60 	jal	80006980 <strtoul>
8000aa00:	24060010 	li	a2,16
8000aa04:	00408821 	move	s1,v0
8000aa08:	00008021 	move	s0,zero
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
		dprintf("MDIO Reg %x=%x \n", i,val);
8000aa0c:	3c128001 	lui	s2,0x8001
8000aa10:	265217cc 	addiu	s2,s2,6092
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
8000aa14:	24130020 	li	s3,32
		REG32(PCIE0_MDIO)= (i<<PCIE_MDIO_REG_OFFSET) | (0<<PCIE_MDIO_RDWR_OFFSET) ;   
		for(j=0;j<0x5555;j++) ;
		val=REG32(PCIE0_MDIO);
		val=( val& PCIE_MDIO_DATA_MASK ) >> PCIE_MDIO_DATA_OFFSET;		
	*/
		val=HostPCIe_SetPhyMdioRead(portnum, i);
8000aa18:	02202021 	move	a0,s1
8000aa1c:	0c00298e 	jal	8000a638 <HostPCIe_SetPhyMdioRead>
8000aa20:	02002821 	move	a1,s0
		dprintf("MDIO Reg %x=%x \n", i,val);
8000aa24:	02402021 	move	a0,s2
8000aa28:	02002821 	move	a1,s0
8000aa2c:	0c001cc1 	jal	80007304 <dprintf>
8000aa30:	00403021 	move	a2,v0
	unsigned int portnum=0;
	
	if(argc>=1)
		portnum	= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	for(i=0; i<=0x1f; i++)
8000aa34:	26100001 	addiu	s0,s0,1
8000aa38:	1613fff8 	bne	s0,s3,8000aa1c <HostPCIe_MDIORead+0x48>
8000aa3c:	02202021 	move	a0,s1

	}



}; 
8000aa40:	8fbf0024 	lw	ra,36(sp)
8000aa44:	8fb30020 	lw	s3,32(sp)
8000aa48:	8fb2001c 	lw	s2,28(sp)
8000aa4c:	8fb10018 	lw	s1,24(sp)
8000aa50:	8fb00014 	lw	s0,20(sp)
8000aa54:	03e00008 	jr	ra
8000aa58:	27bd0028 	addiu	sp,sp,40

8000aa5c <PCIE_Host_Init>:
}; 


//--------------------------------------------------------------------------
int PCIE_Host_Init(int argc, char* argv[])
{
8000aa5c:	27bdffe0 	addiu	sp,sp,-32
8000aa60:	afbf001c 	sw	ra,28(sp)
8000aa64:	afb10018 	sw	s1,24(sp)
8000aa68:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	if(argc >= 1) 
8000aa6c:	18800010 	blez	a0,8000aab0 <PCIE_Host_Init+0x54>
8000aa70:	3c04b900 	lui	a0,0xb900
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000aa74:	8ca40000 	lw	a0,0(a1)
8000aa78:	00002821 	move	a1,zero
8000aa7c:	0c001a60 	jal	80006980 <strtoul>
8000aa80:	24060010 	li	a2,16

	int rc_cfg, cfgaddr;
	int iomapaddr;
	int memmapaddr;

	if(portnum==0)
8000aa84:	10400009 	beqz	v0,8000aaac <PCIE_Host_Init+0x50>
8000aa88:	00401821 	move	v1,v0
	{	rc_cfg=PCIE0_RC_CFG_BASE;
		cfgaddr=PCIE0_EP_CFG_BASE;
		iomapaddr=PCIE0_MAP_IO_BASE;
		memmapaddr=PCIE0_MAP_MEM_BASE;
	}
	else if(portnum==1)
8000aa8c:	24040001 	li	a0,1
8000aa90:	1464004b 	bne	v1,a0,8000abc0 <PCIE_Host_Init+0x164>
8000aa94:	00001021 	move	v0,zero
8000aa98:	3c04ba00 	lui	a0,0xba00
8000aa9c:	3c07b8e0 	lui	a3,0xb8e0
8000aaa0:	3c03b8b3 	lui	v1,0xb8b3
8000aaa4:	08002aaf 	j	8000aabc <PCIE_Host_Init+0x60>
8000aaa8:	3c10b8b2 	lui	s0,0xb8b2
8000aaac:	3c04b900 	lui	a0,0xb900
8000aab0:	3c07b8c0 	lui	a3,0xb8c0
8000aab4:	3c03b8b1 	lui	v1,0xb8b1
8000aab8:	3c10b8b0 	lui	s0,0xb8b0
	}
	else 
	{	return 0;
	}
	
	int t=REG32(rc_cfg);
8000aabc:	8e060000 	lw	a2,0(s0)
	unsigned int vid=t&0x0000ffff;   //0x819810EC
8000aac0:	30c5ffff 	andi	a1,a2,0xffff
	unsigned int pid=(t&0xffff0000) >>16;
	
	if( (vid!= 0x10ec) || (pid!=0x8198))
8000aac4:	240210ec 	li	v0,4332
8000aac8:	14a20004 	bne	a1,v0,8000aadc <PCIE_Host_Init+0x80>
8000aacc:	00063402 	srl	a2,a2,0x10
8000aad0:	34028198 	li	v0,0x8198
8000aad4:	10c20009 	beq	a2,v0,8000aafc <PCIE_Host_Init+0xa0>
8000aad8:	00000000 	nop
	{	DBG_PRINT("VID=%x, PID=%x \n", vid, pid );
8000aadc:	3c048001 	lui	a0,0x8001
8000aae0:	0c001cc1 	jal	80007304 <dprintf>
8000aae4:	248417e0 	addiu	a0,a0,6112
		DBG_PRINT(" !!!  Read VID PID fail !!! \n");
8000aae8:	3c048001 	lui	a0,0x8001
8000aaec:	0c001cc1 	jal	80007304 <dprintf>
8000aaf0:	248417f4 	addiu	a0,a0,6132
		//at_errcnt++;
		return;
8000aaf4:	08002af1 	j	8000abc4 <PCIE_Host_Init+0x168>
8000aaf8:	8fbf001c 	lw	ra,28(sp)
	//CMD
	//bit 2: Enable Bys master, 
	//bit 1: enable memmap, 
	//bit 0: enable iomap

	REG32(rc_cfg + 0x04)= 0x00100007;   
8000aafc:	26050004 	addiu	a1,s0,4
8000ab00:	3c020010 	lui	v0,0x10
8000ab04:	34420007 	ori	v0,v0,0x7
8000ab08:	aca20000 	sw	v0,0(a1)

	//Device Control Register 
	//bit [7-5]  payload size
	REG32(rc_cfg + 0x78)= (REG32(rc_cfg + 0x78 ) & (~0xE0)) | MAX_PAYLOAD_SIZE_128B;  // Set MAX_PAYLOAD_SIZE to 128B,default
8000ab0c:	26060078 	addiu	a2,s0,120
8000ab10:	8cc80000 	lw	t0,0(a2)
8000ab14:	2405ff1f 	li	a1,-225
8000ab18:	01054024 	and	t0,t0,a1
8000ab1c:	acc80000 	sw	t0,0(a2)
	  
      REG32(cfgaddr + 0x04)= 0x00100007;    //0x00180007
8000ab20:	24660004 	addiu	a2,v1,4
8000ab24:	acc20000 	sw	v0,0(a2)

	//bit 0: 0:memory, 1 io indicate
      REG32(cfgaddr + 0x10)= (iomapaddr | 0x00000001) & 0x1FFFFFFF;  // Set BAR0
8000ab28:	24620010 	addiu	v0,v1,16
8000ab2c:	3c061fff 	lui	a2,0x1fff
8000ab30:	34c8fffe 	ori	t0,a2,0xfffe
8000ab34:	00e83824 	and	a3,a3,t0
8000ab38:	34e70001 	ori	a3,a3,0x1
8000ab3c:	ac470000 	sw	a3,0(v0)

	//bit 3: prefetch
	//bit [2:1] 00:32bit, 01:reserved, 10:64bit 11:reserved
      REG32(cfgaddr + 0x18)= (memmapaddr | 0x00000004) & 0x1FFFFFFF;  // Set BAR1  
8000ab40:	24710018 	addiu	s1,v1,24
8000ab44:	34c6fffb 	ori	a2,a2,0xfffb
8000ab48:	00862024 	and	a0,a0,a2
8000ab4c:	34840004 	ori	a0,a0,0x4
8000ab50:	ae240000 	sw	a0,0(s1)


	//offset 0x78 [7:5]
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0xE0)) | (MAX_PAYLOAD_SIZE_128B);  // Set MAX_PAYLOAD_SIZE to 128B
8000ab54:	24630078 	addiu	v1,v1,120
8000ab58:	8c640000 	lw	a0,0(v1)
8000ab5c:	00852824 	and	a1,a0,a1
8000ab60:	ac650000 	sw	a1,0(v1)

	//offset 0x79: [6:4] 
      REG32(cfgaddr + 0x78) = (REG32(cfgaddr + 0x78) & (~0x7000)) | (MAX_READ_REQSIZE_256B<<8);  // Set MAX_REQ_SIZE to 256B,default
8000ab64:	8c650000 	lw	a1,0(v1)
8000ab68:	24048fff 	li	a0,-28673
8000ab6c:	00a42024 	and	a0,a1,a0
8000ab70:	34841000 	ori	a0,a0,0x1000
8000ab74:	ac640000 	sw	a0,0(v1)

	  
	//check
//      if(REG32(cfgaddr + 0x10) != ((iomapaddr | 0x00000001) & 0x1FFFFFFF))
      {	//at_errcnt++;
      		DBG_PRINT("Read Bar0=%x \n", REG32(cfgaddr + 0x10)); //for test
8000ab78:	8c450000 	lw	a1,0(v0)
8000ab7c:	3c048001 	lui	a0,0x8001
8000ab80:	0c001cc1 	jal	80007304 <dprintf>
8000ab84:	24841814 	addiu	a0,a0,6164
      	}
	  

//	if(REG32(cfgaddr + 0x18)!=((memmapaddr| 0x00000004) & 0x1FFFFFFF))
	{	//at_errcnt++;
      		DBG_PRINT("Read Bar1=%x \n", REG32(cfgaddr + 0x18));      //for test
8000ab88:	8e250000 	lw	a1,0(s1)
8000ab8c:	3c048001 	lui	a0,0x8001
8000ab90:	0c001cc1 	jal	80007304 <dprintf>
8000ab94:	24841824 	addiu	a0,a0,6180
	}
	DBG_PRINT("Set BAR finish \n");
8000ab98:	3c048001 	lui	a0,0x8001
8000ab9c:	0c001cc1 	jal	80007304 <dprintf>
8000aba0:	24841834 	addiu	a0,a0,6196


	//io and mem limit, setting to no litmit
	REG32(rc_cfg+ 0x1c) = (2<<4) | (0<<12);   //  [7:4]=base  [15:12]=limit
8000aba4:	2603001c 	addiu	v1,s0,28
8000aba8:	24020020 	li	v0,32
8000abac:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x20) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit	
8000abb0:	26030020 	addiu	v1,s0,32
8000abb4:	ac620000 	sw	v0,0(v1)
	REG32(rc_cfg+ 0x24) = (2<<4) | (0<<20);   //  [15:4]=base  [31:20]=limit		
8000abb8:	26100024 	addiu	s0,s0,36
8000abbc:	ae020000 	sw	v0,0(s0)

}
8000abc0:	8fbf001c 	lw	ra,28(sp)
8000abc4:	8fb10018 	lw	s1,24(sp)
8000abc8:	8fb00014 	lw	s0,20(sp)
8000abcc:	03e00008 	jr	ra
8000abd0:	27bd0020 	addiu	sp,sp,32

8000abd4 <PCIE_PHYLoop>:
		
};

//---------------------------------------------------------------------------
int PCIE_PHYLoop(int argc, char* argv[])
{
8000abd4:	27bdffd8 	addiu	sp,sp,-40
8000abd8:	afbf0024 	sw	ra,36(sp)
8000abdc:	afb30020 	sw	s3,32(sp)
8000abe0:	afb2001c 	sw	s2,28(sp)
8000abe4:	afb10018 	sw	s1,24(sp)
8000abe8:	afb00014 	sw	s0,20(sp)
	int portnum=0;
	int mode=1; 
	if( argc < 2 ) 
8000abec:	28820002 	slti	v0,a0,2
8000abf0:	10400006 	beqz	v0,8000ac0c <PCIE_PHYLoop+0x38>
8000abf4:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
8000abf8:	3c048001 	lui	a0,0x8001
8000abfc:	0c001cc1 	jal	80007304 <dprintf>
8000ac00:	24841848 	addiu	a0,a0,6216
		dprintf("ERR=%x\n",v);
	}
	


}; 
8000ac04:	08002b52 	j	8000ad48 <PCIE_PHYLoop+0x174>
8000ac08:	00001021 	move	v0,zero
	if( argc < 2 ) 
	{
		dprintf("epdn <portnum> <stop/start>.\n");	
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000ac0c:	18800006 	blez	a0,8000ac28 <PCIE_PHYLoop+0x54>
8000ac10:	00008821 	move	s1,zero
8000ac14:	8ca40000 	lw	a0,0(a1)
8000ac18:	00002821 	move	a1,zero
8000ac1c:	0c001a60 	jal	80006980 <strtoul>
8000ac20:	24060010 	li	a2,16
8000ac24:	00408821 	move	s1,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000ac28:	8e040004 	lw	a0,4(s0)
8000ac2c:	00002821 	move	a1,zero
8000ac30:	0c001a60 	jal	80006980 <strtoul>
8000ac34:	24060010 	li	a2,16
8000ac38:	00409021 	move	s2,v0




	unsigned int v;
	v=HostPCIe_SetPhyMdioRead(portnum, 0);  
8000ac3c:	02208021 	move	s0,s1
8000ac40:	02202021 	move	a0,s1
8000ac44:	0c00298e 	jal	8000a638 <HostPCIe_SetPhyMdioRead>
8000ac48:	00002821 	move	a1,zero
8000ac4c:	00409821 	move	s3,v0


	if(mode==1)
8000ac50:	24020001 	li	v0,1
8000ac54:	16420023 	bne	s2,v0,8000ace4 <PCIE_PHYLoop+0x110>
8000ac58:	3c048001 	lui	a0,0x8001
	{	
		dprintf("Start... port=%d   ", portnum);
8000ac5c:	24841868 	addiu	a0,a0,6248
8000ac60:	0c001cc1 	jal	80007304 <dprintf>
8000ac64:	02202821 	move	a1,s1

		v=v|(1<<8);  //bit 8
		HostPCIe_SetPhyMdioWrite(portnum, 0x00, v);  
8000ac68:	36660100 	ori	a2,s3,0x100
8000ac6c:	02202021 	move	a0,s1
8000ac70:	00002821 	move	a1,zero
8000ac74:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000ac78:	30c6ffff 	andi	a2,a2,0xffff
		
		// start bist
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8497);  
8000ac7c:	02202021 	move	a0,s1
8000ac80:	24050013 	li	a1,19
8000ac84:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000ac88:	34068497 	li	a2,0x8497
		delay_ms(100);
8000ac8c:	0c001bb5 	jal	80006ed4 <delay_ms>
8000ac90:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x14, 0xde01);  
8000ac94:	02202021 	move	a0,s1
8000ac98:	24050014 	li	a1,20
8000ac9c:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000aca0:	3406de01 	li	a2,0xde01
		delay_ms(100);		
8000aca4:	0c001bb5 	jal	80006ed4 <delay_ms>
8000aca8:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x8c97);  
8000acac:	02202021 	move	a0,s1
8000acb0:	24050013 	li	a1,19
8000acb4:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000acb8:	34068c97 	li	a2,0x8c97
		delay_ms(100);		
8000acbc:	0c001bb5 	jal	80006ed4 <delay_ms>
8000acc0:	24040064 	li	a0,100
		HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0xcc97);  	
8000acc4:	02202021 	move	a0,s1
8000acc8:	24050013 	li	a1,19
8000accc:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000acd0:	3406cc97 	li	a2,0xcc97
		delay_ms(100);		
8000acd4:	0c001bb5 	jal	80006ed4 <delay_ms>
8000acd8:	24040064 	li	a0,100
8000acdc:	08002b42 	j	8000ad08 <PCIE_PHYLoop+0x134>
8000ace0:	00000000 	nop
		//end bist


	
	}
	else if(mode==0)
8000ace4:	16400008 	bnez	s2,8000ad08 <PCIE_PHYLoop+0x134>
8000ace8:	3c048001 	lui	a0,0x8001
	{	
		dprintf("Stop...  port=%d  ", portnum);	
8000acec:	2484187c 	addiu	a0,a0,6268
8000acf0:	0c001cc1 	jal	80007304 <dprintf>
8000acf4:	02202821 	move	a1,s1
		v=v&0xffffffff-(1<<8);
		HostPCIe_SetPhyMdioWrite(portnum, 0, v);  	
8000acf8:	02202021 	move	a0,s1
8000acfc:	00002821 	move	a1,zero
8000ad00:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000ad04:	3266feff 	andi	a2,s3,0xfeff
	}


	//if(mode==1)
	{
		delay_ms(500);
8000ad08:	0c001bb5 	jal	80006ed4 <delay_ms>
8000ad0c:	240401f4 	li	a0,500
		
		v=HostPCIe_SetPhyMdioRead(portnum, 0x17);	
8000ad10:	02002021 	move	a0,s0
8000ad14:	0c00298e 	jal	8000a638 <HostPCIe_SetPhyMdioRead>
8000ad18:	24050017 	li	a1,23
		dprintf("LOOP CNT=%x ",v);		
8000ad1c:	3c048001 	lui	a0,0x8001
8000ad20:	24841890 	addiu	a0,a0,6288
8000ad24:	0c001cc1 	jal	80007304 <dprintf>
8000ad28:	00402821 	move	a1,v0
		v=HostPCIe_SetPhyMdioRead(portnum, 0x18);
8000ad2c:	02002021 	move	a0,s0
8000ad30:	0c00298e 	jal	8000a638 <HostPCIe_SetPhyMdioRead>
8000ad34:	24050018 	li	a1,24
		v=(v &  (0xff<<4)) >>4;  //bit [11:04]
		dprintf("ERR=%x\n",v);
8000ad38:	3c048001 	lui	a0,0x8001
8000ad3c:	248418a0 	addiu	a0,a0,6304
8000ad40:	0c001cc1 	jal	80007304 <dprintf>
8000ad44:	7c453900 	ext	a1,v0,0x4,0x8
	}
	


}; 
8000ad48:	8fbf0024 	lw	ra,36(sp)
8000ad4c:	8fb30020 	lw	s3,32(sp)
8000ad50:	8fb2001c 	lw	s2,28(sp)
8000ad54:	8fb10018 	lw	s1,24(sp)
8000ad58:	8fb00014 	lw	s0,20(sp)
8000ad5c:	03e00008 	jr	ra
8000ad60:	27bd0028 	addiu	sp,sp,40

8000ad64 <PCIE_PowerDown>:

}; 
//---------------------------------------------------------------------------

int  PCIE_PowerDown(int argc, char* argv[])
{
8000ad64:	27bdffd8 	addiu	sp,sp,-40
8000ad68:	afbf0024 	sw	ra,36(sp)
8000ad6c:	afb40020 	sw	s4,32(sp)
8000ad70:	afb3001c 	sw	s3,28(sp)
8000ad74:	afb20018 	sw	s2,24(sp)
8000ad78:	afb10014 	sw	s1,20(sp)
8000ad7c:	afb00010 	sw	s0,16(sp)
	 
	 int portnum=0;
	 int mode=0;
	int baseaddr=0xb8b00000;
	 
	if( argc < 2 ) 
8000ad80:	28820002 	slti	v0,a0,2
8000ad84:	1040002c 	beqz	v0,8000ae38 <PCIE_PowerDown+0xd4>
8000ad88:	00a08021 	move	s0,a1
	{
		dprintf("epdn <portnum> <mode>.\n");	
8000ad8c:	3c048001 	lui	a0,0x8001
8000ad90:	0c001cc1 	jal	80007304 <dprintf>
8000ad94:	248418a8 	addiu	a0,a0,6312
		dprintf("epdn 0: D0 ->L0 \n");			
8000ad98:	3c048001 	lui	a0,0x8001
8000ad9c:	0c001cc1 	jal	80007304 <dprintf>
8000ada0:	248418c0 	addiu	a0,a0,6336
		dprintf("epdn 3: D3hot ->L1 \n");
8000ada4:	3c048001 	lui	a0,0x8001
8000ada8:	0c001cc1 	jal	80007304 <dprintf>
8000adac:	248418d4 	addiu	a0,a0,6356
		dprintf("epdn 4: board cast PME_TurnOff \n");	
8000adb0:	3c048001 	lui	a0,0x8001
8000adb4:	0c001cc1 	jal	80007304 <dprintf>
8000adb8:	248418ec 	addiu	a0,a0,6380
		
		dprintf("epdn 7: enable aspm and L0s entry \n");	
8000adbc:	3c048001 	lui	a0,0x8001
8000adc0:	0c001cc1 	jal	80007304 <dprintf>
8000adc4:	24841910 	addiu	a0,a0,6416
		dprintf("epdn 8: enable aspm and L1 entry \n");	
8000adc8:	3c048001 	lui	a0,0x8001
8000adcc:	0c001cc1 	jal	80007304 <dprintf>
8000add0:	24841934 	addiu	a0,a0,6452
		dprintf("epdn 9: diable  aspm \n");	
8000add4:	3c048001 	lui	a0,0x8001
8000add8:	0c001cc1 	jal	80007304 <dprintf>
8000addc:	24841958 	addiu	a0,a0,6488

		dprintf("epdn 010: measure L0->L1->L0 \n");		
8000ade0:	3c048001 	lui	a0,0x8001
8000ade4:	0c001cc1 	jal	80007304 <dprintf>
8000ade8:	24841970 	addiu	a0,a0,6512
		dprintf("epdn 020: measure L0->L2->L0 \n");			
8000adec:	3c048001 	lui	a0,0x8001
8000adf0:	0c001cc1 	jal	80007304 <dprintf>
8000adf4:	24841990 	addiu	a0,a0,6544
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
8000adf8:	3c02b8b0 	lui	v0,0xb8b0
8000adfc:	34420728 	ori	v0,v0,0x728
8000ae00:	8c450000 	lw	a1,0(v0)
8000ae04:	3c048001 	lui	a0,0x8001
8000ae08:	248419b0 	addiu	a0,a0,6576
8000ae0c:	0c001cc1 	jal	80007304 <dprintf>
8000ae10:	30a5001f 	andi	a1,a1,0x1f
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
8000ae14:	3c02b8b2 	lui	v0,0xb8b2
8000ae18:	34420728 	ori	v0,v0,0x728
8000ae1c:	8c450000 	lw	a1,0(v0)
8000ae20:	3c048001 	lui	a0,0x8001
8000ae24:	248419c4 	addiu	a0,a0,6596
8000ae28:	0c001cc1 	jal	80007304 <dprintf>
8000ae2c:	30a5001f 	andi	a1,a1,0x1f
		return 0;
8000ae30:	08002c79 	j	8000b1e4 <PCIE_PowerDown+0x480>
8000ae34:	00001021 	move	v0,zero
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000ae38:	188000e2 	blez	a0,8000b1c4 <PCIE_PowerDown+0x460>
8000ae3c:	00000000 	nop
8000ae40:	8ca40000 	lw	a0,0(a1)
8000ae44:	00002821 	move	a1,zero
8000ae48:	0c001a60 	jal	80006980 <strtoul>
8000ae4c:	24060010 	li	a2,16
8000ae50:	00409021 	move	s2,v0
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000ae54:	8e040004 	lw	a0,4(s0)
8000ae58:	00002821 	move	a1,zero
8000ae5c:	0c001a60 	jal	80006980 <strtoul>
8000ae60:	24060010 	li	a2,16
	int tmp;

	if(portnum==0) baseaddr=PCIE0_RC_CFG_BASE;
8000ae64:	12400009 	beqz	s2,8000ae8c <PCIE_PowerDown+0x128>
8000ae68:	00408021 	move	s0,v0
	else if(portnum==1) baseaddr=PCIE1_RC_CFG_BASE;
8000ae6c:	24020001 	li	v0,1
8000ae70:	12420007 	beq	s2,v0,8000ae90 <PCIE_PowerDown+0x12c>
8000ae74:	3c11b8b2 	lui	s1,0xb8b2
	else { dprintf("Only support P0 and P1 \n"); return 0; }
8000ae78:	3c048001 	lui	a0,0x8001
8000ae7c:	0c001cc1 	jal	80007304 <dprintf>
8000ae80:	248419d8 	addiu	a0,a0,6616
8000ae84:	08002c6f 	j	8000b1bc <PCIE_PowerDown+0x458>
8000ae88:	00001021 	move	v0,zero
8000ae8c:	3c11b8b0 	lui	s1,0xb8b0


	if(mode==0)
8000ae90:	1600000c 	bnez	s0,8000aec4 <PCIE_PowerDown+0x160>
8000ae94:	3c020001 	lui	v0,0x1

		#if 0 //saving more power, leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
8000ae98:	34420044 	ori	v0,v0,0x44
8000ae9c:	02221021 	addu	v0,s1,v0
8000aea0:	8c440000 	lw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (0);  //D0	
8000aea4:	2403fffc 	li	v1,-4
8000aea8:	00831824 	and	v1,a0,v1
8000aeac:	ac430000 	sw	v1,0(v0)
		dprintf("D0 \n");
8000aeb0:	3c048001 	lui	a0,0x8001
8000aeb4:	0c001cc1 	jal	80007304 <dprintf>
8000aeb8:	248419f4 	addiu	a0,a0,6644
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
8000aebc:	08002bcf 	j	8000af3c <PCIE_PowerDown+0x1d8>
8000aec0:	24020007 	li	v0,7
		dprintf("D0 \n");
	
	}

	
	if(mode==3)
8000aec4:	24020003 	li	v0,3
8000aec8:	16020010 	bne	s0,v0,8000af0c <PCIE_PowerDown+0x1a8>
8000aecc:	3c020001 	lui	v0,0x1
	{

		#if 1 //saving more power
		REG32(baseaddr+DEVICE_OFFSET+0x80)|= (0x100);  //enable clock PM
8000aed0:	34430080 	ori	v1,v0,0x80
8000aed4:	02231821 	addu	v1,s1,v1
8000aed8:	8c640000 	lw	a0,0(v1)
8000aedc:	34840100 	ori	a0,a0,0x100
8000aee0:	ac640000 	sw	a0,0(v1)
		#endif
		
		tmp = REG32(baseaddr+DEVICE_OFFSET+0x44) &( ~(3));  //D0
8000aee4:	34420044 	ori	v0,v0,0x44
8000aee8:	02221021 	addu	v0,s1,v0
8000aeec:	8c430000 	lw	v1,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x44) = tmp|  (3);  //D3	
8000aef0:	34630003 	ori	v1,v1,0x3
8000aef4:	ac430000 	sw	v1,0(v0)
		//HostPCIe_SetPhyMdioWrite(0xd, 0x15a6);
		dprintf("D3 hot \n");		
8000aef8:	3c048001 	lui	a0,0x8001
8000aefc:	0c001cc1 	jal	80007304 <dprintf>
8000af00:	248419fc 	addiu	a0,a0,6652

	}



	if(mode==8)
8000af04:	08002bef 	j	8000afbc <PCIE_PowerDown+0x258>
8000af08:	24020008 	li	v0,8
		#if 0 //saving more power		
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0708);
		#endif
	}

	if(mode==4)
8000af0c:	24020004 	li	v0,4
8000af10:	16020009 	bne	s0,v0,8000af38 <PCIE_PowerDown+0x1d4>
8000af14:	26221008 	addiu	v0,s1,4104
	{	
		#if 0 //saving more power   leave L1 write
		HostPCIe_SetPhyMdioWrite(portnum, 0xf, 0x0f0f);
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
8000af18:	8c430000 	lw	v1,0(v0)
8000af1c:	34630200 	ori	v1,v1,0x200
8000af20:	ac430000 	sw	v1,0(v0)
		dprintf("Host boardcase PME_TurnOff \n");		
8000af24:	3c048001 	lui	a0,0x8001
8000af28:	0c001cc1 	jal	80007304 <dprintf>
8000af2c:	24841a08 	addiu	a0,a0,6664
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
8000af30:	08002c0f 	j	8000b03c <PCIE_PowerDown+0x2d8>
8000af34:	24020009 	li	v0,9
		#endif	
	
		REG32(baseaddr+0x1008) |= (0x200);  		
		dprintf("Host boardcase PME_TurnOff \n");		
	}
	if(mode==7)
8000af38:	24020007 	li	v0,7
8000af3c:	1602001e 	bne	s0,v0,8000afb8 <PCIE_PowerDown+0x254>
8000af40:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
8000af44:	3443070c 	ori	v1,v0,0x70c
8000af48:	02231821 	addu	v1,s1,v1
8000af4c:	8c650000 	lw	a1,0(v1)
8000af50:	3c04c0ff 	lui	a0,0xc0ff
8000af54:	3484ffff 	ori	a0,a0,0xffff
8000af58:	00a42024 	and	a0,a1,a0
8000af5c:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((3)<<27) | ((1)<<24);   //L1=3us, L0s=1us
8000af60:	8c650000 	lw	a1,0(v1)
8000af64:	3c041900 	lui	a0,0x1900
8000af68:	00a42025 	or	a0,a1,a0
8000af6c:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
8000af70:	26230080 	addiu	v1,s1,128
8000af74:	8c650000 	lw	a1,0(v1)
8000af78:	2404fffc 	li	a0,-4
8000af7c:	00a42824 	and	a1,a1,a0
8000af80:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
8000af84:	34420080 	ori	v0,v0,0x80
8000af88:	02221021 	addu	v0,s1,v0
8000af8c:	8c450000 	lw	a1,0(v0)
8000af90:	00a42024 	and	a0,a1,a0
8000af94:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 1;   //L0s
8000af98:	8c640000 	lw	a0,0(v1)
8000af9c:	34840001 	ori	a0,a0,0x1
8000afa0:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 1;				
8000afa4:	8c430000 	lw	v1,0(v0)
8000afa8:	34630001 	ori	v1,v1,0x1
8000afac:	ac430000 	sw	v1,0(v0)
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
8000afb0:	08002c1e 	j	8000b078 <PCIE_PowerDown+0x314>
8000afb4:	24020010 	li	v0,16

	}



	if(mode==8)
8000afb8:	24020008 	li	v0,8
8000afbc:	1602001e 	bne	s0,v0,8000b038 <PCIE_PowerDown+0x2d4>
8000afc0:	3c020001 	lui	v0,0x1
	{
		REG32(baseaddr+DEVICE_OFFSET+0x070c) &= ~  ((0x7 <<27)|(0x7<<24));
8000afc4:	3443070c 	ori	v1,v0,0x70c
8000afc8:	02231821 	addu	v1,s1,v1
8000afcc:	8c650000 	lw	a1,0(v1)
8000afd0:	3c04c0ff 	lui	a0,0xc0ff
8000afd4:	3484ffff 	ori	a0,a0,0xffff
8000afd8:	00a42024 	and	a0,a1,a0
8000afdc:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x070c) |=  ((1)<<27) | ((3)<<24);   //L1=1us, L0s=3us
8000afe0:	8c650000 	lw	a1,0(v1)
8000afe4:	3c040b00 	lui	a0,0xb00
8000afe8:	00a42025 	or	a0,a1,a0
8000afec:	ac640000 	sw	a0,0(v1)

		REG32(baseaddr+0x80) &= ~(0x3);
8000aff0:	26230080 	addiu	v1,s1,128
8000aff4:	8c650000 	lw	a1,0(v1)
8000aff8:	2404fffc 	li	a0,-4
8000affc:	00a42824 	and	a1,a1,a0
8000b000:	ac650000 	sw	a1,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);		
8000b004:	34420080 	ori	v0,v0,0x80
8000b008:	02221021 	addu	v0,s1,v0
8000b00c:	8c450000 	lw	a1,0(v0)
8000b010:	00a42024 	and	a0,a1,a0
8000b014:	ac440000 	sw	a0,0(v0)

		REG32(baseaddr+0x80) |= 3;   //L1
8000b018:	8c640000 	lw	a0,0(v1)
8000b01c:	34840003 	ori	a0,a0,0x3
8000b020:	ac640000 	sw	a0,0(v1)
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			
8000b024:	8c430000 	lw	v1,0(v0)
8000b028:	34630003 	ori	v1,v1,0x3
8000b02c:	ac430000 	sw	v1,0(v0)
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
8000b030:	08002c37 	j	8000b0dc <PCIE_PowerDown+0x378>
8000b034:	24020020 	li	v0,32
		REG32(baseaddr+0x80) |= 3;   //L1
		REG32(baseaddr+DEVICE_OFFSET+0x80) |= 3;	//L1			

	}

	if(mode==9)
8000b038:	24020009 	li	v0,9
8000b03c:	1602000d 	bne	s0,v0,8000b074 <PCIE_PowerDown+0x310>
8000b040:	26220080 	addiu	v0,s1,128
	{
		REG32(baseaddr+0x80) &= ~(0x3);
8000b044:	8c440000 	lw	a0,0(v0)
8000b048:	2403fffc 	li	v1,-4
8000b04c:	00832024 	and	a0,a0,v1
8000b050:	ac440000 	sw	a0,0(v0)
		REG32(baseaddr+DEVICE_OFFSET+0x80) &= ~(0x3);
8000b054:	3c020001 	lui	v0,0x1
8000b058:	34420080 	ori	v0,v0,0x80
8000b05c:	02221021 	addu	v0,s1,v0
8000b060:	8c440000 	lw	a0,0(v0)
8000b064:	00831824 	and	v1,a0,v1
8000b068:	ac430000 	sw	v1,0(v0)





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000b06c:	08002c67 	j	8000b19c <PCIE_PowerDown+0x438>
8000b070:	26310728 	addiu	s1,s1,1832
		dprintf("status=%x \n", REG32(0xb8b00728) );		
	}
#endif

       //-------------------------------------------------------------	
	if(mode==0x010)
8000b074:	24020010 	li	v0,16
8000b078:	16020018 	bne	s0,v0,8000b0dc <PCIE_PowerDown+0x378>
8000b07c:	24020020 	li	v0,32
	{
             //L0->L1->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
8000b080:	3c10b8b1 	lui	s0,0xb8b1
8000b084:	36100044 	ori	s0,s0,0x44
8000b088:	8e130000 	lw	s3,0(s0)
8000b08c:	2402fffc 	li	v0,-4
8000b090:	02629824 	and	s3,s3,v0
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
			break;
		}	
	
       */
		REG32(0xb8b10044) = tmp|  (3);  //D3	
8000b094:	36620003 	ori	v0,s3,0x3
8000b098:	ae020000 	sw	v0,0(s0)
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x14)   //wait to L1
			break;
		}	
		*/
		delay_ms(100);
8000b09c:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b0a0:	24040064 	li	a0,100
		//REG32(0xb8b10000);
		REG32(0xb8b10044) = tmp|  (0);  //D0, wakeup
8000b0a4:	ae130000 	sw	s3,0(s0)
		
		while(1)
		{	if((REG32(0xb8b00728)&0x1f)==0x11)   //wait to L0
8000b0a8:	3c04b8b0 	lui	a0,0xb8b0
8000b0ac:	34840728 	ori	a0,a0,0x728
8000b0b0:	24030011 	li	v1,17
8000b0b4:	8c820000 	lw	v0,0(a0)
8000b0b8:	3042001f 	andi	v0,v0,0x1f
8000b0bc:	1443fffd 	bne	v0,v1,8000b0b4 <PCIE_PowerDown+0x350>
8000b0c0:	3c02b8b1 	lui	v0,0xb8b1
			break;
		}	
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
8000b0c4:	8c450000 	lw	a1,0(v0)
8000b0c8:	3c048001 	lui	a0,0x8001
8000b0cc:	0c001cc1 	jal	80007304 <dprintf>
8000b0d0:	24841a28 	addiu	a0,a0,6696





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000b0d4:	08002c67 	j	8000b19c <PCIE_PowerDown+0x438>
8000b0d8:	26310728 	addiu	s1,s1,1832
		
		//delay_ms(100);
		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
	}
	//-------------------------------------------------------------	
	if(mode==0x020)
8000b0dc:	1602002e 	bne	s0,v0,8000b198 <PCIE_PowerDown+0x434>
8000b0e0:	00000000 	nop
	{
             //L0->L2->L0
		tmp = REG32(0xb8b10044) &( ~(3));  //D0
8000b0e4:	3c02b8b1 	lui	v0,0xb8b1
8000b0e8:	34420044 	ori	v0,v0,0x44
8000b0ec:	8c430000 	lw	v1,0(v0)

		REG32(0xb8b10044) = tmp|  (3);  //D3	
8000b0f0:	34630003 	ori	v1,v1,0x3
8000b0f4:	ac430000 	sw	v1,0(v0)
		delay_ms(100);
8000b0f8:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b0fc:	24040064 	li	a0,100

		REG32(0xb8b01008) |= (0x200);  
8000b100:	3c14b8b0 	lui	s4,0xb8b0
8000b104:	36941008 	ori	s4,s4,0x1008
8000b108:	8e820000 	lw	v0,0(s4)
8000b10c:	34420200 	ori	v0,v0,0x200
8000b110:	ae820000 	sw	v0,0(s4)
        __delay(100000);  		
8000b114:	3c100001 	lui	s0,0x1
8000b118:	0c00324c 	jal	8000c930 <__delay>
8000b11c:	360486a0 	ori	a0,s0,0x86a0
		//dprintf("Host boardcase PME_TurnOff \n");	
		//delay_ms(100);

	//wakeup
     REG32(SYS_CLKMANAGE) &= ~(1<<12);    //perst=0 off.
8000b120:	3c13b800 	lui	s3,0xb800
8000b124:	36730010 	ori	s3,s3,0x10
8000b128:	8e630000 	lw	v1,0(s3)
8000b12c:	2402efff 	li	v0,-4097
8000b130:	00621024 	and	v0,v1,v0
8000b134:	ae620000 	sw	v0,0(s3)
            //dprintf("CLK_MANAGE=%x \n",  REG32(CLK_MANAGE));
        __delay(100000);   
8000b138:	0c00324c 	jal	8000c930 <__delay>
8000b13c:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000b140:	0c00324c 	jal	8000c930 <__delay>
8000b144:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000b148:	0c00324c 	jal	8000c930 <__delay>
8000b14c:	360486a0 	ori	a0,s0,0x86a0
		
    REG32(SYS_CLKMANAGE) |=  (1<<12);   //PERST=1
8000b150:	8e620000 	lw	v0,0(s3)
8000b154:	34421000 	ori	v0,v0,0x1000
8000b158:	ae620000 	sw	v0,0(s3)
    //prom_printf("\nCLK_MANAGE(0x%x)=0x%x\n\n",CLK_MANAGE,READ_MEM32(CLK_MANAGE));

	
        //4. PCIE PHY Reset       
    REG32(PCIE_PHY0) = 0x01;	//bit7 PHY reset=0   bit0 Enable LTSSM=1
8000b15c:	24020001 	li	v0,1
8000b160:	ae820000 	sw	v0,0(s4)
    REG32(PCIE_PHY0) = 0x81;   //bit7 PHY reset=1   bit0 Enable LTSSM=1
8000b164:	24020081 	li	v0,129
8000b168:	ae820000 	sw	v0,0(s4)
	}
#else

	while(1)
	{
		if( (REG32(0xb8b00728)&0x1f)==0x11)
8000b16c:	3c04b8b0 	lui	a0,0xb8b0
8000b170:	34840728 	ori	a0,a0,0x728
8000b174:	24030011 	li	v1,17
8000b178:	8c820000 	lw	v0,0(a0)
8000b17c:	3042001f 	andi	v0,v0,0x1f
8000b180:	1443fffd 	bne	v0,v1,8000b178 <PCIE_PowerDown+0x414>
8000b184:	3c02b8b1 	lui	v0,0xb8b1
	}
#endif



		dprintf("DID/VID=%x\n", REG32(0xb8b10000));
8000b188:	8c450000 	lw	a1,0(v0)
8000b18c:	3c048001 	lui	a0,0x8001
8000b190:	0c001cc1 	jal	80007304 <dprintf>
8000b194:	24841a28 	addiu	a0,a0,6696





		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
8000b198:	26310728 	addiu	s1,s1,1832
8000b19c:	8e260000 	lw	a2,0(s1)
8000b1a0:	3c048001 	lui	a0,0x8001
8000b1a4:	24841a34 	addiu	a0,a0,6708
8000b1a8:	02402821 	move	a1,s2
8000b1ac:	0c001cc1 	jal	80007304 <dprintf>
8000b1b0:	30c6001f 	andi	a2,a2,0x1f
		
};
8000b1b4:	08002c7a 	j	8000b1e8 <PCIE_PowerDown+0x484>
8000b1b8:	8fbf0024 	lw	ra,36(sp)
8000b1bc:	08002c7a 	j	8000b1e8 <PCIE_PowerDown+0x484>
8000b1c0:	8fbf0024 	lw	ra,36(sp)
		dprintf("P0 Link status=%x \n", REG32(0xb8b00728)&0x1f );		
		dprintf("P1 Link status=%x \n", REG32(0xb8b20728)&0x1f );		
		return 0;
	}
	if(argc>=1)	portnum = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	if(argc>=2)   mode = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000b1c4:	8ca40004 	lw	a0,4(a1)
8000b1c8:	00002821 	move	a1,zero
8000b1cc:	0c001a60 	jal	80006980 <strtoul>
8000b1d0:	24060010 	li	a2,16
8000b1d4:	00408021 	move	s0,v0
8000b1d8:	00009021 	move	s2,zero
8000b1dc:	08002ba4 	j	8000ae90 <PCIE_PowerDown+0x12c>
8000b1e0:	3c11b8b0 	lui	s1,0xb8b0



		dprintf("Port%d Link status=%x \n", portnum, REG32(baseaddr+0x728)&0x1f );			
		
};
8000b1e4:	8fbf0024 	lw	ra,36(sp)
8000b1e8:	8fb40020 	lw	s4,32(sp)
8000b1ec:	8fb3001c 	lw	s3,28(sp)
8000b1f0:	8fb20018 	lw	s2,24(sp)
8000b1f4:	8fb10014 	lw	s1,20(sp)
8000b1f8:	8fb00010 	lw	s0,16(sp)
8000b1fc:	03e00008 	jr	ra
8000b200:	27bd0028 	addiu	sp,sp,40

8000b204 <PCIE_Device_PERST>:

//===========================================================

//------------------------------------------------------------------------
void PCIE_Device_PERST(void)
{
8000b204:	27bdffe0 	addiu	sp,sp,-32
8000b208:	afbf001c 	sw	ra,28(sp)
8000b20c:	afb10018 	sw	s1,24(sp)
8000b210:	afb00014 	sw	s0,20(sp)
	 #define CLK_MANAGE 	0xb8000010
        // 6. PCIE Device Reset       
     REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.    
8000b214:	3c11b800 	lui	s1,0xb800
8000b218:	36310010 	ori	s1,s1,0x10
8000b21c:	8e230000 	lw	v1,0(s1)
8000b220:	3c02fbff 	lui	v0,0xfbff
8000b224:	3442ffff 	ori	v0,v0,0xffff
8000b228:	00621024 	and	v0,v1,v0
8000b22c:	ae220000 	sw	v0,0(s1)
        __delay(100000);   //PCIE standadrd: poweron: 100us, after poweron: 100ms
8000b230:	3c100001 	lui	s0,0x1
8000b234:	0c00324c 	jal	8000c930 <__delay>
8000b238:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   
8000b23c:	0c00324c 	jal	8000c930 <__delay>
8000b240:	360486a0 	ori	a0,s0,0x86a0
        __delay(100000);   		
8000b244:	0c00324c 	jal	8000c930 <__delay>
8000b248:	360486a0 	ori	a0,s0,0x86a0
    REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1
8000b24c:	8e230000 	lw	v1,0(s1)
8000b250:	3c020400 	lui	v0,0x400
8000b254:	00621025 	or	v0,v1,v0
8000b258:	ae220000 	sw	v0,0(s1)

}
8000b25c:	8fbf001c 	lw	ra,28(sp)
8000b260:	8fb10018 	lw	s1,24(sp)
8000b264:	8fb00014 	lw	s0,20(sp)
8000b268:	03e00008 	jr	ra
8000b26c:	27bd0020 	addiu	sp,sp,32

8000b270 <Test_HostPCIE_DataLoopback>:
}


//------------------------------------------------------------------------
int Test_HostPCIE_DataLoopback(int argc, char* argv[])
{
8000b270:	27bdffd0 	addiu	sp,sp,-48
8000b274:	afbf002c 	sw	ra,44(sp)
8000b278:	afb50028 	sw	s5,40(sp)
8000b27c:	afb40024 	sw	s4,36(sp)
8000b280:	afb30020 	sw	s3,32(sp)
8000b284:	afb2001c 	sw	s2,28(sp)
8000b288:	afb10018 	sw	s1,24(sp)
8000b28c:	afb00014 	sw	s0,20(sp)
8000b290:	00808821 	move	s1,a0
8000b294:	00a09021 	move	s2,a1

//    PCIE_reset_procedure(0,0,1);
	unsigned int portnum=0;
	unsigned int test_packet_num=1;
	
	if(argc >= 1) 
8000b298:	18800006 	blez	a0,8000b2b4 <Test_HostPCIE_DataLoopback+0x44>
8000b29c:	00008021 	move	s0,zero
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000b2a0:	8ca40000 	lw	a0,0(a1)
8000b2a4:	00002821 	move	a1,zero
8000b2a8:	0c001a60 	jal	80006980 <strtoul>
8000b2ac:	24060010 	li	a2,16
8000b2b0:	00408021 	move	s0,v0
	}

	if(argc >= 2) 
8000b2b4:	2a220002 	slti	v0,s1,2
8000b2b8:	14400007 	bnez	v0,8000b2d8 <Test_HostPCIE_DataLoopback+0x68>
8000b2bc:	24110001 	li	s1,1
	{	test_packet_num= strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000b2c0:	8e440004 	lw	a0,4(s2)
8000b2c4:	00002821 	move	a1,zero
8000b2c8:	0c001a60 	jal	80006980 <strtoul>
8000b2cc:	24060010 	li	a2,16
    unsigned int cnt;

    unsigned int PCIE_Test_cnt;
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
8000b2d0:	10400006 	beqz	v0,8000b2ec <Test_HostPCIE_DataLoopback+0x7c>
8000b2d4:	00408821 	move	s1,v0
8000b2d8:	00009021 	move	s2,zero
8000b2dc:	24130001 	li	s3,1
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
8000b2e0:	3c158001 	lui	s5,0x8001

	{		at2_errcnt++;
8000b2e4:	08002ccf 	j	8000b33c <Test_HostPCIE_DataLoopback+0xcc>
8000b2e8:	3c148001 	lui	s4,0x8001
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000b2ec:	3c118001 	lui	s1,0x8001
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
8000b2f0:	3c128001 	lui	s2,0x8001
8000b2f4:	26521a4c 	addiu	s2,s2,6732
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000b2f8:	02002021 	move	a0,s0
8000b2fc:	0c00200d 	jal	80008034 <example>
8000b300:	8e254144 	lw	a1,16708(s1)
8000b304:	1440fffc 	bnez	v0,8000b2f8 <Test_HostPCIE_DataLoopback+0x88>
8000b308:	00000000 	nop
       	 {
				//printf("FAIL, and hang!\n");
				printf("FAIL!\n");
8000b30c:	0c001cc1 	jal	80007304 <dprintf>
8000b310:	02402021 	move	a0,s2
	unsigned int pcie_err=0;
	
	if(test_packet_num==0)
	{
		while(1)
       	 if(example(portnum, at2_mode)==0)   //0: mean fail
8000b314:	08002cbf 	j	8000b2fc <Test_HostPCIE_DataLoopback+0x8c>
8000b318:	02002021 	move	a0,s0
#if DBG
        prom_printf("\n==================(Start)======================\n");
        prom_printf("\nPCIE_Test_cnt:%d\n",PCIE_Test_cnt);
#endif        

        if(example(portnum, at2_mode)==0)   //0: mean fail
8000b31c:	0c00200d 	jal	80008034 <example>
8000b320:	8ea54144 	lw	a1,16708(s5)
8000b324:	14400004 	bnez	v0,8000b338 <Test_HostPCIE_DataLoopback+0xc8>
8000b328:	8e824140 	lw	v0,16704(s4)

	{		at2_errcnt++;
8000b32c:	24420001 	addiu	v0,v0,1
8000b330:	ae824140 	sw	v0,16704(s4)
		pcie_err++;
8000b334:	26520001 	addiu	s2,s2,1
				printf("FAIL!\n");
				//while(1)  {};
		 }
	}
	
    for (PCIE_Test_cnt=1; PCIE_Test_cnt<=test_packet_num; PCIE_Test_cnt++)
8000b338:	26730001 	addiu	s3,s3,1
8000b33c:	0233102b 	sltu	v0,s1,s3
8000b340:	1040fff6 	beqz	v0,8000b31c <Test_HostPCIE_DataLoopback+0xac>
8000b344:	02002021 	move	a0,s0
			return;
	}
#endif
		
    }
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
8000b348:	3c048001 	lui	a0,0x8001
8000b34c:	24841a54 	addiu	a0,a0,6740
8000b350:	02202821 	move	a1,s1
8000b354:	0c001cc1 	jal	80007304 <dprintf>
8000b358:	02403021 	move	a2,s2
	
}; 
8000b35c:	8fbf002c 	lw	ra,44(sp)
8000b360:	8fb50028 	lw	s5,40(sp)
8000b364:	8fb40024 	lw	s4,36(sp)
8000b368:	8fb30020 	lw	s3,32(sp)
8000b36c:	8fb2001c 	lw	s2,28(sp)
8000b370:	8fb10018 	lw	s1,24(sp)
8000b374:	8fb00014 	lw	s0,20(sp)
8000b378:	03e00008 	jr	ra
8000b37c:	27bd0030 	addiu	sp,sp,48

8000b380 <PCIE_Check_Link>:
	REG32(pcie_phy) = 0x81;   //bit7: PHY reset=1   bit0: Enable LTSSM=1
	
}
//------------------------------------------------------------------------
int PCIE_Check_Link(unsigned int portnum)
{
8000b380:	27bdffd0 	addiu	sp,sp,-48
8000b384:	afbf002c 	sw	ra,44(sp)
8000b388:	afb30028 	sw	s3,40(sp)
8000b38c:	afb20024 	sw	s2,36(sp)
8000b390:	afb10020 	sw	s1,32(sp)
8000b394:	afb0001c 	sw	s0,28(sp)
	unsigned int dbgaddr;
	unsigned int cfgaddr;
	
	if(portnum==0)	dbgaddr=0xb8b00728;
8000b398:	14800004 	bnez	a0,8000b3ac <PCIE_Check_Link+0x2c>
8000b39c:	00808021 	move	s0,a0
8000b3a0:	3c11b8b0 	lui	s1,0xb8b0
8000b3a4:	08002cf5 	j	8000b3d4 <PCIE_Check_Link+0x54>
8000b3a8:	36310728 	ori	s1,s1,0x728
	else if(portnum==1)	dbgaddr=0xb8b20728;
8000b3ac:	24020001 	li	v0,1
8000b3b0:	14820004 	bne	a0,v0,8000b3c4 <PCIE_Check_Link+0x44>
8000b3b4:	24020002 	li	v0,2
8000b3b8:	3c11b8b2 	lui	s1,0xb8b2
8000b3bc:	08002cf5 	j	8000b3d4 <PCIE_Check_Link+0x54>
8000b3c0:	36310728 	ori	s1,s1,0x728
	else if(portnum==2)	dbgaddr=0xb8b40728;	
8000b3c4:	14820033 	bne	a0,v0,8000b494 <PCIE_Check_Link+0x114>
8000b3c8:	8fbf002c 	lw	ra,44(sp)
8000b3cc:	3c11b8b4 	lui	s1,0xb8b4
8000b3d0:	36310728 	ori	s1,s1,0x728
	else return;	

  //wait for LinkUP
      delay_ms(10);
8000b3d4:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b3d8:	2404000a 	li	a0,10
	volatile int i=5;
8000b3dc:	24020005 	li	v0,5
8000b3e0:	afa20010 	sw	v0,16(sp)
	while(--i)
8000b3e4:	08002d01 	j	8000b404 <PCIE_Check_Link+0x84>
8000b3e8:	24120011 	li	s2,17
	{
		 delay_ms(10);	  
8000b3ec:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b3f0:	2404000a 	li	a0,10
	      if( (REG32(dbgaddr)&0x1f)==0x11)
8000b3f4:	8e220000 	lw	v0,0(s1)
8000b3f8:	3042001f 	andi	v0,v0,0x1f
8000b3fc:	10520007 	beq	v0,s2,8000b41c <PCIE_Check_Link+0x9c>
8000b400:	00000000 	nop
	else return;	

  //wait for LinkUP
      delay_ms(10);
	volatile int i=5;
	while(--i)
8000b404:	8fa20010 	lw	v0,16(sp)
8000b408:	2442ffff 	addiu	v0,v0,-1
8000b40c:	afa20010 	sw	v0,16(sp)
8000b410:	8fa20010 	lw	v0,16(sp)
8000b414:	1440fff5 	bnez	v0,8000b3ec <PCIE_Check_Link+0x6c>
8000b418:	00000000 	nop
		 delay_ms(10);	  
	      if( (REG32(dbgaddr)&0x1f)==0x11)
		  	break;

	}
	if(i==0)
8000b41c:	8fa20010 	lw	v0,16(sp)
8000b420:	14400006 	bnez	v0,8000b43c <PCIE_Check_Link+0xbc>
8000b424:	3c048001 	lui	a0,0x8001
	{	//if(at2_mode==0)  //not auto test, show message
		prom_printf("PCIE_P%d ->  Cannot LinkUP\n",portnum);
8000b428:	24841a7c 	addiu	a0,a0,6780
8000b42c:	0c001d43 	jal	8000750c <prom_printf>
8000b430:	02002821 	move	a1,s0
		return 0;
8000b434:	08002d24 	j	8000b490 <PCIE_Check_Link+0x110>
8000b438:	00001021 	move	v0,zero
	}
	else  //already  linkup
	{
		if(portnum==0)	      REG32(PCIE0_RC_CFG_BASE + 0x04)= 0x00100007;
8000b43c:	16000007 	bnez	s0,8000b45c <PCIE_Check_Link+0xdc>
8000b440:	3c030010 	lui	v1,0x10
8000b444:	34630007 	ori	v1,v1,0x7
8000b448:	3c02b8b0 	lui	v0,0xb8b0
8000b44c:	34420004 	ori	v0,v0,0x4
8000b450:	ac430000 	sw	v1,0(v0)
8000b454:	08002d1e 	j	8000b478 <PCIE_Check_Link+0xf8>
8000b458:	3c13b8b1 	lui	s3,0xb8b1
		else if(portnum==1) REG32(PCIE1_RC_CFG_BASE + 0x04)= 0x00100007;
8000b45c:	24020001 	li	v0,1
8000b460:	16020005 	bne	s0,v0,8000b478 <PCIE_Check_Link+0xf8>
8000b464:	34630007 	ori	v1,v1,0x7
8000b468:	3c02b8b2 	lui	v0,0xb8b2
8000b46c:	34420004 	ori	v0,v0,0x4
8000b470:	ac430000 	sw	v1,0(v0)
8000b474:	3c13b8b3 	lui	s3,0xb8b3
		  
		if(portnum==0) cfgaddr=0xb8b10000;
		else if(portnum==1) cfgaddr=0xb8b30000;

		//if(at2_mode==0)
		dprintf("Find Port=%x Device:Vender ID=%x\n", portnum, REG32(cfgaddr) );
8000b478:	8e660000 	lw	a2,0(s3)
8000b47c:	3c048001 	lui	a0,0x8001
8000b480:	24841a98 	addiu	a0,a0,6808
8000b484:	0c001cc1 	jal	80007304 <dprintf>
8000b488:	02002821 	move	a1,s0
8000b48c:	24020001 	li	v0,1
	}
	return 1;
}
8000b490:	8fbf002c 	lw	ra,44(sp)
8000b494:	8fb30028 	lw	s3,40(sp)
8000b498:	8fb20024 	lw	s2,36(sp)
8000b49c:	8fb10020 	lw	s1,32(sp)
8000b4a0:	8fb0001c 	lw	s0,28(sp)
8000b4a4:	03e00008 	jr	ra
8000b4a8:	27bd0030 	addiu	sp,sp,48

8000b4ac <PCIE_reset_procedure>:
//#else  //25MHz
//#define PHY_EAT_40MHZ 0
//#endif

void PCIE_reset_procedure(int portnum, int Use_External_PCIE_CLK, int mdio_reset)
{
8000b4ac:	27bdffe0 	addiu	sp,sp,-32
8000b4b0:	afbf001c 	sw	ra,28(sp)
8000b4b4:	afb10018 	sw	s1,24(sp)
8000b4b8:	afb00014 	sw	s0,20(sp)
8000b4bc:	00808021 	move	s0,a0
8000b4c0:	00c08821 	move	s1,a2
 	//dprintf("port=%x, mdio_rst=%x \n", portnum, mdio_reset);

	
 #if 1
	#define SYS_HW_STRAP   (0xb8000000 +0x08)
	unsigned int v=REG32(SYS_HW_STRAP);
8000b4c4:	3c03b800 	lui	v1,0xb800
8000b4c8:	34620008 	ori	v0,v1,0x8
8000b4cc:	8c420000 	lw	v0,0(v0)
	//unsigned char sel40m=GET_BITVAL(v, 25, RANG1);
	unsigned char sel40m=GET_BITVAL(v, 24, RANG1);
#endif

	//for RTL8198c pin_mux2 (0xb8000104) [21:20]=01
	REG32(0xb8000104)&=~(3<<20);
8000b4d0:	34620104 	ori	v0,v1,0x104
8000b4d4:	8c450000 	lw	a1,0(v0)
8000b4d8:	3c04ffcf 	lui	a0,0xffcf
8000b4dc:	3484ffff 	ori	a0,a0,0xffff
8000b4e0:	00a42024 	and	a0,a1,a0
8000b4e4:	ac440000 	sw	a0,0(v0)
	REG32(0xb8000104)|=(1<<20);
8000b4e8:	8c450000 	lw	a1,0(v0)
8000b4ec:	3c040010 	lui	a0,0x10
8000b4f0:	00a42025 	or	a0,a1,a0
8000b4f4:	ac440000 	sw	a0,0(v0)



 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
8000b4f8:	34630010 	ori	v1,v1,0x10
8000b4fc:	8c640000 	lw	a0,0(v1)
8000b500:	3c020004 	lui	v0,0x4
8000b504:	34423000 	ori	v0,v0,0x3000
8000b508:	00821025 	or	v0,a0,v0
8000b50c:	ac620000 	sw	v0,0(v1)
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
8000b510:	1600000d 	bnez	s0,8000b548 <PCIE_reset_procedure+0x9c>
8000b514:	24020001 	li	v0,1
8000b518:	00601021 	move	v0,v1
8000b51c:	8c630000 	lw	v1,0(v1)
8000b520:	34634000 	ori	v1,v1,0x4000
8000b524:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
8000b528:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b52c:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
8000b530:	24030008 	li	v1,8
8000b534:	3c02b8b0 	lui	v0,0xb8b0
8000b538:	3442100c 	ori	v0,v0,0x100c
8000b53c:	ac430000 	sw	v1,0(v0)
8000b540:	08002d60 	j	8000b580 <PCIE_reset_procedure+0xd4>
8000b544:	00000000 	nop
 	//first, Turn On PCIE IP
	 #define CLK_MANAGE 	0xb8000010
	REG32(CLK_MANAGE) |= (1<<12) | (1<<13) | (1<<18);
	 
	if(portnum==0)		    REG32(CLK_MANAGE) |=  (1<<14);        //enable active_pcie0
	else if(portnum==1)	    REG32(CLK_MANAGE) |=  (1<<16);        //enable active_pcie1	
8000b548:	16020069 	bne	s0,v0,8000b6f0 <PCIE_reset_procedure+0x244>
8000b54c:	8fbf001c 	lw	ra,28(sp)
8000b550:	3c02b800 	lui	v0,0xb800
8000b554:	34420010 	ori	v0,v0,0x10
8000b558:	8c440000 	lw	a0,0(v0)
8000b55c:	3c030001 	lui	v1,0x1
8000b560:	00831825 	or	v1,a0,v1
8000b564:	ac430000 	sw	v1,0(v0)
	else return;
		    

			
      // __delay(1000*1000*1);
       delay_ms(10);
8000b568:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b56c:	2404000a 	li	a0,10

        //add compatible, slove sata pcie card.
	if(portnum==0)	  REG32(0xb8b0100c)=(1<<3);  //set target Device Num=1;
	if(portnum==1)	  REG32(0xb8b2100c)=(2<<3);  //set target Device Num=1;
8000b570:	24030010 	li	v1,16
8000b574:	3c02b8b2 	lui	v0,0xb8b2
8000b578:	3442100c 	ori	v0,v0,0x100c
8000b57c:	ac430000 	sw	v1,0(v0)

 	//REG32(SYS_PCIE_ANA)=0x3f39;   //PCIE_ANA  bokai tell me to do this.

	if(mdio_reset)
8000b580:	12200019 	beqz	s1,8000b5e8 <PCIE_reset_procedure+0x13c>
8000b584:	3c028001 	lui	v0,0x8001
	{
		if(at2_mode==0)  //no auto test, show message
8000b588:	8c424144 	lw	v0,16708(v0)
8000b58c:	14400003 	bnez	v0,8000b59c <PCIE_reset_procedure+0xf0>
8000b590:	3c048001 	lui	a0,0x8001
			dprintf("Do MDIO_RESET\n");
8000b594:	0c001cc1 	jal	80007304 <dprintf>
8000b598:	24841abc 	addiu	a0,a0,6844
		
		 delay_ms(10);
8000b59c:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b5a0:	2404000a 	li	a0,10
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
8000b5a4:	02008821 	move	s1,s0
8000b5a8:	0c002970 	jal	8000a5c0 <PCIE_MDIO_Reset>
8000b5ac:	02002021 	move	a0,s0
	}  
	
	  delay_ms(10);
8000b5b0:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b5b4:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
8000b5b8:	0c002980 	jal	8000a600 <PCIE_PHY_Reset>
8000b5bc:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
8000b5c0:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b5c4:	2404000a 	li	a0,10
#endif
#if 1  //v6 FPGA 98C PCIE PHY 40MHZ
		{
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
8000b5c8:	3c02b800 	lui	v0,0xb800
8000b5cc:	34420008 	ori	v0,v0,0x8
8000b5d0:	8c420000 	lw	v0,0(v0)
		if(phy40M)
8000b5d4:	7c420600 	ext	v0,v0,0x18,0x1
8000b5d8:	1440000c 	bnez	v0,8000b60c <PCIE_reset_procedure+0x160>
8000b5dc:	00000000 	nop
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
8000b5e0:	08002d95 	j	8000b654 <PCIE_reset_procedure+0x1a8>
8000b5e4:	3c048001 	lui	a0,0x8001
		 delay_ms(10);
       	// 3.MDIO Reset
		PCIE_MDIO_Reset(portnum);
	}  
	
	  delay_ms(10);
8000b5e8:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b5ec:	2404000a 	li	a0,10
 	PCIE_PHY_Reset(portnum);	
8000b5f0:	02008821 	move	s1,s0
8000b5f4:	0c002980 	jal	8000a600 <PCIE_PHY_Reset>
8000b5f8:	02002021 	move	a0,s0
	
       // __delay(1000*1000);
        delay_ms(10);
8000b5fc:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b600:	2404000a 	li	a0,10
8000b604:	08002da8 	j	8000b6a0 <PCIE_reset_procedure+0x1f4>
8000b608:	00000000 	nop
		int phy40M=0;
		
		 phy40M=(REG32(0xb8000008)&(1<<24))>>24;
		if(phy40M)
		{
		dprintf("PCIE PHY=40MHZ,portnum=%d\n",portnum);
8000b60c:	3c048001 	lui	a0,0x8001
8000b610:	24841acc 	addiu	a0,a0,6860
8000b614:	0c001cc1 	jal	80007304 <dprintf>
8000b618:	02002821 	move	a1,s0
		HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x7b01);
8000b61c:	02002021 	move	a0,s0
8000b620:	24050003 	li	a1,3
8000b624:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b628:	24067b01 	li	a2,31489
		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0x0268);
8000b62c:	02002021 	move	a0,s0
8000b630:	24050006 	li	a1,6
8000b634:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b638:	24060268 	li	a2,616
		//f26c
		
		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70); 
8000b63c:	02002021 	move	a0,s0
8000b640:	24050019 	li	a1,25
8000b644:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b648:	3406fc70 	li	a2,0xfc70
8000b64c:	08002da8 	j	8000b6a0 <PCIE_reset_procedure+0x1f4>
8000b650:	00000000 	nop
		// HostPCIe_SetPhyMdioWrite(portnum, 0x13, 0x026c);
		}
		else
		{
			dprintf("PCIE PHY=25MHZ,portnum=%d\n",portnum);
8000b654:	24841ae8 	addiu	a0,a0,6888
8000b658:	0c001cc1 	jal	80007304 <dprintf>
8000b65c:	02002821 	move	a1,s0
			HostPCIe_SetPhyMdioWrite(portnum, 0x3, 0x3001);
8000b660:	02002021 	move	a0,s0
8000b664:	24050003 	li	a1,3
8000b668:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b66c:	24063001 	li	a2,12289
        		HostPCIe_SetPhyMdioWrite(portnum, 0x6, 0xe0b8); //Hannah
8000b670:	02002021 	move	a0,s0
8000b674:	24050006 	li	a1,6
8000b678:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b67c:	3406e0b8 	li	a2,0xe0b8

        		HostPCIe_SetPhyMdioWrite(portnum, 0xF, 0x400F);
8000b680:	02002021 	move	a0,s0
8000b684:	2405000f 	li	a1,15
8000b688:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b68c:	2406400f 	li	a2,16399
        		HostPCIe_SetPhyMdioWrite(portnum, 0x19, 0xFC70);	
8000b690:	02002021 	move	a0,s0
8000b694:	24050019 	li	a1,25
8000b698:	0c0029b1 	jal	8000a6c4 <HostPCIe_SetPhyMdioWrite>
8000b69c:	3406fc70 	li	a2,0xfc70
#endif
	  	}
 
	//---------------------------------------
         // 6. PCIE Device Reset
       delay_ms(10);
8000b6a0:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b6a4:	2404000a 	li	a0,10
	PCIE_PHY_Reset(portnum);
8000b6a8:	0c002980 	jal	8000a600 <PCIE_PHY_Reset>
8000b6ac:	02202021 	move	a0,s1
       REG32(CLK_MANAGE) &= ~(1<<26);    //perst=0 off.
8000b6b0:	3c10b800 	lui	s0,0xb800
8000b6b4:	36100010 	ori	s0,s0,0x10
8000b6b8:	8e030000 	lw	v1,0(s0)
8000b6bc:	3c02fbff 	lui	v0,0xfbff
8000b6c0:	3442ffff 	ori	v0,v0,0xffff
8000b6c4:	00621024 	and	v0,v1,v0
8000b6c8:	ae020000 	sw	v0,0(s0)
     	delay_ms(300);
8000b6cc:	0c001bb5 	jal	80006ed4 <delay_ms>
8000b6d0:	2404012c 	li	a0,300
       REG32(CLK_MANAGE) |=  (1<<26);   //PERST=1 
8000b6d4:	8e030000 	lw	v1,0(s0)
8000b6d8:	3c020400 	lui	v0,0x400
8000b6dc:	00621025 	or	v0,v1,v0
8000b6e0:	ae020000 	sw	v0,0(s0)
	//---------------------------------------	  
	PCIE_Check_Link(portnum);
8000b6e4:	0c002ce0 	jal	8000b380 <PCIE_Check_Link>
8000b6e8:	02202021 	move	a0,s1

}
8000b6ec:	8fbf001c 	lw	ra,28(sp)
8000b6f0:	8fb10018 	lw	s1,24(sp)
8000b6f4:	8fb00014 	lw	s0,20(sp)
8000b6f8:	03e00008 	jr	ra
8000b6fc:	27bd0020 	addiu	sp,sp,32

8000b700 <PCIE_Host_RESET>:
	printf("====> Total test cnt=%d, test fail=%d\n", test_packet_num,  pcie_err);
	
}; 
//------------------------------------------------------------------------
int PCIE_Host_RESET(int argc, char* argv[])
{
8000b700:	27bdffe0 	addiu	sp,sp,-32
8000b704:	afbf001c 	sw	ra,28(sp)
8000b708:	afb10018 	sw	s1,24(sp)
8000b70c:	afb00014 	sw	s0,20(sp)
	int  portnum= 0;  //0: one port, 1: two port
	int Use_External_PCIE_CLK=0;
	int mdio_reset=0;
	if(argc<2)
8000b710:	28820002 	slti	v0,a0,2
8000b714:	10400009 	beqz	v0,8000b73c <PCIE_Host_RESET+0x3c>
8000b718:	00a08021 	move	s0,a1
	{//dump all	
	       dprintf("\n"); 		   
8000b71c:	3c048001 	lui	a0,0x8001
8000b720:	0c001cc1 	jal	80007304 <dprintf>
8000b724:	24840f54 	addiu	a0,a0,3924
		dprintf("hrst <portnum> <mdio_reset>\n");
8000b728:	3c048001 	lui	a0,0x8001
8000b72c:	0c001cc1 	jal	80007304 <dprintf>
8000b730:	24841b04 	addiu	a0,a0,6916
		return;
8000b734:	08002dec 	j	8000b7b0 <PCIE_Host_RESET+0xb0>
8000b738:	8fbf001c 	lw	ra,28(sp)
	}
	
	if(argc >= 1) 
8000b73c:	18800020 	blez	a0,8000b7c0 <PCIE_Host_RESET+0xc0>
8000b740:	00000000 	nop
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000b744:	8ca40000 	lw	a0,0(a1)
8000b748:	00002821 	move	a1,zero
8000b74c:	0c001a60 	jal	80006980 <strtoul>
8000b750:	24060010 	li	a2,16
8000b754:	00408821 	move	s1,v0
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000b758:	8e040004 	lw	a0,4(s0)
8000b75c:	00002821 	move	a1,zero
8000b760:	0c001a60 	jal	80006980 <strtoul>
8000b764:	24060010 	li	a2,16
8000b768:	00408021 	move	s0,v0
	}

	if(portnum==2)
8000b76c:	24020002 	li	v0,2
8000b770:	1622000a 	bne	s1,v0,8000b79c <PCIE_Host_RESET+0x9c>
8000b774:	00002021 	move	a0,zero
	{
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
8000b778:	00002821 	move	a1,zero
8000b77c:	0c002d2b 	jal	8000b4ac <PCIE_reset_procedure>
8000b780:	02003021 	move	a2,s0
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
8000b784:	24040001 	li	a0,1
8000b788:	00002821 	move	a1,zero
8000b78c:	0c002d2b 	jal	8000b4ac <PCIE_reset_procedure>
8000b790:	02003021 	move	a2,s0
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);

}; 
8000b794:	08002dec 	j	8000b7b0 <PCIE_Host_RESET+0xb0>
8000b798:	8fbf001c 	lw	ra,28(sp)
		PCIE_reset_procedure(0, Use_External_PCIE_CLK, mdio_reset);
		PCIE_reset_procedure(1, Use_External_PCIE_CLK, mdio_reset);
		//PCIE_reset_procedure(portnum, 1, mdio_reset);		
	}		
	else
		PCIE_reset_procedure(portnum, Use_External_PCIE_CLK, mdio_reset);
8000b79c:	02202021 	move	a0,s1
8000b7a0:	00002821 	move	a1,zero
8000b7a4:	0c002d2b 	jal	8000b4ac <PCIE_reset_procedure>
8000b7a8:	02003021 	move	a2,s0

}; 
8000b7ac:	8fbf001c 	lw	ra,28(sp)
8000b7b0:	8fb10018 	lw	s1,24(sp)
8000b7b4:	8fb00014 	lw	s0,20(sp)
8000b7b8:	03e00008 	jr	ra
8000b7bc:	27bd0020 	addiu	sp,sp,32
	
	if(argc >= 1) 
	{	portnum= strtoul((const char*)(argv[0]), (char **)NULL, 16);	
	}
	if(argc >= 2) 
	{	mdio_reset= strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000b7c0:	8ca40004 	lw	a0,4(a1)
8000b7c4:	00002821 	move	a1,zero
8000b7c8:	0c001a60 	jal	80006980 <strtoul>
8000b7cc:	24060010 	li	a2,16
8000b7d0:	00408021 	move	s0,v0
8000b7d4:	08002de7 	j	8000b79c <PCIE_Host_RESET+0x9c>
8000b7d8:	00008821 	move	s1,zero

8000b7dc <CmdTestSRAM>:
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
{
8000b7dc:	27bdff98 	addiu	sp,sp,-104
8000b7e0:	afbf0064 	sw	ra,100(sp)
8000b7e4:	afbe0060 	sw	s8,96(sp)
8000b7e8:	afb7005c 	sw	s7,92(sp)
8000b7ec:	afb60058 	sw	s6,88(sp)
8000b7f0:	afb50054 	sw	s5,84(sp)
8000b7f4:	afb40050 	sw	s4,80(sp)
8000b7f8:	afb3004c 	sw	s3,76(sp)
8000b7fc:	afb20048 	sw	s2,72(sp)
8000b800:	afb10044 	sw	s1,68(sp)
8000b804:	afb00040 	sw	s0,64(sp)

	unsigned char *addr;
	unsigned int len=(1<<12);  //SRAM size=4K
	unsigned int i;
	
	if( argc < 1 ) 
8000b808:	1c800006 	bgtz	a0,8000b824 <CmdTestSRAM+0x48>
8000b80c:	00000000 	nop
	{
		dprintf("Usage: sram <map addr> \n");		
8000b810:	3c048001 	lui	a0,0x8001
8000b814:	0c001cc1 	jal	80007304 <dprintf>
8000b818:	24841b24 	addiu	a0,a0,6948
		return;	
8000b81c:	08002f25 	j	8000bc94 <CmdTestSRAM+0x4b8>
8000b820:	8fbf0064 	lw	ra,100(sp)
	}
	addr = strtoul((const char*)(argv[0]), (char **)NULL, 16);	
8000b824:	8ca40000 	lw	a0,0(a1)
8000b828:	00002821 	move	a1,zero
8000b82c:	0c001a60 	jal	80006980 <strtoul>
8000b830:	24060010 	li	a2,16

	unsigned char *paddr=VIR2PHY(addr);
8000b834:	3c031fff 	lui	v1,0x1fff
8000b838:	3463ffff 	ori	v1,v1,0xffff
8000b83c:	00431824 	and	v1,v0,v1
8000b840:	afa30038 	sw	v1,56(sp)
	unsigned char  *n8addr=VIR2NOC(addr);
8000b844:	3c13a000 	lui	s3,0xa000
8000b848:	00539825 	or	s3,v0,s3
8000b84c:	afb3002c 	sw	s3,44(sp)
	unsigned short *n16addr=VIR2NOC(addr);		
	unsigned int     *n32addr=VIR2NOC(addr);	
	
	//===============================================
	//stage 1: r/w
	memset(n8addr, 0xff, len);
8000b850:	02602021 	move	a0,s3
8000b854:	240500ff 	li	a1,255
8000b858:	0c0019d9 	jal	80006764 <memset>
8000b85c:	24061000 	li	a2,4096
#if 1
	Enable_SRAM(paddr);
8000b860:	0c00295c 	jal	8000a570 <Enable_SRAM>
8000b864:	8fa40038 	lw	a0,56(sp)
#endif
	//-----------------------------------------------------
	//test fix pattern
	unsigned int patt_array[]={ 0x00000000, 0x55555555, 0xaaaaaaaa, 0xffffffff, 0x1234567, 0xa5a55a5a  };
8000b868:	afa00010 	sw	zero,16(sp)
8000b86c:	3c025555 	lui	v0,0x5555
8000b870:	34425555 	ori	v0,v0,0x5555
8000b874:	afa20014 	sw	v0,20(sp)
8000b878:	3c02aaaa 	lui	v0,0xaaaa
8000b87c:	3442aaaa 	ori	v0,v0,0xaaaa
8000b880:	afa20018 	sw	v0,24(sp)
8000b884:	2402ffff 	li	v0,-1
8000b888:	afa2001c 	sw	v0,28(sp)
8000b88c:	3c020123 	lui	v0,0x123
8000b890:	34424567 	ori	v0,v0,0x4567
8000b894:	afa20020 	sw	v0,32(sp)
8000b898:	3c02a5a5 	lui	v0,0xa5a5
8000b89c:	34425a5a 	ori	v0,v0,0x5a5a
8000b8a0:	afa20024 	sw	v0,36(sp)
8000b8a4:	0000b821 	move	s7,zero
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b8a8:	27be0028 	addiu	s8,sp,40
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	
8000b8ac:	3c028001 	lui	v0,0x8001
8000b8b0:	24421b94 	addiu	v0,v0,7060
8000b8b4:	afa2003c 	sw	v0,60(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b8b8:	26711000 	addiu	s1,s3,4096
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	
8000b8bc:	3c028001 	lui	v0,0x8001
8000b8c0:	24421b78 	addiu	v0,v0,7032
8000b8c4:	afa20034 	sw	v0,52(sp)
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
8000b8c8:	3c028001 	lui	v0,0x8001
8000b8cc:	24421b40 	addiu	v0,v0,6976
8000b8d0:	afa20030 	sw	v0,48(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b8d4:	afb30028 	sw	s3,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
8000b8d8:	3c148001 	lui	s4,0x8001
8000b8dc:	08002e98 	j	8000ba60 <CmdTestSRAM+0x284>
8000b8e0:	26941b5c 	addiu	s4,s4,7004
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
8000b8e4:	16e0001a 	bnez	s7,8000b950 <CmdTestSRAM+0x174>
8000b8e8:	24020001 	li	v0,1
		{			
			unsigned char patt=patt_array[patt_idx];
8000b8ec:	92d20003 	lbu	s2,3(s6)
			printf("Test Patt %02x, byte w/r \n", patt);	
8000b8f0:	0240a821 	move	s5,s2
8000b8f4:	8fa40030 	lw	a0,48(sp)
8000b8f8:	0c001cc1 	jal	80007304 <dprintf>
8000b8fc:	02402821 	move	a1,s2
			memset(n8addr, patt, len);	
8000b900:	8fa4002c 	lw	a0,44(sp)
8000b904:	02402821 	move	a1,s2
8000b908:	0c0019d9 	jal	80006764 <memset>
8000b90c:	24061000 	li	a2,4096
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b910:	8fb00028 	lw	s0,40(sp)
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != patt)
8000b914:	92020000 	lbu	v0,0(s0)
8000b918:	304200ff 	andi	v0,v0,0xff
8000b91c:	10520007 	beq	v0,s2,8000b93c <CmdTestSRAM+0x160>
8000b920:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
8000b924:	92070000 	lbu	a3,0(s0)
8000b928:	02802021 	move	a0,s4
8000b92c:	02002821 	move	a1,s0
8000b930:	02a03021 	move	a2,s5
8000b934:	0c001cc1 	jal	80007304 <dprintf>
8000b938:	30e700ff 	andi	a3,a3,0xff
8000b93c:	26100001 	addiu	s0,s0,1
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			unsigned char patt=patt_array[patt_idx];
			printf("Test Patt %02x, byte w/r \n", patt);	
			memset(n8addr, patt, len);	
			for(i=0; i<len; i++)
8000b940:	1611fff4 	bne	s0,s1,8000b914 <CmdTestSRAM+0x138>
8000b944:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000b948:	08002e85 	j	8000ba14 <CmdTestSRAM+0x238>
8000b94c:	26d60004 	addiu	s6,s6,4
			{
				if(REG8(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000b950:	16e2001a 	bne	s7,v0,8000b9bc <CmdTestSRAM+0x1e0>
8000b954:	24020002 	li	v0,2
		{
			unsigned short patt=patt_array[patt_idx];
8000b958:	96d20002 	lhu	s2,2(s6)
			printf("Test Patt %04x, short w/r \n", patt);	
8000b95c:	0240a821 	move	s5,s2
8000b960:	8fa40034 	lw	a0,52(sp)
8000b964:	0c001cc1 	jal	80007304 <dprintf>
8000b968:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b96c:	8fa20028 	lw	v0,40(sp)
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
8000b970:	a4520000 	sh	s2,0(v0)
8000b974:	24420002 	addiu	v0,v0,2
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			unsigned short patt=patt_array[patt_idx];
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
8000b978:	1451fffd 	bne	v0,s1,8000b970 <CmdTestSRAM+0x194>
8000b97c:	8fb00028 	lw	s0,40(sp)
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
			{
				if(REG16(n8addr+i) != patt)
8000b980:	96020000 	lhu	v0,0(s0)
8000b984:	3042ffff 	andi	v0,v0,0xffff
8000b988:	10520007 	beq	v0,s2,8000b9a8 <CmdTestSRAM+0x1cc>
8000b98c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
8000b990:	96070000 	lhu	a3,0(s0)
8000b994:	02802021 	move	a0,s4
8000b998:	02002821 	move	a1,s0
8000b99c:	02a03021 	move	a2,s5
8000b9a0:	0c001cc1 	jal	80007304 <dprintf>
8000b9a4:	30e7ffff 	andi	a3,a3,0xffff
8000b9a8:	26100002 	addiu	s0,s0,2
			printf("Test Patt %04x, short w/r \n", patt);	

			for(i=0; i<len; i+=2)			
				REG16(n8addr+i)= patt;	
			
			for(i=0; i<len; i+=2)
8000b9ac:	1630fff4 	bne	s1,s0,8000b980 <CmdTestSRAM+0x1a4>
8000b9b0:	00000000 	nop
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000b9b4:	08002e85 	j	8000ba14 <CmdTestSRAM+0x238>
8000b9b8:	26d60004 	addiu	s6,s6,4
			{
				if(REG16(n8addr+i) != patt)
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG16(n8addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
8000b9bc:	16e20014 	bne	s7,v0,8000ba10 <CmdTestSRAM+0x234>
8000b9c0:	8fa4003c 	lw	a0,60(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
8000b9c4:	8ed20000 	lw	s2,0(s6)
			printf("Test Patt %08x, int w/r \n", patt);	
8000b9c8:	0c001cc1 	jal	80007304 <dprintf>
8000b9cc:	02402821 	move	a1,s2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000b9d0:	8fa20028 	lw	v0,40(sp)
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	
8000b9d4:	ac520000 	sw	s2,0(v0)
8000b9d8:	24420004 	addiu	v0,v0,4
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			unsigned int patt=patt_array[patt_idx];
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
8000b9dc:	1451fffd 	bne	v0,s1,8000b9d4 <CmdTestSRAM+0x1f8>
8000b9e0:	8fb00028 	lw	s0,40(sp)
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
			{
				if(REG32(n8addr+i) != patt)
8000b9e4:	8e020000 	lw	v0,0(s0)
8000b9e8:	10520006 	beq	v0,s2,8000ba04 <CmdTestSRAM+0x228>
8000b9ec:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, patt, REG32(n8addr+i));
8000b9f0:	8e070000 	lw	a3,0(s0)
8000b9f4:	02802021 	move	a0,s4
8000b9f8:	02002821 	move	a1,s0
8000b9fc:	0c001cc1 	jal	80007304 <dprintf>
8000ba00:	02403021 	move	a2,s2
8000ba04:	26100004 	addiu	s0,s0,4
			printf("Test Patt %08x, int w/r \n", patt);	

			for(i=0; i<len; i+=4)			
				REG32(n8addr+i)= patt;	

			for(i=0; i<len; i+=4)
8000ba08:	1630fff6 	bne	s1,s0,8000b9e4 <CmdTestSRAM+0x208>
8000ba0c:	00000000 	nop
8000ba10:	26d60004 	addiu	s6,s6,4
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
	
	for(patt_idx=0; patt_idx< sizeof(patt_array)/sizeof(patt_array[0]) ; patt_idx++)
8000ba14:	16deffb3 	bne	s6,s8,8000b8e4 <CmdTestSRAM+0x108>
8000ba18:	24020003 	li	v0,3
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000ba1c:	26f70001 	addiu	s7,s7,1
8000ba20:	16e2000f 	bne	s7,v0,8000ba60 <CmdTestSRAM+0x284>
8000ba24:	3c028001 	lui	v0,0x8001
8000ba28:	24170001 	li	s7,1
8000ba2c:	0000b021 	move	s6,zero
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000ba30:	241e0001 	li	s8,1
		{
			printf("Test inc Patt, short w/r \n");	
8000ba34:	24421bcc 	addiu	v0,v0,7116
8000ba38:	afa20030 	sw	v0,48(sp)
8000ba3c:	afb30028 	sw	s3,40(sp)

			for(i=0; i<len/2; i++)			
8000ba40:	24150800 	li	s5,2048
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
8000ba44:	3c148001 	lui	s4,0x8001
8000ba48:	26941b5c 	addiu	s4,s4,7004
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
8000ba4c:	3c028001 	lui	v0,0x8001
8000ba50:	24421bb0 	addiu	v0,v0,7088
8000ba54:	afa20034 	sw	v0,52(sp)
			for(i=0; i<len; i++)		
8000ba58:	08002e9c 	j	8000ba70 <CmdTestSRAM+0x294>
8000ba5c:	24121000 	li	s2,4096
	#define ACC16 1
	#define ACC32 2
	#define ACCEND 3
	unsigned int accmode;
	
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000ba60:	08002e39 	j	8000b8e4 <CmdTestSRAM+0x108>
8000ba64:	27b60010 	addiu	s6,sp,16
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000ba68:	26d60001 	addiu	s6,s6,1
8000ba6c:	26f70001 	addiu	s7,s7,1
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
8000ba70:	16c0001b 	bnez	s6,8000bae0 <CmdTestSRAM+0x304>
8000ba74:	00000000 	nop
		{			
			printf("Test inc Patt, byte w/r \n");	
8000ba78:	0c001cc1 	jal	80007304 <dprintf>
8000ba7c:	8fa40034 	lw	a0,52(sp)
8000ba80:	00001021 	move	v0,zero
8000ba84:	00531821 	addu	v1,v0,s3
8000ba88:	304400ff 	andi	a0,v0,0xff
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
8000ba8c:	a0640000 	sb	a0,0(v1)
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
	{
		if(accmode==ACC8)  //pattern fix value, 8 bit access
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
8000ba90:	24420001 	addiu	v0,v0,1
8000ba94:	1452fffc 	bne	v0,s2,8000ba88 <CmdTestSRAM+0x2ac>
8000ba98:	00531821 	addu	v1,v0,s3
8000ba9c:	8fb00028 	lw	s0,40(sp)
8000baa0:	00008821 	move	s1,zero
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
			{
				if(REG8(n8addr+i) != (i&0xff) )
8000baa4:	92020000 	lbu	v0,0(s0)
8000baa8:	304200ff 	andi	v0,v0,0xff
8000baac:	322600ff 	andi	a2,s1,0xff
8000bab0:	10460006 	beq	v0,a2,8000bacc <CmdTestSRAM+0x2f0>
8000bab4:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
8000bab8:	92070000 	lbu	a3,0(s0)
8000babc:	02802021 	move	a0,s4
8000bac0:	02002821 	move	a1,s0
8000bac4:	0c001cc1 	jal	80007304 <dprintf>
8000bac8:	30e700ff 	andi	a3,a3,0xff
		{			
			printf("Test inc Patt, byte w/r \n");	
			for(i=0; i<len; i++)		
				REG8(n8addr+i)=i;
			
			for(i=0; i<len; i++)
8000bacc:	26310001 	addiu	s1,s1,1
8000bad0:	1632fff4 	bne	s1,s2,8000baa4 <CmdTestSRAM+0x2c8>
8000bad4:	26100001 	addiu	s0,s0,1
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000bad8:	08002e9b 	j	8000ba6c <CmdTestSRAM+0x290>
8000badc:	26d60001 	addiu	s6,s6,1
			{
				if(REG8(n8addr+i) != (i&0xff) )
					printf("%x err, exp=%x, read=%x\n", n8addr+i, (i&0xff), REG8(n8addr+i));
			}
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
8000bae0:	16de001b 	bne	s6,s8,8000bb50 <CmdTestSRAM+0x374>
8000bae4:	24020002 	li	v0,2
		{
			printf("Test inc Patt, short w/r \n");	
8000bae8:	0c001cc1 	jal	80007304 <dprintf>
8000baec:	8fa40030 	lw	a0,48(sp)
8000baf0:	8fa30028 	lw	v1,40(sp)
8000baf4:	00001021 	move	v0,zero
8000baf8:	3044ffff 	andi	a0,v0,0xffff

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
8000bafc:	a4640000 	sh	a0,0(v1)
		}
		else if(accmode==ACC16)			//pattern fix value, 16 bit access
		{
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
8000bb00:	24420001 	addiu	v0,v0,1
8000bb04:	1455fffc 	bne	v0,s5,8000baf8 <CmdTestSRAM+0x31c>
8000bb08:	24630002 	addiu	v1,v1,2
8000bb0c:	8fb00028 	lw	s0,40(sp)
8000bb10:	00008821 	move	s1,zero
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
			{
				if(REG16(n16addr+i) != (i&0xffff) )
8000bb14:	96020000 	lhu	v0,0(s0)
8000bb18:	3042ffff 	andi	v0,v0,0xffff
8000bb1c:	3226ffff 	andi	a2,s1,0xffff
8000bb20:	10460006 	beq	v0,a2,8000bb3c <CmdTestSRAM+0x360>
8000bb24:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
8000bb28:	96070000 	lhu	a3,0(s0)
8000bb2c:	02802021 	move	a0,s4
8000bb30:	02002821 	move	a1,s0
8000bb34:	0c001cc1 	jal	80007304 <dprintf>
8000bb38:	30e7ffff 	andi	a3,a3,0xffff
			printf("Test inc Patt, short w/r \n");	

			for(i=0; i<len/2; i++)			
				REG16(n16addr+i)= i;	
			
			for(i=0; i<len/2; i++)
8000bb3c:	26310001 	addiu	s1,s1,1
8000bb40:	1635fff4 	bne	s1,s5,8000bb14 <CmdTestSRAM+0x338>
8000bb44:	26100002 	addiu	s0,s0,2
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000bb48:	08002e9b 	j	8000ba6c <CmdTestSRAM+0x290>
8000bb4c:	26d60001 	addiu	s6,s6,1
			{
				if(REG16(n16addr+i) != (i&0xffff) )
					printf("%x err, exp=%x, read=%x\n", n16addr+i, (i&0xffff), REG16(n16addr+i));
			}
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
8000bb50:	16c2001d 	bne	s6,v0,8000bbc8 <CmdTestSRAM+0x3ec>
8000bb54:	2ee20003 	sltiu	v0,s7,3
		{			
			printf("Test inc Patt, int w/r \n");	
8000bb58:	3c048001 	lui	a0,0x8001
8000bb5c:	0c001cc1 	jal	80007304 <dprintf>
8000bb60:	24841be8 	addiu	a0,a0,7144
8000bb64:	02601821 	move	v1,s3
8000bb68:	00001021 	move	v0,zero

			for(i=0; i<len/4; i++)			
8000bb6c:	24040400 	li	a0,1024
				REG32(n32addr+i)= i;	
8000bb70:	ac620000 	sw	v0,0(v1)
		}
		else if(accmode==ACC32)   //pattern fix value, 32 bit access
		{			
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
8000bb74:	24420001 	addiu	v0,v0,1
8000bb78:	1444fffd 	bne	v0,a0,8000bb70 <CmdTestSRAM+0x394>
8000bb7c:	24630004 	addiu	v1,v1,4
8000bb80:	02608021 	move	s0,s3
8000bb84:	00008821 	move	s1,zero
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
			{
				if(REG32(n32addr+i) != i)
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
8000bb88:	3c148001 	lui	s4,0x8001
8000bb8c:	26941b5c 	addiu	s4,s4,7004
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
8000bb90:	24120400 	li	s2,1024
			{
				if(REG32(n32addr+i) != i)
8000bb94:	8e020000 	lw	v0,0(s0)
8000bb98:	10510006 	beq	v0,s1,8000bbb4 <CmdTestSRAM+0x3d8>
8000bb9c:	00000000 	nop
					printf("%x err, exp=%x, read=%x\n", n32addr+i, i, REG32(n32addr+i));
8000bba0:	8e070000 	lw	a3,0(s0)
8000bba4:	02802021 	move	a0,s4
8000bba8:	02002821 	move	a1,s0
8000bbac:	0c001cc1 	jal	80007304 <dprintf>
8000bbb0:	02203021 	move	a2,s1
			printf("Test inc Patt, int w/r \n");	

			for(i=0; i<len/4; i++)			
				REG32(n32addr+i)= i;	

			for(i=0; i<len/4; i++)
8000bbb4:	26310001 	addiu	s1,s1,1
8000bbb8:	1632fff6 	bne	s1,s2,8000bb94 <CmdTestSRAM+0x3b8>
8000bbbc:	26100004 	addiu	s0,s0,4
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
8000bbc0:	08002ef4 	j	8000bbd0 <CmdTestSRAM+0x3f4>
8000bbc4:	8fa4002c 	lw	a0,44(sp)
		}		
	}
	}
	//-----------------------------------------------------	
	//test inc patt
	for(accmode=ACC8; accmode<ACCEND; accmode++)  // 8 bit, 16bit, 32bit
8000bbc8:	1440ffa7 	bnez	v0,8000ba68 <CmdTestSRAM+0x28c>
8000bbcc:	8fa4002c 	lw	a0,44(sp)
		if(n32addr[i] !=data)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, data, n8addr[i]);
	}
#endif
	//-----------------------------------------------------
	memset(n8addr,0xaa,len);
8000bbd0:	240500aa 	li	a1,170
8000bbd4:	0c0019d9 	jal	80006764 <memset>
8000bbd8:	24061000 	li	a2,4096
	Disable_SRAM();
8000bbdc:	0c002969 	jal	8000a5a4 <Disable_SRAM>
8000bbe0:	26711000 	addiu	s1,s3,4096


	//===========================================
	//stage 2: test on/off
	printf("Test Pattern 0x55 in DRAM, 0xaa in SRAM \n");
8000bbe4:	3c048001 	lui	a0,0x8001
8000bbe8:	0c001cc1 	jal	80007304 <dprintf>
8000bbec:	24841c04 	addiu	a0,a0,7172
	
	memset(n8addr,0x55,len);
8000bbf0:	8fa4002c 	lw	a0,44(sp)
8000bbf4:	24050055 	li	a1,85
8000bbf8:	0c0019d9 	jal	80006764 <memset>
8000bbfc:	24061000 	li	a2,4096
	
#if 1
	printf("Enable SRAM, do compare\n");
8000bc00:	3c048001 	lui	a0,0x8001
8000bc04:	0c001cc1 	jal	80007304 <dprintf>
8000bc08:	24841c30 	addiu	a0,a0,7216
	Enable_SRAM(paddr);
8000bc0c:	0c00295c 	jal	8000a570 <Enable_SRAM>
8000bc10:	8fa40038 	lw	a0,56(sp)
	//enable sram
	REG32(0xb8004000)=0;   //sram seg addr
}


int CmdTestSRAM(int argc, char* argv[])
8000bc14:	02608021 	move	s0,s3

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
8000bc18:	241200aa 	li	s2,170
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
8000bc1c:	3c148001 	lui	s4,0x8001
8000bc20:	26941b5c 	addiu	s4,s4,7004

	
	//compare the original sdram
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0xaa)
8000bc24:	92070000 	lbu	a3,0(s0)
8000bc28:	10f20004 	beq	a3,s2,8000bc3c <CmdTestSRAM+0x460>
8000bc2c:	02002821 	move	a1,s0
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
8000bc30:	02802021 	move	a0,s4
8000bc34:	0c001cc1 	jal	80007304 <dprintf>
8000bc38:	02403021 	move	a2,s2
8000bc3c:	26100001 	addiu	s0,s0,1
	Enable_SRAM(paddr);
#endif

	
	//compare the original sdram
	for(i=0; i<len; i++)
8000bc40:	1611fff8 	bne	s0,s1,8000bc24 <CmdTestSRAM+0x448>
8000bc44:	00000000 	nop
	{
		if(n8addr[i] != 0xaa)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0xaa, n8addr[i]);
	}
	
	printf("Disable SRAM, do compare\n");
8000bc48:	3c048001 	lui	a0,0x8001
8000bc4c:	0c001cc1 	jal	80007304 <dprintf>
8000bc50:	24841c4c 	addiu	a0,a0,7244
	Disable_SRAM();
8000bc54:	0c002969 	jal	8000a5a4 <Disable_SRAM>
8000bc58:	24100055 	li	s0,85
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
8000bc5c:	3c128001 	lui	s2,0x8001
8000bc60:	26521b5c 	addiu	s2,s2,7004
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
	{
		if(n8addr[i] != 0x55)
8000bc64:	92670000 	lbu	a3,0(s3)
8000bc68:	10f00004 	beq	a3,s0,8000bc7c <CmdTestSRAM+0x4a0>
8000bc6c:	02602821 	move	a1,s3
			printf("%x err, exp=%x, read=%x\n", n8addr+i, 0x55, n8addr[i]);
8000bc70:	02402021 	move	a0,s2
8000bc74:	0c001cc1 	jal	80007304 <dprintf>
8000bc78:	02003021 	move	a2,s0
8000bc7c:	26730001 	addiu	s3,s3,1
	}
	
	printf("Disable SRAM, do compare\n");
	Disable_SRAM();
	
	for(i=0; i<len; i++)
8000bc80:	1671fff8 	bne	s3,s1,8000bc64 <CmdTestSRAM+0x488>
8000bc84:	3c048001 	lui	a0,0x8001
	}

	//-----------------------------------------------------

	
	printf("No error is pass\n");
8000bc88:	0c001cc1 	jal	80007304 <dprintf>
8000bc8c:	24841c68 	addiu	a0,a0,7272
}
8000bc90:	8fbf0064 	lw	ra,100(sp)
8000bc94:	8fbe0060 	lw	s8,96(sp)
8000bc98:	8fb7005c 	lw	s7,92(sp)
8000bc9c:	8fb60058 	lw	s6,88(sp)
8000bca0:	8fb50054 	lw	s5,84(sp)
8000bca4:	8fb40050 	lw	s4,80(sp)
8000bca8:	8fb3004c 	lw	s3,76(sp)
8000bcac:	8fb20048 	lw	s2,72(sp)
8000bcb0:	8fb10044 	lw	s1,68(sp)
8000bcb4:	8fb00040 	lw	s0,64(sp)
8000bcb8:	03e00008 	jr	ra
8000bcbc:	27bd0068 	addiu	sp,sp,104

8000bcc0 <Check_UartRxDataRdy>:



unsigned int Check_UartRxDataRdy()
{
	if 	(REG32(UART_LSR) & (1<<24) )
8000bcc0:	3c02b800 	lui	v0,0xb800
8000bcc4:	34422014 	ori	v0,v0,0x2014
8000bcc8:	8c420000 	lw	v0,0(v0)
		return 1;
	else
		return 0;
}
8000bccc:	03e00008 	jr	ra
8000bcd0:	7c420600 	ext	v0,v0,0x18,0x1

8000bcd4 <Get_UartData>:

unsigned char Get_UartData()
{	return REG32(UART_RBR)>>24;
8000bcd4:	3c02b800 	lui	v0,0xb800
8000bcd8:	34422000 	ori	v0,v0,0x2000
8000bcdc:	8c420000 	lw	v0,0(v0)
}
8000bce0:	03e00008 	jr	ra
8000bce4:	00021602 	srl	v0,v0,0x18

8000bce8 <Get_UartData_timeout>:

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
8000bce8:	27bdffe0 	addiu	sp,sp,-32
8000bcec:	afbf001c 	sw	ra,28(sp)
8000bcf0:	afb10018 	sw	s1,24(sp)
8000bcf4:	afb00014 	sw	s0,20(sp)
8000bcf8:	00808821 	move	s1,a0
	unsigned int t=timeout;

	while(t--)
8000bcfc:	08002f4a 	j	8000bd28 <Get_UartData_timeout+0x40>
8000bd00:	00a08021 	move	s0,a1
	{
		if(Check_UartRxDataRdy())
8000bd04:	0c002f30 	jal	8000bcc0 <Check_UartRxDataRdy>
8000bd08:	2610ffff 	addiu	s0,s0,-1
8000bd0c:	10400006 	beqz	v0,8000bd28 <Get_UartData_timeout+0x40>
8000bd10:	00000000 	nop
		{	*c=Get_UartData();
8000bd14:	0c002f35 	jal	8000bcd4 <Get_UartData>
8000bd18:	00000000 	nop
8000bd1c:	a2220000 	sb	v0,0(s1)
			return 1;
8000bd20:	08002f4c 	j	8000bd30 <Get_UartData_timeout+0x48>
8000bd24:	24020001 	li	v0,1

int Get_UartData_timeout(unsigned char *c, unsigned int  timeout)
{	
	unsigned int t=timeout;

	while(t--)
8000bd28:	1600fff6 	bnez	s0,8000bd04 <Get_UartData_timeout+0x1c>
8000bd2c:	00001021 	move	v0,zero
			return 1;
		}

	}
	return 0;
}
8000bd30:	8fbf001c 	lw	ra,28(sp)
8000bd34:	8fb10018 	lw	s1,24(sp)
8000bd38:	8fb00014 	lw	s0,20(sp)
8000bd3c:	03e00008 	jr	ra
8000bd40:	27bd0020 	addiu	sp,sp,32

8000bd44 <xmodem_receive>:




int xmodem_receive(unsigned char  * buf)
{
8000bd44:	27bdffa8 	addiu	sp,sp,-88
8000bd48:	afbf0054 	sw	ra,84(sp)
8000bd4c:	afbe0050 	sw	s8,80(sp)
8000bd50:	afb7004c 	sw	s7,76(sp)
8000bd54:	afb60048 	sw	s6,72(sp)
8000bd58:	afb50044 	sw	s5,68(sp)
8000bd5c:	afb40040 	sw	s4,64(sp)
8000bd60:	afb3003c 	sw	s3,60(sp)
8000bd64:	afb20038 	sw	s2,56(sp)
8000bd68:	afb10034 	sw	s1,52(sp)
8000bd6c:	afb00030 	sw	s0,48(sp)
8000bd70:	afa40018 	sw	a0,24(sp)
8000bd74:	24110014 	li	s1,20
8000bd78:	00009821 	move	s3,zero
8000bd7c:	00008021 	move	s0,zero
8000bd80:	24020001 	li	v0,1
8000bd84:	afa2001c 	sw	v0,28(sp)
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
8000bd88:	3c148001 	lui	s4,0x8001
8000bd8c:	2694ec20 	addiu	s4,s4,-5088
					retry--;
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
8000bd90:	27b50010 	addiu	s5,sp,16
8000bd94:	3c120001 	lui	s2,0x1
8000bd98:	365286a0 	ori	s2,s2,0x86a0
				{	head1=c;
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
				{	head2=c;				
8000bd9c:	0000f021 	move	s8,zero
						 continue;
					}
				}
				
				retry--;
				putc(NAK);
8000bda0:	24160001 	li	s6,1
					}
				
					else if(c == CAN)
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
8000bda4:	24170004 	li	s7,4
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
	{
		switch(state)
8000bda8:	2e020005 	sltiu	v0,s0,5
8000bdac:	1040ffff 	beqz	v0,8000bdac <xmodem_receive+0x68>
8000bdb0:	00000000 	nop
8000bdb4:	00101080 	sll	v0,s0,0x2
8000bdb8:	02821021 	addu	v0,s4,v0
8000bdbc:	8c420000 	lw	v0,0(v0)
8000bdc0:	00400008 	jr	v0
8000bdc4:	00000000 	nop
		{
			case XMODEM_RX_READY:
				
				putc(NAK);			
8000bdc8:	0c00197c 	jal	800065f0 <serial_outc>
8000bdcc:	24040015 	li	a0,21
				if(getc_with_timeout(&c, timeout))
8000bdd0:	02a02021 	move	a0,s5
8000bdd4:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000bdd8:	02402821 	move	a1,s2
8000bddc:	10400078 	beqz	v0,8000bfc0 <xmodem_receive+0x27c>
8000bde0:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
8000bde4:	10560075 	beq	v0,s6,8000bfbc <xmodem_receive+0x278>
8000bde8:	24030003 	li	v1,3
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}			
					else if(c == 3)  //Ctrl+C
8000bdec:	14430074 	bne	v0,v1,8000bfc0 <xmodem_receive+0x27c>
8000bdf0:	00000000 	nop
					{
						putc(CAN);	putc(CAN);
8000bdf4:	0c00197c 	jal	800065f0 <serial_outc>
8000bdf8:	24040018 	li	a0,24
8000bdfc:	0c00197c 	jal	800065f0 <serial_outc>
8000be00:	24040018 	li	a0,24
						putc(CAN);	putc(CAN);
8000be04:	0c00197c 	jal	800065f0 <serial_outc>
8000be08:	24040018 	li	a0,24
8000be0c:	0c00197c 	jal	800065f0 <serial_outc>
8000be10:	24040018 	li	a0,24
						size = 0;
						return false;
8000be14:	08002ffb 	j	8000bfec <xmodem_receive+0x2a8>
8000be18:	00009821 	move	s3,zero
					}
				}	
				break;
				
			case XMODEM_WAIT_HEADER:
				if(getc_with_timeout(&c, timeout))
8000be1c:	02a02021 	move	a0,s5
8000be20:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000be24:	02402821 	move	a1,s2
8000be28:	10400009 	beqz	v0,8000be50 <xmodem_receive+0x10c>
8000be2c:	93a20010 	lbu	v0,16(sp)
				{
					if(c == SOH)
8000be30:	10560062 	beq	v0,s6,8000bfbc <xmodem_receive+0x278>
8000be34:	24040018 	li	a0,24
					{
						packet_size = 128;						
						state = XMODEM_RX_PACKET;
					}
				
					else if(c == CAN)
8000be38:	14440003 	bne	v0,a0,8000be48 <xmodem_receive+0x104>
8000be3c:	00571026 	xor	v0,v0,s7
8000be40:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000be44:	24100003 	li	s0,3
					{	state = XMODEM_CANCEL;
					}
					else if(c == EOT)
8000be48:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000be4c:	02e2800a 	movz	s0,s7,v0
					}
				}
				else
				{
					/* timed out, try again */
					retry--;
8000be50:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000be54:	2631ffff 	addiu	s1,s1,-1
				}
				break;
				
			case XMODEM_RX_PACKET:
				if(getc_with_timeout(&c, timeout))
8000be58:	02a02021 	move	a0,s5
8000be5c:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000be60:	02402821 	move	a1,s2
8000be64:	10400024 	beqz	v0,8000bef8 <xmodem_receive+0x1b4>
8000be68:	93a50010 	lbu	a1,16(sp)
				{	head1=c;
8000be6c:	afa50028 	sw	a1,40(sp)
				}
				else goto fail;
				
				if(getc_with_timeout(&c, timeout))
8000be70:	02a02021 	move	a0,s5
8000be74:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000be78:	02402821 	move	a1,s2
8000be7c:	1040001e 	beqz	v0,8000bef8 <xmodem_receive+0x1b4>
8000be80:	93a20010 	lbu	v0,16(sp)
				{	head2=c;				
8000be84:	afa2002c 	sw	v0,44(sp)
8000be88:	afbe0024 	sw	s8,36(sp)
8000be8c:	afbe0020 	sw	s8,32(sp)
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
				{
					if(getc_with_timeout(&c, timeout))
8000be90:	02a02021 	move	a0,s5
8000be94:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000be98:	02402821 	move	a1,s2
8000be9c:	10400016 	beqz	v0,8000bef8 <xmodem_receive+0x1b4>
8000bea0:	8fa40018 	lw	a0,24(sp)
					{	ptr[i] = c;
8000bea4:	8fa50020 	lw	a1,32(sp)
8000bea8:	00851821 	addu	v1,a0,a1
8000beac:	93a20010 	lbu	v0,16(sp)
8000beb0:	a0620000 	sb	v0,0(v1)
						csum+=c;
8000beb4:	8fa30024 	lw	v1,36(sp)
8000beb8:	00621021 	addu	v0,v1,v0
8000bebc:	304200ff 	andi	v0,v0,0xff
8000bec0:	afa20024 	sw	v0,36(sp)
				{	head2=c;				
				}
				else goto fail;

				csum=0;
				for(i = 0; i < packet_size  ; i++)
8000bec4:	24a50001 	addiu	a1,a1,1
8000bec8:	24040080 	li	a0,128
8000becc:	14a4fff0 	bne	a1,a0,8000be90 <xmodem_receive+0x14c>
8000bed0:	afa50020 	sw	a1,32(sp)
					}
					else
						goto fail;
				}

				if(getc_with_timeout(&c, timeout))
8000bed4:	02a02021 	move	a0,s5
8000bed8:	0c002f3a 	jal	8000bce8 <Get_UartData_timeout>
8000bedc:	02402821 	move	a1,s2
8000bee0:	10400005 	beqz	v0,8000bef8 <xmodem_receive+0x1b4>
8000bee4:	8fa50020 	lw	a1,32(sp)

				
				state = XMODEM_WAIT_HEADER;
				
				/* packet was too small, retry */
				if(i < (packet_size))
8000bee8:	2ca30080 	sltiu	v1,a1,128
8000beec:	10600007 	beqz	v1,8000bf0c <xmodem_receive+0x1c8>
8000bef0:	93a20010 	lbu	v0,16(sp)
8000bef4:	02c08021 	move	s0,s6
				{
fail:				
					retry--;
8000bef8:	2631ffff 	addiu	s1,s1,-1
					putc(NAK);
8000befc:	0c00197c 	jal	800065f0 <serial_outc>
8000bf00:	24040015 	li	a0,21
					continue;
8000bf04:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000bf08:	00000000 	nop
				}
				
				/* check validity of packet */
				if( (head1 == 255-head2) && (head_csum==csum) )
8000bf0c:	240400ff 	li	a0,255
8000bf10:	8fa5002c 	lw	a1,44(sp)
8000bf14:	00851823 	subu	v1,a0,a1
8000bf18:	8fa40028 	lw	a0,40(sp)
8000bf1c:	1483001a 	bne	a0,v1,8000bf88 <xmodem_receive+0x244>
8000bf20:	8fa50024 	lw	a1,36(sp)
8000bf24:	14450018 	bne	v0,a1,8000bf88 <xmodem_receive+0x244>
8000bf28:	8fa2001c 	lw	v0,28(sp)
				{
					/* is this the packet we were waiting for? */
					if(head1== block_index)
8000bf2c:	1444000d 	bne	v0,a0,8000bf64 <xmodem_receive+0x220>
8000bf30:	8fa4001c 	lw	a0,28(sp)
					{
						ptr+=packet_size;
8000bf34:	8fa30018 	lw	v1,24(sp)
8000bf38:	24630080 	addiu	v1,v1,128
8000bf3c:	afa30018 	sw	v1,24(sp)
						size += packet_size;						
8000bf40:	26730080 	addiu	s3,s3,128
						block_index++;
8000bf44:	24420001 	addiu	v0,v0,1
8000bf48:	304200ff 	andi	v0,v0,0xff
8000bf4c:	afa2001c 	sw	v0,28(sp)
						retry = RETRY;
						putc(ACK);
8000bf50:	0c00197c 	jal	800065f0 <serial_outc>
8000bf54:	24040006 	li	a0,6
8000bf58:	24110014 	li	s1,20
8000bf5c:	08002f6a 	j	8000bda8 <xmodem_receive+0x64>
8000bf60:	02c08021 	move	s0,s6
						continue;
					}
					else if(head1 == (unsigned char )(block_index-1))
8000bf64:	2482ffff 	addiu	v0,a0,-1
8000bf68:	304200ff 	andi	v0,v0,0xff
8000bf6c:	8fa50028 	lw	a1,40(sp)
8000bf70:	14450005 	bne	v0,a1,8000bf88 <xmodem_receive+0x244>
8000bf74:	00000000 	nop
					{
						/* this is a retransmission of the last packet */
						putc(ACK);
8000bf78:	0c00197c 	jal	800065f0 <serial_outc>
8000bf7c:	24040006 	li	a0,6
						 continue;
8000bf80:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000bf84:	02c08021 	move	s0,s6
					}
				}
				
				retry--;
8000bf88:	2631ffff 	addiu	s1,s1,-1
				putc(NAK);
8000bf8c:	0c00197c 	jal	800065f0 <serial_outc>
8000bf90:	24040015 	li	a0,21
				break;
8000bf94:	08002ff0 	j	8000bfc0 <xmodem_receive+0x27c>
8000bf98:	02c08021 	move	s0,s6
				
			case XMODEM_CANCEL:
				putc(ACK);
8000bf9c:	0c00197c 	jal	800065f0 <serial_outc>
8000bfa0:	24040006 	li	a0,6
				
				return false;
8000bfa4:	08002ffb 	j	8000bfec <xmodem_receive+0x2a8>
8000bfa8:	00009821 	move	s3,zero
				
			case XMODEM_EOT:
				putc(ACK);
8000bfac:	0c00197c 	jal	800065f0 <serial_outc>
8000bfb0:	24040006 	li	a0,6
				//mdelay(100);				
				return size;
8000bfb4:	08002ffc 	j	8000bff0 <xmodem_receive+0x2ac>
8000bfb8:	02601021 	move	v0,s3
8000bfbc:	24100002 	li	s0,2

	
	/* received buffer size to zero */
	int size = 0;
	
	while(retry > 0)
8000bfc0:	1620ff7a 	bnez	s1,8000bdac <xmodem_receive+0x68>
8000bfc4:	2e020005 	sltiu	v0,s0,5
				break;
		}
	}
	
	/* retry too much, fail */
	putc(CAN);	putc(CAN);
8000bfc8:	0c00197c 	jal	800065f0 <serial_outc>
8000bfcc:	24040018 	li	a0,24
8000bfd0:	0c00197c 	jal	800065f0 <serial_outc>
8000bfd4:	24040018 	li	a0,24
	putc(CAN);	putc(CAN);
8000bfd8:	0c00197c 	jal	800065f0 <serial_outc>
8000bfdc:	24040018 	li	a0,24
8000bfe0:	0c00197c 	jal	800065f0 <serial_outc>
8000bfe4:	24040018 	li	a0,24
8000bfe8:	00009821 	move	s3,zero
	
	
	return false;
}
8000bfec:	02601021 	move	v0,s3
8000bff0:	8fbf0054 	lw	ra,84(sp)
8000bff4:	8fbe0050 	lw	s8,80(sp)
8000bff8:	8fb7004c 	lw	s7,76(sp)
8000bffc:	8fb60048 	lw	s6,72(sp)
8000c000:	8fb50044 	lw	s5,68(sp)
8000c004:	8fb40040 	lw	s4,64(sp)
8000c008:	8fb3003c 	lw	s3,60(sp)
8000c00c:	8fb20038 	lw	s2,56(sp)
8000c010:	8fb10034 	lw	s1,52(sp)
8000c014:	8fb00030 	lw	s0,48(sp)
8000c018:	03e00008 	jr	ra
8000c01c:	27bd0058 	addiu	sp,sp,88

8000c020 <pollingDownModeKeyword>:
{
	int i;
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
	if  (Check_UART_DataReady() )
8000c020:	3c02b800 	lui	v0,0xb800
8000c024:	34422014 	ori	v0,v0,0x2014
8000c028:	8c420000 	lw	v0,0(v0)
8000c02c:	7c420600 	ext	v0,v0,0x18,0x1
8000c030:	1040000c 	beqz	v0,8000c064 <pollingDownModeKeyword+0x44>
8000c034:	00000000 	nop
	{
		i=Get_UART_Data();
8000c038:	3c02b800 	lui	v0,0xb800
8000c03c:	34422000 	ori	v0,v0,0x2000
8000c040:	8c430000 	lw	v1,0(v0)
		Get_UART_Data();
8000c044:	8c420000 	lw	v0,0(v0)
		if( i == key )
8000c048:	00031602 	srl	v0,v1,0x18
8000c04c:	14440005 	bne	v0,a0,8000c064 <pollingDownModeKeyword+0x44>
8000c050:	24030001 	li	v1,1
		{ 	
#if defined(UTILITY_DEBUG)		
			dprintf("User Press ESC Break Key\r\n");
#endif			
			gCHKKEY_HIT=1;
8000c054:	3c028001 	lui	v0,0x8001
8000c058:	ac434150 	sw	v1,16720(v0)
			return 1;
8000c05c:	03e00008 	jr	ra
8000c060:	24020001 	li	v0,1
		}
	}
	return 0;
}
8000c064:	03e00008 	jr	ra
8000c068:	00001021 	move	v0,zero

8000c06c <Init_GPIO>:
	REG32(PEFGHDIR_REG) = REG32(PEFGHDIR_REG) & (~(1<<25) );  //0 input, 1 output, set F bit 7 input
#endif	
#endif
#endif
#endif
}
8000c06c:	03e00008 	jr	ra
8000c070:	00000000 	nop

8000c074 <console_init>:
	unsigned long dl;
	unsigned long dll;     
	unsigned long dlm;       


  	REG32(UART_LCR_REG)=0x03000000;		//Line Control Register  8,n,1
8000c074:	3c02b800 	lui	v0,0xb800
8000c078:	3443200c 	ori	v1,v0,0x200c
8000c07c:	3c050300 	lui	a1,0x300
8000c080:	ac650000 	sw	a1,0(v1)
  			
  	REG32( UART_FCR_REG)=0xc7000000;		//FIFO Ccontrol Register
8000c084:	34462008 	ori	a2,v0,0x2008
8000c088:	3c07c700 	lui	a3,0xc700
8000c08c:	acc70000 	sw	a3,0(a2)
  	REG32( UART_IER_REG)=0x00000000;
8000c090:	34462004 	ori	a2,v0,0x2004
8000c094:	acc00000 	sw	zero,0(a2)
  	dl = (lexea_clock /16)/BAUD_RATE-1;
8000c098:	3c071b4e 	lui	a3,0x1b4e
8000c09c:	34e781b5 	ori	a3,a3,0x81b5
8000c0a0:	00870019 	multu	a0,a3
8000c0a4:	00002010 	mfhi	a0
8000c0a8:	00042402 	srl	a0,a0,0x10
8000c0ac:	2484ffff 	addiu	a0,a0,-1
  	//*(volatile unsigned long *)(0xa1000000) = dl ; 
  	dll = dl & 0xff;
  	dlm = dl / 0x100;
  	REG32( UART_LCR_REG)=0x83000000;		//Divisor latch access bit=1
8000c0b0:	3c078300 	lui	a3,0x8300
8000c0b4:	ac670000 	sw	a3,0(v1)
  	REG32( UART_DLL_REG)=dll*0x1000000;
8000c0b8:	00043e00 	sll	a3,a0,0x18
8000c0bc:	34422000 	ori	v0,v0,0x2000
8000c0c0:	ac470000 	sw	a3,0(v0)
   	REG32( UART_DLM_REG)=dlm*0x1000000; 
8000c0c4:	00042202 	srl	a0,a0,0x8
8000c0c8:	00042600 	sll	a0,a0,0x18
8000c0cc:	acc40000 	sw	a0,0(a2)
    	REG32( UART_LCR_REG)=0x83000000& 0x7fffffff;	//Divisor latch access bit=0
8000c0d0:	ac650000 	sw	a1,0(v1)
   	//rtl_outl( UART_THR,0x41000000);	

	//dprintf("\n\n-------------------------------------------");
	//dprintf("\nUART1 output test ok\n");
}
8000c0d4:	03e00008 	jr	ra
8000c0d8:	00000000 	nop

8000c0dc <setClkInitConsole>:
}
#endif
//-------------------------------------------------------
//set clk and init console	
void setClkInitConsole(void)
{
8000c0dc:	27bdffe8 	addiu	sp,sp,-24
8000c0e0:	afbf0014 	sw	ra,20(sp)
	console_init( glexra_clock);
8000c0e4:	3c028001 	lui	v0,0x8001
8000c0e8:	0c00301d 	jal	8000c074 <console_init>
8000c0ec:	8c442f00 	lw	a0,12032(v0)
//	printf("\n=>init console ok\n");
}
8000c0f0:	8fbf0014 	lw	ra,20(sp)
8000c0f4:	03e00008 	jr	ra
8000c0f8:	27bd0018 	addiu	sp,sp,24

8000c0fc <initFlash>:
//-------------------------------------------------------

//-------------------------------------------------------
// init flash 
void initFlash(void)
{
8000c0fc:	27bdffe8 	addiu	sp,sp,-24
8000c100:	afbf0014 	sw	ra,20(sp)
#if defined(CONFIG_SPI_FLASH)
   	spi_probe();                                  
8000c104:	0c00120d 	jal	80004834 <spi_probe>
8000c108:	00000000 	nop
		rtk_scan_v2r_bbt();
		rtk_nand_scan_bbt();
#endif

#endif
}
8000c10c:	8fbf0014 	lw	ra,20(sp)
8000c110:	03e00008 	jr	ra
8000c114:	27bd0018 	addiu	sp,sp,24

8000c118 <initHeap>:
//	printf("\n=>init console ok\n");
}
//-------------------------------------------------------
//init heap	
void initHeap(void)
{
8000c118:	27bdffe8 	addiu	sp,sp,-24
8000c11c:	afbf0014 	sw	ra,20(sp)
#if defined(RTL8198)
	/* Initialize malloc mechanism */
	UINT32 heap_addr=((UINT32)dl_heap&(~7))+8 ;
8000c120:	2402fff8 	li	v0,-8
8000c124:	3c058001 	lui	a1,0x8001
8000c128:	24a552a8 	addiu	a1,a1,21160
8000c12c:	00a22824 	and	a1,a1,v0
8000c130:	24a50008 	addiu	a1,a1,8
	UINT32 heap_end=heap_addr+sizeof(dl_heap)-8;
  	i_alloc((void *)heap_addr, heap_end);
8000c134:	00a02021 	move	a0,a1
8000c138:	3402fff8 	li	v0,0xfff8
8000c13c:	0c0018e8 	jal	800063a0 <i_alloc>
8000c140:	00a22821 	addu	a1,a1,v0
8000c144:	40016000 	mfc0	at,c0_status
8000c148:	34210001 	ori	at,at,0x1
8000c14c:	38210001 	xori	at,at,0x1
8000c150:	40816000 	mtc0	at,c0_status
8000c154:	000000c0 	ehb
	...
#endif
	cli();  	
	flush_cache(); // david
8000c164:	0c00187c 	jal	800061f0 <flush_cache>
8000c168:	00000000 	nop
}
8000c16c:	8fbf0014 	lw	ra,20(sp)
8000c170:	03e00008 	jr	ra
8000c174:	27bd0018 	addiu	sp,sp,24

8000c178 <CmdEthStartup>:
	//dprintf("\nUART1 output test ok\n");
}
//-------------------------------------------------------

void CmdEthStartup(int argc, char* argv[])
{
8000c178:	27bdffe8 	addiu	sp,sp,-24
8000c17c:	afbf0014 	sw	ra,20(sp)
	eth_startup(0);	
8000c180:	0c00084f 	jal	8000213c <eth_startup>
8000c184:	00002021 	move	a0,zero

	dprintf("\n---Ethernet init Okay!\n");
8000c188:	3c048001 	lui	a0,0x8001
8000c18c:	0c001cc1 	jal	80007304 <dprintf>
8000c190:	24841e84 	addiu	a0,a0,7812


extern __inline__ void
__sti(void)
{
	__asm__ __volatile__(
8000c194:	40016000 	mfc0	at,c0_status
8000c198:	34210001 	ori	at,at,0x1
8000c19c:	40816000 	mtc0	at,c0_status
8000c1a0:	000000c0 	ehb
	sti();

#ifdef SUPPORT_TFTP_CLIENT	
	tftpd_entry(0);		
#else
	tftpd_entry();		
8000c1a4:	0c00036e 	jal	80000db8 <tftpd_entry>
8000c1a8:	00000000 	nop
#endif
	return ;		
}
8000c1ac:	8fbf0014 	lw	ra,20(sp)
8000c1b0:	03e00008 	jr	ra
8000c1b4:	27bd0018 	addiu	sp,sp,24

8000c1b8 <goToDownMode>:

void goToDownMode()
{
8000c1b8:	27bdffe8 	addiu	sp,sp,-24
8000c1bc:	afbf0014 	sw	ra,20(sp)
#ifndef CONFIG_SW_NONE

	if(pollingDownModeKeyword('m')==0)
8000c1c0:	0c003008 	jal	8000c020 <pollingDownModeKeyword>
8000c1c4:	2404006d 	li	a0,109
8000c1c8:	1440000c 	bnez	v0,8000c1fc <goToDownMode+0x44>
8000c1cc:	00000000 	nop
	{
		eth_startup(0);	
8000c1d0:	0c00084f 	jal	8000213c <eth_startup>
8000c1d4:	00002021 	move	a0,zero

		dprintf("\n---Ethernet init Okay!\n");
8000c1d8:	3c048001 	lui	a0,0x8001
8000c1dc:	0c001cc1 	jal	80007304 <dprintf>
8000c1e0:	24841e84 	addiu	a0,a0,7812
8000c1e4:	40016000 	mfc0	at,c0_status
8000c1e8:	34210001 	ori	at,at,0x1
8000c1ec:	40816000 	mtc0	at,c0_status
8000c1f0:	000000c0 	ehb
		sti();

#ifdef SUPPORT_TFTP_CLIENT	
		tftpd_entry(0);
#else
		tftpd_entry();		
8000c1f4:	0c00036e 	jal	80000db8 <tftpd_entry>
8000c1f8:	00000000 	nop
		httpd_entry();
#endif

	}
#endif
	monitor();
8000c1fc:	0c0032e7 	jal	8000cb9c <monitor>
8000c200:	00000000 	nop
	return ;
}
8000c204:	8fbf0014 	lw	ra,20(sp)
8000c208:	03e00008 	jr	ra
8000c20c:	27bd0018 	addiu	sp,sp,24

8000c210 <user_interrupt>:
#endif
//------------------------------------------------------------------------------------------

//return 0: do nothing; 1: jump to down load mode; 3 jump to debug down load mode
int user_interrupt(unsigned long time)
{
8000c210:	27bdffe8 	addiu	sp,sp,-24
8000c214:	afbf0014 	sw	ra,20(sp)
	
#ifdef CONFIG_BOOT_RESET_ENABLE
	int button_press_detected=-1;
#endif
	
	tickStart=get_timer_jiffies();
8000c218:	0c00325c 	jal	8000c970 <get_timer_jiffies>
8000c21c:	00000000 	nop
#ifdef  SUPPORT_TFTP_CLIENT
	do 
#endif
    {
		ret=pollingDownModeKeyword(ESC);
8000c220:	0c003008 	jal	8000c020 <pollingDownModeKeyword>
8000c224:	2404001b 	li	a0,27
8000c228:	38420001 	xori	v0,v0,0x1
		gCHKKEY_HIT=1;    
		return 1;
	}
#endif	
	return 0;
}
8000c22c:	2c420001 	sltiu	v0,v0,1
8000c230:	8fbf0014 	lw	ra,20(sp)
8000c234:	03e00008 	jr	ra
8000c238:	27bd0018 	addiu	sp,sp,24

8000c23c <goToLocalStartMode>:
#endif		
//-------------------------------------------------------

#if !defined(CONFIG_NONE_FLASH)
void goToLocalStartMode(unsigned long addr,IMG_HEADER_Tp pheader)
{
8000c23c:	27bdffe8 	addiu	sp,sp,-24
8000c240:	afbf0014 	sw	ra,20(sp)
8000c244:	afb00010 	sw	s0,16(sp)
8000c248:	00801021 	move	v0,a0
8000c24c:	00a08021 	move	s0,a1
8000c250:	00002021 	move	a0,zero
8000c254:	00001821 	move	v1,zero
	}			
#else

	word_ptr = (unsigned short *)pheader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
	*word_ptr = rtl_inw(addr + i);
8000c258:	3c07b800 	lui	a3,0xb800
8000c25c:	00473821 	addu	a3,v0,a3
		*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
	}			
#else

	word_ptr = (unsigned short *)pheader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000c260:	24060010 	li	a2,16
	*word_ptr = rtl_inw(addr + i);
8000c264:	00e42021 	addu	a0,a3,a0
8000c268:	94850000 	lhu	a1,0(a0)
8000c26c:	02032021 	addu	a0,s0,v1
8000c270:	a4850000 	sh	a1,0(a0)
		*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
	}			
#else

	word_ptr = (unsigned short *)pheader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000c274:	24630002 	addiu	v1,v1,2
8000c278:	1466fffa 	bne	v1,a2,8000c264 <goToLocalStartMode+0x28>
8000c27c:	00602021 	move	a0,v1
	// move image to SDRAM
#if !defined(CONFIG_NONE_FLASH)	
#ifdef CONFIG_NAND_FLASH
	nflashread( pheader->startAddr|0x20000000,(unsigned int)(addr-FLASH_BASE+sizeof(IMG_HEADER_T)),pheader->len-2,0);
#else
	flashread( pheader->startAddr|0x20000000,	(unsigned int)(addr-FLASH_BASE+sizeof(IMG_HEADER_T)), pheader->len-2);
8000c280:	8e040004 	lw	a0,4(s0)
8000c284:	8e06000c 	lw	a2,12(s0)
8000c288:	3c032000 	lui	v1,0x2000
8000c28c:	00832025 	or	a0,a0,v1
8000c290:	3c05fb00 	lui	a1,0xfb00
8000c294:	34a50010 	ori	a1,a1,0x10
8000c298:	00452821 	addu	a1,v0,a1
8000c29c:	0c0011c2 	jal	80004708 <flashread>
8000c2a0:	24c6fffe 	addiu	a2,a2,-2
#endif
#endif		
	if ( !user_interrupt(0) )  // See if user escape during copy image
8000c2a4:	0c003084 	jal	8000c210 <user_interrupt>
8000c2a8:	00002021 	move	a0,zero
8000c2ac:	14400023 	bnez	v0,8000c33c <goToLocalStartMode+0x100>
8000c2b0:	8fbf0014 	lw	ra,20(sp)
8000c2b4:	3c03b800 	lui	v1,0xb800
8000c2b8:	ac623000 	sw	v0,12288(v1)
		outl(0,GIMR0); // mask all interrupt
#if defined(CONFIG_BOOT_RESET_ENABLE)
		Set_GPIO_LED_OFF();
#endif

		prom_printf("Jump to image start=0x%x...\n", pheader->startAddr);
8000c2bc:	3c048001 	lui	a0,0x8001
8000c2c0:	24841ea0 	addiu	a0,a0,7840
8000c2c4:	0c001d43 	jal	8000750c <prom_printf>
8000c2c8:	8e050004 	lw	a1,4(s0)
		set_bankinfo_register();
#endif
#ifdef CONFIG_RTK_BOOTINFO_SUPPORT
		rtk_inc_bootcnt();
#endif
		jump = (void *)(pheader->startAddr);
8000c2cc:	8e100004 	lw	s0,4(s0)

		 REG32(0xb8003114)=0;
8000c2d0:	3c02b800 	lui	v0,0xb800
8000c2d4:	34433114 	ori	v1,v0,0x3114
8000c2d8:	ac600000 	sw	zero,0(v1)
  		REG32(0xb8000010)&=~(1<<11);
8000c2dc:	34420010 	ori	v0,v0,0x10
8000c2e0:	8c440000 	lw	a0,0(v0)
8000c2e4:	2403f7ff 	li	v1,-2049
8000c2e8:	00831824 	and	v1,a0,v1
8000c2ec:	ac430000 	sw	v1,0(v0)
  		REG32(0xbbdc0300)=0xffffffff;
8000c2f0:	3c03bbdc 	lui	v1,0xbbdc
8000c2f4:	34640300 	ori	a0,v1,0x300
8000c2f8:	2402ffff 	li	v0,-1
8000c2fc:	ac820000 	sw	v0,0(a0)
  		REG32(0xbbdc0304)=0xffffffff;
8000c300:	34630304 	ori	v1,v1,0x304
8000c304:	ac620000 	sw	v0,0(v1)
 * no nops at all.
 */
extern __inline__ void
__cli(void)
{
	__asm__ __volatile__(
8000c308:	40016000 	mfc0	at,c0_status
8000c30c:	34210001 	ori	at,at,0x1
8000c310:	38210001 	xori	at,at,0x1
8000c314:	40816000 	mtc0	at,c0_status
8000c318:	000000c0 	ehb
	...
		cli();
		flush_cache(); 
8000c328:	0c00187c 	jal	800061f0 <flush_cache>
8000c32c:	00000000 	nop
		jump();				 // jump to start
8000c330:	0200f809 	jalr	s0
8000c334:	00000000 	nop
		return ;
	}
	return;
}
8000c338:	8fbf0014 	lw	ra,20(sp)
8000c33c:	8fb00010 	lw	s0,16(sp)
8000c340:	03e00008 	jr	ra
8000c344:	27bd0018 	addiu	sp,sp,24

8000c348 <doBooting>:
#define RTL_8198CS 0x80
#define RTL_8954ES 0x83


void doBooting(int flag, unsigned long addr, IMG_HEADER_Tp pheader)
{
8000c348:	27bdffe0 	addiu	sp,sp,-32
8000c34c:	afbf001c 	sw	ra,28(sp)
8000c350:	afb20018 	sw	s2,24(sp)
8000c354:	afb10014 	sw	s1,20(sp)
8000c358:	afb00010 	sw	s0,16(sp)
8000c35c:	00a08021 	move	s0,a1
8000c360:	00c08821 	move	s1,a2
	unsigned int id = REG32(0xb800000c) & 0xff;
8000c364:	3c02b800 	lui	v0,0xb800
8000c368:	3442000c 	ori	v0,v0,0xc
8000c36c:	8c520000 	lw	s2,0(v0)
#ifdef SUPPORT_TFTP_CLIENT	
	extern int check_tftp_client_state();

	if(flag || check_tftp_client_state() >= 0)
#else
	if(flag)
8000c370:	1080002e 	beqz	a0,8000c42c <doBooting+0xe4>
8000c374:	3c043b02 	lui	a0,0x3b02
#endif
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
8000c378:	0c003084 	jal	8000c210 <user_interrupt>
8000c37c:	34843380 	ori	a0,a0,0x3380
8000c380:	24030001 	li	v1,1
8000c384:	1043001f 	beq	v0,v1,8000c404 <doBooting+0xbc>
8000c388:	325200ff 	andi	s2,s2,0xff
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
8000c38c:	12400007 	beqz	s2,8000c3ac <doBooting+0x64>
8000c390:	24020080 	li	v0,128
8000c394:	12420005 	beq	s2,v0,8000c3ac <doBooting+0x64>
8000c398:	24020003 	li	v0,3
8000c39c:	12420003 	beq	s2,v0,8000c3ac <doBooting+0x64>
8000c3a0:	24020083 	li	v0,131
8000c3a4:	16420006 	bne	s2,v0,8000c3c0 <doBooting+0x78>
8000c3a8:	24020002 	li	v0,2
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
8000c3ac:	2404000b 	li	a0,11
8000c3b0:	0c002854 	jal	8000a150 <SettingCPUClk>
8000c3b4:	00002821 	move	a1,zero
	{
		switch(user_interrupt(WAIT_TIME_USER_INTERRUPT))
		{
		case LOCALSTART_MODE:
		default:
			if ((id==RTL_8198C)||(id==RTL_8198CS||(id==RTL_8954E)||(id==RTL_8954ES)))
8000c3b8:	080030fa 	j	8000c3e8 <doBooting+0xa0>
8000c3bc:	00002021 	move	a0,zero
			{
				SettingCPUClk(0xb,0);      //chg f1000MHz
			}
			else if (id==RTL_8198CD)
8000c3c0:	16420005 	bne	s2,v0,8000c3d8 <doBooting+0x90>
8000c3c4:	24040003 	li	a0,3
			{
				SettingCPUClk(3,0);      //chg f600MHz	
8000c3c8:	0c002854 	jal	8000a150 <SettingCPUClk>
8000c3cc:	00002821 	move	a1,zero
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
			}
			CmdCore1Wakeup(0,NULL);		
8000c3d0:	080030fa 	j	8000c3e8 <doBooting+0xa0>
8000c3d4:	00002021 	move	a0,zero
			{
				SettingCPUClk(3,0);      //chg f600MHz	
			}
			else
			{
				SettingCPUClk(0x7,0);      //chg f800MHz			
8000c3d8:	24040007 	li	a0,7
8000c3dc:	0c002854 	jal	8000a150 <SettingCPUClk>
8000c3e0:	00002821 	move	a1,zero
			}
			CmdCore1Wakeup(0,NULL);		
8000c3e4:	00002021 	move	a0,zero
8000c3e8:	0c0020f4 	jal	800083d0 <CmdCore1Wakeup>
8000c3ec:	00002821 	move	a1,zero
			if (!flag) {
				REG32(GIMR_REG)=0x0;   //add by jiawenjian
				goToDownMode(); 	
			}	
#endif			
			goToLocalStartMode(addr,pheader);
8000c3f0:	02002021 	move	a0,s0
8000c3f4:	0c00308f 	jal	8000c23c <goToLocalStartMode>
8000c3f8:	02202821 	move	a1,s1
			break;
8000c3fc:	08003113 	j	8000c44c <doBooting+0x104>
8000c400:	8fbf001c 	lw	ra,28(sp)
			
		case DOWN_MODE:
		 	CmdCore1Wakeup(0,NULL);	
8000c404:	00002021 	move	a0,zero
8000c408:	0c0020f4 	jal	800083d0 <CmdCore1Wakeup>
8000c40c:	00002821 	move	a1,zero
			dprintf("\n---Escape booting by user\n");	
8000c410:	3c048001 	lui	a0,0x8001
8000c414:	0c001cc1 	jal	80007304 <dprintf>
8000c418:	24841ec0 	addiu	a0,a0,7872
                         REG32(0xb800311c)=0xa5000000 ;
        		 #endif
			#ifdef CONFIG_NAND_FLASH
			REG32(0xb8019004) = 0;
			#endif
			goToDownMode();	
8000c41c:	0c00306e 	jal	8000c1b8 <goToDownMode>
8000c420:	00000000 	nop
		REG32(0xb8019004) = 0;
		#endif
		goToDownMode();		
	}
	return;
}
8000c424:	08003113 	j	8000c44c <doBooting+0x104>
8000c428:	8fbf001c 	lw	ra,28(sp)
		}/*switch case */
	}/*if image correct*/
	else
#endif //CONFIG_NFBI
	{
		CmdCore1Wakeup(0,NULL);		
8000c42c:	00002021 	move	a0,zero
8000c430:	0c0020f4 	jal	800083d0 <CmdCore1Wakeup>
8000c434:	00002821 	move	a1,zero
		flush_cache();
8000c438:	0c00187c 	jal	800061f0 <flush_cache>
8000c43c:	00000000 	nop
                 #endif	
		//REG32(GIMR_REG)=0x0;   //add by jiawenjian
		#ifdef CONFIG_NAND_FLASH
		REG32(0xb8019004) = 0;
		#endif
		goToDownMode();		
8000c440:	0c00306e 	jal	8000c1b8 <goToDownMode>
8000c444:	00000000 	nop
	}
	return;
}
8000c448:	8fbf001c 	lw	ra,28(sp)
8000c44c:	8fb20018 	lw	s2,24(sp)
8000c450:	8fb10014 	lw	s1,20(sp)
8000c454:	8fb00010 	lw	s0,16(sp)
8000c458:	03e00008 	jr	ra
8000c45c:	27bd0020 	addiu	sp,sp,32

8000c460 <check_rootfs_image>:
	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
{
8000c460:	27bdffb8 	addiu	sp,sp,-72
8000c464:	afbf0044 	sw	ra,68(sp)
8000c468:	afbe0040 	sw	s8,64(sp)
8000c46c:	afb7003c 	sw	s7,60(sp)
8000c470:	afb60038 	sw	s6,56(sp)
8000c474:	afb50034 	sw	s5,52(sp)
8000c478:	afb40030 	sw	s4,48(sp)
8000c47c:	afb3002c 	sw	s3,44(sp)
8000c480:	afb20028 	sw	s2,40(sp)
8000c484:	afb10024 	sw	s1,36(sp)
8000c488:	afb00020 	sw	s0,32(sp)
	unsigned long length=0;
	unsigned char tmpbuf[16];	
	

	
	if(gCHKKEY_HIT==1)
8000c48c:	3c028001 	lui	v0,0x8001
8000c490:	8c434150 	lw	v1,16720(v0)
8000c494:	24020001 	li	v0,1
8000c498:	10620044 	beq	v1,v0,8000c5ac <check_rootfs_image+0x14c>
8000c49c:	0080f021 	move	s8,a0
	{
		*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
	}
			
#else
	word_ptr = (unsigned short *)tmpbuf;
8000c4a0:	27a20010 	addiu	v0,sp,16
8000c4a4:	3c14b800 	lui	s4,0xb800
8000c4a8:	0094a021 	addu	s4,a0,s4

	return (ret);
}
//------------------------------------------------------------------------------------------

int check_rootfs_image(unsigned long addr)
8000c4ac:	27a50020 	addiu	a1,sp,32
8000c4b0:	02801821 	move	v1,s4
	}
			
#else
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);
8000c4b4:	94640000 	lhu	a0,0(v1)
8000c4b8:	a4440000 	sh	a0,0(v0)
		*word_ptr = ((*(ptr_data+1+i))|*(ptr_data+i)<<8)&0xffff;
	}
			
#else
	word_ptr = (unsigned short *)tmpbuf;
	for (i=0; i<16; i+=2, word_ptr++)
8000c4bc:	24420002 	addiu	v0,v0,2
8000c4c0:	1445fffc 	bne	v0,a1,8000c4b4 <check_rootfs_image+0x54>
8000c4c4:	24630002 	addiu	v1,v1,2
		*word_ptr = rtl_inw(addr + i);
#endif

	if ( memcmp(tmpbuf, SQSH_SIGNATURE, SIG_LEN) && memcmp(tmpbuf, SQSH_SIGNATURE_LE, SIG_LEN)) {
8000c4c8:	27a40010 	addiu	a0,sp,16
8000c4cc:	3c058001 	lui	a1,0x8001
8000c4d0:	24a50180 	addiu	a1,a1,384
8000c4d4:	0c0019ed 	jal	800067b4 <memcmp>
8000c4d8:	24060004 	li	a2,4
8000c4dc:	1040000f 	beqz	v0,8000c51c <check_rootfs_image+0xbc>
8000c4e0:	8fb50018 	lw	s5,24(sp)
8000c4e4:	27a40010 	addiu	a0,sp,16
8000c4e8:	3c058001 	lui	a1,0x8001
8000c4ec:	24a51edc 	addiu	a1,a1,7900
8000c4f0:	0c0019ed 	jal	800067b4 <memcmp>
8000c4f4:	24060004 	li	a2,4
8000c4f8:	10400008 	beqz	v0,8000c51c <check_rootfs_image+0xbc>
8000c4fc:	8fb50018 	lw	s5,24(sp)
		prom_printf("no rootfs signature at %X!\n",addr-FLASH_BASE);
8000c500:	3c048001 	lui	a0,0x8001
8000c504:	24841ee4 	addiu	a0,a0,7908
8000c508:	3c05fb00 	lui	a1,0xfb00
8000c50c:	0c001d43 	jal	8000750c <prom_printf>
8000c510:	03c52821 	addu	a1,s8,a1
		return 0;
8000c514:	0800316e 	j	8000c5b8 <check_rootfs_image+0x158>
8000c518:	00001021 	move	v0,zero
	}

#if CHECK_BURN_SERIAL
	board_rootfs_length =
#endif
	length = *(((unsigned long *)tmpbuf) + OFFSET_OF_LEN) + SIZE_OF_SQFS_SUPER_BLOCK + SIZE_OF_CHECKSUM;
8000c51c:	26b50282 	addiu	s5,s5,642
			}
			#endif
			
#else

	for (i=0; i<length; i+=2) {
8000c520:	12a00024 	beqz	s5,8000c5b4 <check_rootfs_image+0x154>
8000c524:	00009821 	move	s3,zero
8000c528:	00009021 	move	s2,zero
8000c52c:	00008021 	move	s0,zero
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
8000c530:	3c118001 	lui	s1,0x8001
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000c534:	3c160002 	lui	s6,0x2
8000c538:	36d60001 	ori	s6,s6,0x1
			{	gCHKKEY_CNT=0;
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000c53c:	24170001 	li	s7,1
	for (i=0; i<length; i+=2) {
#if 1  //slowly
                 #if CONFIG_ESD_SUPPORT//patch for ESD
                  	 REG32(0xb800311c)|= (1<<23);
                  #endif
			gCHKKEY_CNT++;
8000c540:	8e224154 	lw	v0,16724(s1)
8000c544:	24420001 	addiu	v0,v0,1
8000c548:	ae224154 	sw	v0,16724(s1)
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000c54c:	0056102b 	sltu	v0,v0,s6
8000c550:	14400006 	bnez	v0,8000c56c <check_rootfs_image+0x10c>
8000c554:	00000000 	nop
			{	gCHKKEY_CNT=0;
8000c558:	ae204154 	sw	zero,16724(s1)
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000c55c:	0c003084 	jal	8000c210 <user_interrupt>
8000c560:	00002021 	move	a0,zero
8000c564:	10570014 	beq	v0,s7,8000c5b8 <check_rootfs_image+0x158>
8000c568:	00001021 	move	v0,zero
			{	gCHKKEY_HIT=1; 
				return 0;
			}
#endif			
#if defined(NEED_CHKSUM)	
		sum += rtl_inw(addr + i);
8000c56c:	02939821 	addu	s3,s4,s3
8000c570:	96620000 	lhu	v0,0(s3)
8000c574:	02429021 	addu	s2,s2,v0
8000c578:	3252ffff 	andi	s2,s2,0xffff
			}
			#endif
			
#else

	for (i=0; i<length; i+=2) {
8000c57c:	26100002 	addiu	s0,s0,2
8000c580:	0215102b 	sltu	v0,s0,s5
8000c584:	1440ffee 	bnez	v0,8000c540 <check_rootfs_image+0xe0>
8000c588:	02009821 	move	s3,s0
#endif
	}
#endif

#if defined(NEED_CHKSUM)		
	if ( sum ) {
8000c58c:	12400009 	beqz	s2,8000c5b4 <check_rootfs_image+0x154>
8000c590:	3c048001 	lui	a0,0x8001
		prom_printf("rootfs checksum error at %X!\n",addr-FLASH_BASE);
8000c594:	24841f00 	addiu	a0,a0,7936
8000c598:	3c05fb00 	lui	a1,0xfb00
8000c59c:	0c001d43 	jal	8000750c <prom_printf>
8000c5a0:	03c52821 	addu	a1,s8,a1
		return 0;
8000c5a4:	0800316e 	j	8000c5b8 <check_rootfs_image+0x158>
8000c5a8:	00001021 	move	v0,zero
8000c5ac:	0800316e 	j	8000c5b8 <check_rootfs_image+0x158>
8000c5b0:	00001021 	move	v0,zero
8000c5b4:	24020001 	li	v0,1
	}	
#endif	
	return 1;
#endif //CONFIG_RTK_VOIP
}
8000c5b8:	8fbf0044 	lw	ra,68(sp)
8000c5bc:	8fbe0040 	lw	s8,64(sp)
8000c5c0:	8fb7003c 	lw	s7,60(sp)
8000c5c4:	8fb60038 	lw	s6,56(sp)
8000c5c8:	8fb50034 	lw	s5,52(sp)
8000c5cc:	8fb40030 	lw	s4,48(sp)
8000c5d0:	8fb3002c 	lw	s3,44(sp)
8000c5d4:	8fb20028 	lw	s2,40(sp)
8000c5d8:	8fb10024 	lw	s1,36(sp)
8000c5dc:	8fb00020 	lw	s0,32(sp)
8000c5e0:	03e00008 	jr	ra
8000c5e4:	27bd0048 	addiu	sp,sp,72

8000c5e8 <check_system_image>:
	return ret;
}
#endif
// return,  0: not found, 1: linux found, 2:linux with root found
int check_system_image(unsigned long addr,IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp setting_header)
{
8000c5e8:	27bdffc0 	addiu	sp,sp,-64
8000c5ec:	afbf003c 	sw	ra,60(sp)
8000c5f0:	afbe0038 	sw	s8,56(sp)
8000c5f4:	afb70034 	sw	s7,52(sp)
8000c5f8:	afb60030 	sw	s6,48(sp)
8000c5fc:	afb5002c 	sw	s5,44(sp)
8000c600:	afb40028 	sw	s4,40(sp)
8000c604:	afb30024 	sw	s3,36(sp)
8000c608:	afb20020 	sw	s2,32(sp)
8000c60c:	afb1001c 	sw	s1,28(sp)
8000c610:	afb00018 	sw	s0,24(sp)
8000c614:	0080f021 	move	s8,a0
	unsigned short temp16=0;
	char image_sig_check[1]={0};
	char image_sig[4]={0};
	char image_sig_root[4]={0};
	
	if(gCHKKEY_HIT==1)
8000c618:	3c028001 	lui	v0,0x8001
8000c61c:	8c434150 	lw	v1,16720(v0)
8000c620:	24020001 	li	v0,1
8000c624:	1062004a 	beq	v1,v0,8000c750 <check_system_image+0x168>
8000c628:	00a08821 	move	s1,a1
	int i, ret=0;
	unsigned short sum=0, *word_ptr;
	unsigned short length=0;
	unsigned short temp16=0;
	char image_sig_check[1]={0};
	char image_sig[4]={0};
8000c62c:	afa00010 	sw	zero,16(sp)
	char image_sig_root[4]={0};
8000c630:	afa00014 	sw	zero,20(sp)
8000c634:	00001821 	move	v1,zero
8000c638:	00001021 	move	v0,zero
#else

        /*check firmware image.*/
	word_ptr = (unsigned short *)pHeader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
		*word_ptr = rtl_inw(addr + i);	
8000c63c:	3c06b800 	lui	a2,0xb800
8000c640:	00863021 	addu	a2,a0,a2
			
#else

        /*check firmware image.*/
	word_ptr = (unsigned short *)pHeader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000c644:	24050010 	li	a1,16
		*word_ptr = rtl_inw(addr + i);	
8000c648:	00c31821 	addu	v1,a2,v1
8000c64c:	94640000 	lhu	a0,0(v1)
8000c650:	02221821 	addu	v1,s1,v0
8000c654:	a4640000 	sh	a0,0(v1)
			
#else

        /*check firmware image.*/
	word_ptr = (unsigned short *)pHeader;
	for (i=0; i<sizeof(IMG_HEADER_T); i+=2, word_ptr++)
8000c658:	24420002 	addiu	v0,v0,2
8000c65c:	1445fffa 	bne	v0,a1,8000c648 <check_system_image+0x60>
8000c660:	00401821 	move	v1,v0
		*word_ptr = rtl_inw(addr + i);	
#endif

	memcpy(image_sig, FW_SIGNATURE, SIG_LEN);
8000c664:	3c028001 	lui	v0,0x8001
8000c668:	8c4202c4 	lw	v0,708(v0)
8000c66c:	afa20010 	sw	v0,16(sp)
	memcpy(image_sig_root, FW_SIGNATURE_WITH_ROOT, SIG_LEN);
8000c670:	3c028001 	lui	v0,0x8001
8000c674:	8c4202dc 	lw	v0,732(v0)
8000c678:	afa20014 	sw	v0,20(sp)

	if (!memcmp(pHeader->signature, image_sig, SIG_LEN))
8000c67c:	02202021 	move	a0,s1
8000c680:	27a50010 	addiu	a1,sp,16
8000c684:	0c0019ed 	jal	800067b4 <memcmp>
8000c688:	24060004 	li	a2,4
8000c68c:	1040000e 	beqz	v0,8000c6c8 <check_system_image+0xe0>
8000c690:	24170001 	li	s7,1
		ret=1;
	else if  (!memcmp(pHeader->signature, image_sig_root, SIG_LEN))
8000c694:	02202021 	move	a0,s1
8000c698:	27a50014 	addiu	a1,sp,20
8000c69c:	0c0019ed 	jal	800067b4 <memcmp>
8000c6a0:	24060004 	li	a2,4
8000c6a4:	10400008 	beqz	v0,8000c6c8 <check_system_image+0xe0>
8000c6a8:	24170002 	li	s7,2
		ret=2;
	else{
		prom_printf("no sys signature at %X!\n",addr-FLASH_BASE);
8000c6ac:	3c048001 	lui	a0,0x8001
8000c6b0:	24841f20 	addiu	a0,a0,7968
8000c6b4:	3c05fb00 	lui	a1,0xfb00
8000c6b8:	0c001d43 	jal	8000750c <prom_printf>
8000c6bc:	03c52821 	addu	a1,s8,a1
8000c6c0:	080031d5 	j	8000c754 <check_system_image+0x16c>
8000c6c4:	0000b821 	move	s7,zero
			
			}
			#endif
			
#else
		for (i=0; i<pHeader->len; i+=2) {
8000c6c8:	8e22000c 	lw	v0,12(s1)
8000c6cc:	10400021 	beqz	v0,8000c754 <check_system_image+0x16c>
8000c6d0:	0000a021 	move	s4,zero
8000c6d4:	00009821 	move	s3,zero
8000c6d8:	00008021 	move	s0,zero
#if 1  //slowly
			gCHKKEY_CNT++;
8000c6dc:	3c128001 	lui	s2,0x8001
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000c6e0:	3c150002 	lui	s5,0x2
8000c6e4:	36b50001 	ori	s5,s5,0x1
			{	gCHKKEY_HIT=1; 
				return 0;
			}
#endif
#if defined(NEED_CHKSUM)	
			sum += rtl_inw(addr + sizeof(IMG_HEADER_T) + i);
8000c6e8:	3c16b800 	lui	s6,0xb800
8000c6ec:	36d60010 	ori	s6,s6,0x10
8000c6f0:	03d6b021 	addu	s6,s8,s6
			#endif
			
#else
		for (i=0; i<pHeader->len; i+=2) {
#if 1  //slowly
			gCHKKEY_CNT++;
8000c6f4:	8e424154 	lw	v0,16724(s2)
8000c6f8:	24420001 	addiu	v0,v0,1
8000c6fc:	ae424154 	sw	v0,16724(s2)
			if( gCHKKEY_CNT>ACCCNT_TOCHKKEY)
8000c700:	0055102b 	sltu	v0,v0,s5
8000c704:	14400007 	bnez	v0,8000c724 <check_system_image+0x13c>
8000c708:	00000000 	nop
			{	gCHKKEY_CNT=0;
8000c70c:	ae404154 	sw	zero,16724(s2)
				if ( user_interrupt(0)==1 )  //return 1: got ESC Key
8000c710:	0c003084 	jal	8000c210 <user_interrupt>
8000c714:	00002021 	move	a0,zero
8000c718:	24030001 	li	v1,1
8000c71c:	1043000c 	beq	v0,v1,8000c750 <check_system_image+0x168>
8000c720:	00000000 	nop
			{	gCHKKEY_HIT=1; 
				return 0;
			}
#endif
#if defined(NEED_CHKSUM)	
			sum += rtl_inw(addr + sizeof(IMG_HEADER_T) + i);
8000c724:	02d4a021 	addu	s4,s6,s4
8000c728:	96820000 	lhu	v0,0(s4)
8000c72c:	02629821 	addu	s3,s3,v0
8000c730:	3273ffff 	andi	s3,s3,0xffff
			
			}
			#endif
			
#else
		for (i=0; i<pHeader->len; i+=2) {
8000c734:	26100002 	addiu	s0,s0,2
8000c738:	8e22000c 	lw	v0,12(s1)
8000c73c:	0202102b 	sltu	v0,s0,v0
8000c740:	1440ffec 	bnez	v0,8000c6f4 <check_system_image+0x10c>
8000c744:	0200a021 	move	s4,s0
#endif
		}	
#endif

#if defined(NEED_CHKSUM)			
		if ( sum ) {
8000c748:	12600003 	beqz	s3,8000c758 <check_system_image+0x170>
8000c74c:	02e01021 	move	v0,s7
8000c750:	0000b821 	move	s7,zero
#endif		
	}
	//prom_printf("ret=%d  sys signature at %X!\n",ret,addr-FLASH_BASE);

	return (ret);
}
8000c754:	02e01021 	move	v0,s7
8000c758:	8fbf003c 	lw	ra,60(sp)
8000c75c:	8fbe0038 	lw	s8,56(sp)
8000c760:	8fb70034 	lw	s7,52(sp)
8000c764:	8fb60030 	lw	s6,48(sp)
8000c768:	8fb5002c 	lw	s5,44(sp)
8000c76c:	8fb40028 	lw	s4,40(sp)
8000c770:	8fb30024 	lw	s3,36(sp)
8000c774:	8fb20020 	lw	s2,32(sp)
8000c778:	8fb1001c 	lw	s1,28(sp)
8000c77c:	8fb00018 	lw	s0,24(sp)
8000c780:	03e00008 	jr	ra
8000c784:	27bd0040 	addiu	sp,sp,64

8000c788 <check_image>:
#endif

//------------------------------------------------------------------------------------------

int check_image(IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp psetting_header)
{
8000c788:	27bdffc8 	addiu	sp,sp,-56
8000c78c:	afbf0034 	sw	ra,52(sp)
8000c790:	afbe0030 	sw	s8,48(sp)
8000c794:	afb7002c 	sw	s7,44(sp)
8000c798:	afb60028 	sw	s6,40(sp)
8000c79c:	afb50024 	sw	s5,36(sp)
8000c7a0:	afb40020 	sw	s4,32(sp)
8000c7a4:	afb3001c 	sw	s3,28(sp)
8000c7a8:	afb20018 	sw	s2,24(sp)
8000c7ac:	afb10014 	sw	s1,20(sp)
8000c7b0:	afb00010 	sw	s0,16(sp)
8000c7b4:	0080f021 	move	s8,a0
8000c7b8:	00a0b821 	move	s7,a1
static int check_image_header(IMG_HEADER_Tp pHeader,SETTING_HEADER_Tp psetting_header,unsigned long bank_offset)
{
	int i,ret=0;
#ifndef CONFIG_NAND_FLASH_BOOTING
	//flash mapping
	return_addr = (unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET+bank_offset;
8000c7bc:	3c030501 	lui	v1,0x501
8000c7c0:	3c028001 	lui	v0,0x8001
8000c7c4:	ac4331bc 	sw	v1,12732(v0)
	ret = check_system_image((unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET+bank_offset,pHeader, psetting_header);
8000c7c8:	3c040501 	lui	a0,0x501
8000c7cc:	03c02821 	move	a1,s8
8000c7d0:	0c00317a 	jal	8000c5e8 <check_system_image>
8000c7d4:	02e03021 	move	a2,s7

	if(ret==0) {
8000c7d8:	14400027 	bnez	v0,8000c878 <check_image+0xf0>
8000c7dc:	24030002 	li	v1,2
		return_addr = (unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET2+bank_offset;		
8000c7e0:	3c030502 	lui	v1,0x502
8000c7e4:	3c028001 	lui	v0,0x8001
8000c7e8:	ac4331bc 	sw	v1,12732(v0)
		ret=check_system_image((unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET2+bank_offset,  pHeader, psetting_header);
8000c7ec:	3c040502 	lui	a0,0x502
8000c7f0:	03c02821 	move	a1,s8
8000c7f4:	0c00317a 	jal	8000c5e8 <check_system_image>
8000c7f8:	02e03021 	move	a2,s7
	}
	if(ret==0) {
8000c7fc:	1440001d 	bnez	v0,8000c874 <check_image+0xec>
8000c800:	3c030503 	lui	v1,0x503
		return_addr = (unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET3+bank_offset;				
8000c804:	3c028001 	lui	v0,0x8001
8000c808:	ac4331bc 	sw	v1,12732(v0)
		ret=check_system_image((unsigned long)FLASH_BASE+CODE_IMAGE_OFFSET3+bank_offset,  pHeader, psetting_header);
8000c80c:	3c040503 	lui	a0,0x503
8000c810:	03c02821 	move	a1,s8
8000c814:	0c00317a 	jal	8000c5e8 <check_system_image>
8000c818:	02e03021 	move	a2,s7
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
8000c81c:	14400016 	bnez	v0,8000c878 <check_image+0xf0>
8000c820:	24030002 	li	v1,2
8000c824:	3c100001 	lui	s0,0x1
8000c828:	3c110500 	lui	s1,0x500
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
8000c82c:	3c128001 	lui	s2,0x8001
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
8000c830:	3c130001 	lui	s3,0x1
8000c834:	3c150002 	lui	s5,0x2
8000c838:	3c160003 	lui	s6,0x3
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
8000c83c:	3c140008 	lui	s4,0x8
8000c840:	02112021 	addu	a0,s0,s1
	{
		return_addr=(unsigned long)FLASH_BASE+i+bank_offset; 
		if(CODE_IMAGE_OFFSET == i || CODE_IMAGE_OFFSET2 == i || CODE_IMAGE_OFFSET3 == i){
8000c844:	12130007 	beq	s0,s3,8000c864 <check_image+0xdc>
8000c848:	ae4431bc 	sw	a0,12732(s2)
8000c84c:	12150005 	beq	s0,s5,8000c864 <check_image+0xdc>
8000c850:	00000000 	nop
8000c854:	12160003 	beq	s0,s6,8000c864 <check_image+0xdc>
8000c858:	03c02821 	move	a1,s8
			i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
			continue;
		}
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
8000c85c:	0c00317a 	jal	8000c5e8 <check_system_image>
8000c860:	02e03021 	move	a2,s7
	}			
#endif

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
	i=CONFIG_LINUX_IMAGE_OFFSET_START;	
	while(i<=CONFIG_LINUX_IMAGE_OFFSET_END && (0==ret))
8000c864:	12140004 	beq	s0,s4,8000c878 <check_image+0xf0>
8000c868:	24030002 	li	v1,2
8000c86c:	1040fff4 	beqz	v0,8000c840 <check_image+0xb8>
8000c870:	26101000 	addiu	s0,s0,4096
		ret = check_system_image((unsigned long)FLASH_BASE+i+bank_offset, pHeader, psetting_header);
		i += CONFIG_LINUX_IMAGE_OFFSET_STEP; 
	}
#endif

	if(ret==2)
8000c874:	24030002 	li	v1,2
8000c878:	1443001f 	bne	v0,v1,8000c8f8 <check_image+0x170>
8000c87c:	8fbf0034 	lw	ra,52(sp)
        {
#ifndef CONFIG_NAND_FLASH_BOOTING
                ret=check_rootfs_image((unsigned long)FLASH_BASE+ROOT_FS_OFFSET+bank_offset);
8000c880:	0c003118 	jal	8000c460 <check_rootfs_image>
8000c884:	3c04050e 	lui	a0,0x50e
                if(ret==0)
8000c888:	1440001b 	bnez	v0,8000c8f8 <check_image+0x170>
8000c88c:	8fbf0034 	lw	ra,52(sp)
                	ret=check_rootfs_image((unsigned long)FLASH_BASE+ROOT_FS_OFFSET+ROOT_FS_OFFSET_OP1+bank_offset);
8000c890:	0c003118 	jal	8000c460 <check_rootfs_image>
8000c894:	3c04050f 	lui	a0,0x50f
                if(ret==0)
8000c898:	14400017 	bnez	v0,8000c8f8 <check_image+0x170>
8000c89c:	8fbf0034 	lw	ra,52(sp)
                	ret=check_rootfs_image((unsigned long)FLASH_BASE+ROOT_FS_OFFSET+ROOT_FS_OFFSET_OP1+ROOT_FS_OFFSET_OP2+bank_offset);
8000c8a0:	0c003118 	jal	8000c460 <check_rootfs_image>
8000c8a4:	3c040513 	lui	a0,0x513
				ret = 0;
#endif	

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
		i = CONFIG_ROOT_IMAGE_OFFSET_START;
		while((i <= CONFIG_ROOT_IMAGE_OFFSET_END) && (0==ret))
8000c8a8:	14400012 	bnez	v0,8000c8f4 <check_image+0x16c>
8000c8ac:	3c100010 	lui	s0,0x10
		{
			if( ROOT_FS_OFFSET == i ||
8000c8b0:	3c11000e 	lui	s1,0xe
8000c8b4:	3c13000f 	lui	s3,0xf
8000c8b8:	3c140013 	lui	s4,0x13
			    (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1) == i ||
		            (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1 + ROOT_FS_OFFSET_OP2) == i){
				i += CONFIG_ROOT_IMAGE_OFFSET_STEP;
				continue;
			}
			ret = check_rootfs_image((unsigned long)FLASH_BASE+i+bank_offset);
8000c8bc:	3c150500 	lui	s5,0x500
				ret = 0;
#endif	

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
		i = CONFIG_ROOT_IMAGE_OFFSET_START;
		while((i <= CONFIG_ROOT_IMAGE_OFFSET_END) && (0==ret))
8000c8c0:	3c120020 	lui	s2,0x20
		{
			if( ROOT_FS_OFFSET == i ||
8000c8c4:	12110007 	beq	s0,s1,8000c8e4 <check_image+0x15c>
8000c8c8:	00000000 	nop
8000c8cc:	12130005 	beq	s0,s3,8000c8e4 <check_image+0x15c>
8000c8d0:	00000000 	nop
8000c8d4:	12140003 	beq	s0,s4,8000c8e4 <check_image+0x15c>
8000c8d8:	00000000 	nop
			    (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1) == i ||
		            (ROOT_FS_OFFSET + ROOT_FS_OFFSET_OP1 + ROOT_FS_OFFSET_OP2) == i){
				i += CONFIG_ROOT_IMAGE_OFFSET_STEP;
				continue;
			}
			ret = check_rootfs_image((unsigned long)FLASH_BASE+i+bank_offset);
8000c8dc:	0c003118 	jal	8000c460 <check_rootfs_image>
8000c8e0:	02152021 	addu	a0,s0,s5
				ret = 0;
#endif	

#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
		i = CONFIG_ROOT_IMAGE_OFFSET_START;
		while((i <= CONFIG_ROOT_IMAGE_OFFSET_END) && (0==ret))
8000c8e4:	12120004 	beq	s0,s2,8000c8f8 <check_image+0x170>
8000c8e8:	8fbf0034 	lw	ra,52(sp)
8000c8ec:	1040fff5 	beqz	v0,8000c8c4 <check_image+0x13c>
8000c8f0:	26101000 	addiu	s0,s0,4096
 	#else
       	ret = check_dualbank_setting(IN_BOOTING_MODE);
	#endif
#endif //end of NFBI else
	return ret;
}
8000c8f4:	8fbf0034 	lw	ra,52(sp)
8000c8f8:	8fbe0030 	lw	s8,48(sp)
8000c8fc:	8fb7002c 	lw	s7,44(sp)
8000c900:	8fb60028 	lw	s6,40(sp)
8000c904:	8fb50024 	lw	s5,36(sp)
8000c908:	8fb40020 	lw	s4,32(sp)
8000c90c:	8fb3001c 	lw	s3,28(sp)
8000c910:	8fb20018 	lw	s2,24(sp)
8000c914:	8fb10014 	lw	s1,20(sp)
8000c918:	8fb00010 	lw	s0,16(sp)
8000c91c:	03e00008 	jr	ra
8000c920:	27bd0038 	addiu	sp,sp,56
	...

8000c930 <__delay>:
//------------------------------------------------------------------------------

__inline__ void
__delay(unsigned long loops)
{
	__asm__ __volatile__ (
8000c930:	1480ffff 	bnez	a0,8000c930 <__delay>
8000c934:	2484ffff 	addiu	a0,a0,-1
		"1:\tbnez\t%0,1b\n\t"
		"subu\t%0,1\n\t"
		".set\treorder"
		:"=r" (loops)
		:"0" (loops));
}
8000c938:	03e00008 	jr	ra
8000c93c:	00000000 	nop

8000c940 <timer_interrupt>:
static void timer_interrupt(int num, void *ptr, struct pt_regs * reg)
{
	//dprintf("jiff=%x\r\n",jiffies);
	//flush_WBcache();
	//rtl_outl(TCIR,rtl_inl(TCIR));
	REG32(TCIR_REG)|=(1<<29);
8000c940:	3c02b800 	lui	v0,0xb800
8000c944:	34423114 	ori	v0,v0,0x3114
8000c948:	8c440000 	lw	a0,0(v0)
8000c94c:	3c032000 	lui	v1,0x2000
8000c950:	00831825 	or	v1,a0,v1
8000c954:	ac430000 	sw	v1,0(v0)

	//if(jiffies==0x80)
	//REG32(GIMR_REG)&= ~(1<<8);
	
	jiffies++;
8000c958:	3c028001 	lui	v0,0x8001
8000c95c:	8c434160 	lw	v1,16736(v0)
8000c960:	24630001 	addiu	v1,v1,1
8000c964:	ac434160 	sw	v1,16736(v0)


}
8000c968:	03e00008 	jr	ra
8000c96c:	00000000 	nop

8000c970 <get_timer_jiffies>:
volatile unsigned int get_timer_jiffies(void)
{

	return jiffies;
8000c970:	3c028001 	lui	v0,0x8001
8000c974:	8c424160 	lw	v0,16736(v0)
};
8000c978:	03e00008 	jr	ra
8000c97c:	00000000 	nop

8000c980 <timer_init>:

//------------------------------------------------------------------------------
void timer_init(unsigned long lexra_clock)
{
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (0<<31) | (0<<30);	//using time0
8000c980:	3c02b800 	lui	v0,0xb800
8000c984:	34433110 	ori	v1,v0,0x3110
8000c988:	ac600000 	sw	zero,0(v1)
    //REG32(TCCNR_REG) = (1<<31) | (0<<30);	//using counter0

	#define DIVISOR     0xE
	#define DIVF_OFFSET                         16		
    REG32(CDBR_REG) = (DIVISOR) << DIVF_OFFSET;
8000c98c:	34453118 	ori	a1,v0,0x3118
8000c990:	3c06000e 	lui	a2,0xe
8000c994:	aca60000 	sw	a2,0(a1)
	#define TICK_10MS_FREQ  100  /* 100 Hz */
	#define TICK_1MS_FREQ   1000 /* 1K Hz */
	
	#define TICK_FREQ       TICK_10MS_FREQ	
   
      REG32(TC0DATA_REG) = (((SysClkRate / DIVISOR) / TICK_FREQ) + 1) <<4;
8000c998:	3c055d9f 	lui	a1,0x5d9f
8000c99c:	34a57391 	ori	a1,a1,0x7391
8000c9a0:	00850018 	mult	a0,a1
8000c9a4:	00002810 	mfhi	a1
8000c9a8:	00052a43 	sra	a1,a1,0x9
8000c9ac:	000427c3 	sra	a0,a0,0x1f
8000c9b0:	00a42823 	subu	a1,a1,a0
8000c9b4:	24a50001 	addiu	a1,a1,1
8000c9b8:	00052900 	sll	a1,a1,0x4
8000c9bc:	34443100 	ori	a0,v0,0x3100
8000c9c0:	ac850000 	sw	a1,0(a0)

         
    /* Set timer mode and Enable timer */
    REG32(TCCNR_REG) = (1<<31) | (1<<30);	//using time0
8000c9c4:	3c04c000 	lui	a0,0xc000
8000c9c8:	ac640000 	sw	a0,0(v1)
    //REG32(GIMR_REG) |= (1<<8);	//request_irq() will set 

    /* Set interrupt routing register */
  // RTL8198
    //REG32(IRR1_REG) = 0x00050004;  //uart:IRQ5,  time0:IRQ4
    REG32(IRR1_REG) = 0x02;  
8000c9cc:	3443300c 	ori	v1,v0,0x300c
8000c9d0:	24040002 	li	a0,2
8000c9d4:	ac640000 	sw	a0,0(v1)
   
    
    /* Enable timer interrupt */
    REG32(TCIR_REG) = (1<<31);
8000c9d8:	34423114 	ori	v0,v0,0x3114
8000c9dc:	3c038000 	lui	v1,0x8000
8000c9e0:	ac430000 	sw	v1,0(v0)
}
8000c9e4:	03e00008 	jr	ra
8000c9e8:	00000000 	nop

8000c9ec <rand2>:
    static unsigned int z = 521288629;
    static unsigned int c = 7654321;

    unsigned long long t, a= 698769069;

    x = 69069 * x + 12345;
8000c9ec:	3c048001 	lui	a0,0x8001
8000c9f0:	8c82318c 	lw	v0,12684(a0)
8000c9f4:	00022880 	sll	a1,v0,0x2
8000c9f8:	00021900 	sll	v1,v0,0x4
8000c9fc:	00a31821 	addu	v1,a1,v1
8000ca00:	00032900 	sll	a1,v1,0x4
8000ca04:	00a31823 	subu	v1,a1,v1
8000ca08:	00621023 	subu	v0,v1,v0
8000ca0c:	000218c0 	sll	v1,v0,0x3
8000ca10:	00621023 	subu	v0,v1,v0
8000ca14:	00021940 	sll	v1,v0,0x5
8000ca18:	00431021 	addu	v0,v0,v1
8000ca1c:	24423039 	addiu	v0,v0,12345
8000ca20:	ac82318c 	sw	v0,12684(a0)
    y ^= (y << 13); y ^= (y >> 17); y ^= (y << 5);
8000ca24:	3c038001 	lui	v1,0x8001
8000ca28:	8c643188 	lw	a0,12680(v1)
8000ca2c:	00043340 	sll	a2,a0,0xd
8000ca30:	00c43026 	xor	a2,a2,a0
8000ca34:	00062442 	srl	a0,a2,0x11
8000ca38:	00863026 	xor	a2,a0,a2
8000ca3c:	00062140 	sll	a0,a2,0x5
8000ca40:	00863026 	xor	a2,a0,a2
8000ca44:	ac663188 	sw	a2,12680(v1)
    t = a * z + c; c = (t >> 32); z = t;
8000ca48:	3c078001 	lui	a3,0x8001
8000ca4c:	8ce33184 	lw	v1,12676(a3)
8000ca50:	3c0429a6 	lui	a0,0x29a6
8000ca54:	34845ead 	ori	a0,a0,0x5ead
8000ca58:	00640019 	multu	v1,a0
8000ca5c:	00002812 	mflo	a1
8000ca60:	00002010 	mfhi	a0
8000ca64:	3c088001 	lui	t0,0x8001
8000ca68:	8d033180 	lw	v1,12672(t0)
8000ca6c:	00a31821 	addu	v1,a1,v1
8000ca70:	0065482b 	sltu	t1,v1,a1
8000ca74:	01242021 	addu	a0,t1,a0
8000ca78:	ad043180 	sw	a0,12672(t0)
8000ca7c:	ace33184 	sw	v1,12676(a3)
8000ca80:	00621021 	addu	v0,v1,v0

    return x + y + z;
}
8000ca84:	03e00008 	jr	ra
8000ca88:	00461021 	addu	v0,v0,a2

8000ca8c <CmdHelp>:
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
{
8000ca8c:	27bdffd8 	addiu	sp,sp,-40
8000ca90:	afbf0024 	sw	ra,36(sp)
8000ca94:	afb30020 	sw	s3,32(sp)
8000ca98:	afb2001c 	sw	s2,28(sp)
8000ca9c:	afb10018 	sw	s1,24(sp)
8000caa0:	afb00014 	sw	s0,20(sp)
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
8000caa4:	3c048001 	lui	a0,0x8001
8000caa8:	0c001cc1 	jal	80007304 <dprintf>
8000caac:	24841f3c 	addiu	a0,a0,7996
8000cab0:	3c108001 	lui	s0,0x8001
8000cab4:	26102f3c 	addiu	s0,s0,12092
#endif
};


//==============================================================================
int CmdHelp( int argc, char* argv[] )
8000cab8:	3c118001 	lui	s1,0x8001
8000cabc:	2631318c 	addiu	s1,s1,12684
    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
		{
			printf( "%s\n", MainCmdTable[i].msg );
8000cac0:	3c128001 	lui	s2,0x8001
8000cac4:	26530588 	addiu	s3,s2,1416
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
	{
		if( MainCmdTable[i].msg )
8000cac8:	8e050000 	lw	a1,0(s0)
8000cacc:	10a00003 	beqz	a1,8000cadc <CmdHelp+0x50>
8000cad0:	00000000 	nop
		{
			printf( "%s\n", MainCmdTable[i].msg );
8000cad4:	0c001cc1 	jal	80007304 <dprintf>
8000cad8:	02602021 	move	a0,s3
8000cadc:	26100010 	addiu	s0,s0,16
int CmdHelp( int argc, char* argv[] )
{
	int	i ;

    printf("----------------- COMMAND MODE HELP ------------------\n");
	for( i=0  ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000cae0:	1611fff9 	bne	s0,s1,8000cac8 <CmdHelp+0x3c>
8000cae4:	24020001 	li	v0,1
		}
	}
	/*Cyrus Tsai*/
    
	return TRUE ;
}
8000cae8:	8fbf0024 	lw	ra,36(sp)
8000caec:	8fb30020 	lw	s3,32(sp)
8000caf0:	8fb2001c 	lw	s2,28(sp)
8000caf4:	8fb10018 	lw	s1,24(sp)
8000caf8:	8fb00014 	lw	s0,20(sp)
8000cafc:	03e00008 	jr	ra
8000cb00:	27bd0028 	addiu	sp,sp,40

8000cb04 <CmdAuto>:

//---------------------------------------------------------------------------
#ifndef RTL8197B
extern int autoBurn;
int CmdAuto(int argc, char* argv[])
{
8000cb04:	27bdffe8 	addiu	sp,sp,-24
8000cb08:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;


	if(argv[0][0] == '0')
8000cb0c:	8ca20000 	lw	v0,0(a1)
8000cb10:	80430000 	lb	v1,0(v0)
8000cb14:	24020030 	li	v0,48
8000cb18:	14620004 	bne	v1,v0,8000cb2c <CmdAuto+0x28>
8000cb1c:	24030001 	li	v1,1
		autoBurn = 0 ;
8000cb20:	3c028001 	lui	v0,0x8001
8000cb24:	080032cd 	j	8000cb34 <CmdAuto+0x30>
8000cb28:	ac4027b4 	sw	zero,10164(v0)
	else
		autoBurn = 1 ;
8000cb2c:	3c028001 	lui	v0,0x8001
8000cb30:	ac4327b4 	sw	v1,10164(v0)
	printf("AutoBurning=%d\n",autoBurn);
8000cb34:	3c048001 	lui	a0,0x8001
8000cb38:	24841f74 	addiu	a0,a0,8052
8000cb3c:	3c028001 	lui	v0,0x8001
8000cb40:	0c001cc1 	jal	80007304 <dprintf>
8000cb44:	8c4527b4 	lw	a1,10164(v0)
}
8000cb48:	8fbf0014 	lw	ra,20(sp)
8000cb4c:	03e00008 	jr	ra
8000cb50:	27bd0018 	addiu	sp,sp,24

8000cb54 <YesOrNo>:

//---------------------------------------------------------------------------


int YesOrNo(void)
{
8000cb54:	27bdffe0 	addiu	sp,sp,-32
8000cb58:	afbf001c 	sw	ra,28(sp)
	unsigned char iChar[2];

	GetLine( iChar, 2,1);
8000cb5c:	27a40010 	addiu	a0,sp,16
8000cb60:	24050002 	li	a1,2
8000cb64:	0c001b2f 	jal	80006cbc <GetLine>
8000cb68:	24060001 	li	a2,1
	printf("\n");//vicadd
8000cb6c:	3c048001 	lui	a0,0x8001
8000cb70:	0c001cc1 	jal	80007304 <dprintf>
8000cb74:	24840f54 	addiu	a0,a0,3924
	if ((iChar[0] == 'Y') || (iChar[0] == 'y'))
8000cb78:	93a30010 	lbu	v1,16(sp)
8000cb7c:	24040059 	li	a0,89
8000cb80:	10640003 	beq	v1,a0,8000cb90 <YesOrNo+0x3c>
8000cb84:	24020001 	li	v0,1
8000cb88:	38620079 	xori	v0,v1,0x79
8000cb8c:	2c420001 	sltiu	v0,v0,1
		return 1;
	else
		return 0;
}
8000cb90:	8fbf001c 	lw	ra,28(sp)
8000cb94:	03e00008 	jr	ra
8000cb98:	27bd0020 	addiu	sp,sp,32

8000cb9c <monitor>:
#endif
	monitor_real(table_count);
}
#else
void monitor(void)
{
8000cb9c:	27bdff38 	addiu	sp,sp,-200
8000cba0:	afbf00c4 	sw	ra,196(sp)
8000cba4:	afbe00c0 	sw	s8,192(sp)
8000cba8:	afb700bc 	sw	s7,188(sp)
8000cbac:	afb600b8 	sw	s6,184(sp)
8000cbb0:	afb500b4 	sw	s5,180(sp)
8000cbb4:	afb400b0 	sw	s4,176(sp)
8000cbb8:	afb300ac 	sw	s3,172(sp)
8000cbbc:	afb200a8 	sw	s2,168(sp)
8000cbc0:	afb100a4 	sw	s1,164(sp)
8000cbc4:	afb000a0 	sw	s0,160(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000cbc8:	3c178001 	lui	s7,0x8001
8000cbcc:	26f70264 	addiu	s7,s7,612
8000cbd0:	3c1e8001 	lui	s8,0x8001
8000cbd4:	27de00d8 	addiu	s8,s8,216
		memset( buffer, 0, MAX_MONITOR_BUFFER );
8000cbd8:	27b40010 	addiu	s4,sp,16
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
8000cbdc:	3c168001 	lui	s6,0x8001
8000cbe0:	26d62f30 	addiu	s6,s6,12080
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000cbe4:	24130025 	li	s3,37
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000cbe8:	3c028001 	lui	v0,0x8001
8000cbec:	24421f84 	addiu	v0,v0,8068
8000cbf0:	afa20098 	sw	v0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000cbf4:	02e02021 	move	a0,s7
8000cbf8:	0c001cc1 	jal	80007304 <dprintf>
8000cbfc:	03c02821 	move	a1,s8
		memset( buffer, 0, MAX_MONITOR_BUFFER );
8000cc00:	02802021 	move	a0,s4
8000cc04:	00002821 	move	a1,zero
8000cc08:	0c0019d9 	jal	80006764 <memset>
8000cc0c:	24060080 	li	a2,128
		GetLine( buffer, MAX_MONITOR_BUFFER,1);
8000cc10:	02802021 	move	a0,s4
8000cc14:	24050080 	li	a1,128
8000cc18:	0c001b2f 	jal	80006cbc <GetLine>
8000cc1c:	24060001 	li	a2,1
		printf( "\n" );
8000cc20:	3c048001 	lui	a0,0x8001
8000cc24:	0c001cc1 	jal	80007304 <dprintf>
8000cc28:	24840f54 	addiu	a0,a0,3924
		argc = GetArgc( (const char *)buffer );
8000cc2c:	0c001ac5 	jal	80006b14 <GetArgc>
8000cc30:	02802021 	move	a0,s4
8000cc34:	0040a821 	move	s5,v0
		argv = GetArgv( (const char *)buffer );
8000cc38:	0c001afd 	jal	80006bf4 <GetArgv>
8000cc3c:	02802021 	move	a0,s4
		if( argc < 1 ) continue ;
8000cc40:	1aa0ffec 	blez	s5,8000cbf4 <monitor+0x58>
8000cc44:	00409021 	move	s2,v0
		StrUpr( argv[0] );
8000cc48:	0c001ab4 	jal	80006ad0 <StrUpr>
8000cc4c:	8c440000 	lw	a0,0(v0)
8000cc50:	02c08821 	move	s1,s6
8000cc54:	00008021 	move	s0,zero
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
		{
			
			if( ! strcmp( argv[0], MainCmdTable[i].cmd ) )
8000cc58:	8e440000 	lw	a0,0(s2)
8000cc5c:	0c0019b1 	jal	800066c4 <strcmp>
8000cc60:	8e250000 	lw	a1,0(s1)
8000cc64:	14400010 	bnez	v0,8000cca8 <monitor+0x10c>
8000cc68:	26100001 	addiu	s0,s0,1
8000cc6c:	2610ffff 	addiu	s0,s0,-1
				if (MainCmdTable[i].n_arg != (argc - 1))
					printf("%s\n", MainCmdTable[i].msg);
				else
					retval = MainCmdTable[i].func( argc - 1 , argv+1 );
#endif
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
8000cc70:	00101100 	sll	v0,s0,0x4
8000cc74:	00561021 	addu	v0,v0,s6
8000cc78:	8c420008 	lw	v0,8(v0)
8000cc7c:	26a4ffff 	addiu	a0,s5,-1
8000cc80:	0040f809 	jalr	v0
8000cc84:	26450004 	addiu	a1,s2,4
				memset(argv[0],0,sizeof(argv[0]));
8000cc88:	8e420000 	lw	v0,0(s2)
8000cc8c:	a0400000 	sb	zero,0(v0)
8000cc90:	a0400001 	sb	zero,1(v0)
8000cc94:	a0400002 	sb	zero,2(v0)
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000cc98:	1613ffd6 	bne	s0,s3,8000cbf4 <monitor+0x58>
8000cc9c:	a0400003 	sb	zero,3(v0)
8000cca0:	0800332c 	j	8000ccb0 <monitor+0x114>
8000cca4:	00000000 	nop
		printf( "\n" );
		argc = GetArgc( (const char *)buffer );
		argv = GetArgv( (const char *)buffer );
		if( argc < 1 ) continue ;
		StrUpr( argv[0] );
		for( i=0 ; i < (sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) ; i++ )
8000cca8:	1613ffeb 	bne	s0,s3,8000cc58 <monitor+0xbc>
8000ccac:	26310010 	addiu	s1,s1,16
				retval = MainCmdTable[i].func( argc - 1 , argv+1 );
				memset(argv[0],0,sizeof(argv[0]));
				break;
			}
		}
		if(i==sizeof(MainCmdTable) / sizeof(COMMAND_TABLE)) printf("Unknown command !\r\n");
8000ccb0:	0c001cc1 	jal	80007304 <dprintf>
8000ccb4:	8fa40098 	lw	a0,152(sp)
	{	
		 #if CONFIG_ESD_SUPPORT//patch for ESD
                         REG32(0xb800311c)|= (1<<23);
        	#endif
	
		printf( "%s", MAIN_PROMPT );
8000ccb8:	080032fe 	j	8000cbf8 <monitor+0x5c>
8000ccbc:	02e02021 	move	a0,s7

8000ccc0 <CmdLoad>:
#endif


//---------------------------------------------------------------------------
int CmdLoad(int argc, char* argv[])
{
8000ccc0:	27bdffe8 	addiu	sp,sp,-24
8000ccc4:	afbf0014 	sw	ra,20(sp)
	unsigned long addr;

	if(argc < 1) 
8000ccc8:	1c800007 	bgtz	a0,8000cce8 <CmdLoad+0x28>
8000cccc:	3c048001 	lui	a0,0x8001
	{
		printf("TFTP Load Addr 0x%x\n",image_address);
8000ccd0:	24841f9c 	addiu	a0,a0,8092
8000ccd4:	3c028001 	lui	v0,0x8001
8000ccd8:	0c001cc1 	jal	80007304 <dprintf>
8000ccdc:	8c452708 	lw	a1,9992(v0)
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	printf("Set TFTP Load Addr 0x%x\n",image_address);
}
8000cce0:	08003344 	j	8000cd10 <CmdLoad+0x50>
8000cce4:	24020001 	li	v0,1
		printf("TFTP Load Addr 0x%x\n",image_address);
		return 1;
	}

	
	image_address= strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000cce8:	8ca40000 	lw	a0,0(a1)
8000ccec:	00002821 	move	a1,zero
8000ccf0:	0c001a60 	jal	80006980 <strtoul>
8000ccf4:	24060010 	li	a2,16
8000ccf8:	3c038001 	lui	v1,0x8001
8000ccfc:	ac622708 	sw	v0,9992(v1)
	printf("Set TFTP Load Addr 0x%x\n",image_address);
8000cd00:	3c048001 	lui	a0,0x8001
8000cd04:	24841f98 	addiu	a0,a0,8088
8000cd08:	0c001cc1 	jal	80007304 <dprintf>
8000cd0c:	00402821 	move	a1,v0
}
8000cd10:	8fbf0014 	lw	ra,20(sp)
8000cd14:	03e00008 	jr	ra
8000cd18:	27bd0018 	addiu	sp,sp,24

8000cd1c <CmdCmp>:
		*(volatile unsigned char *)(src) = value;
	}
	
}
int CmdCmp(int argc, char* argv[])
{
8000cd1c:	27bdffd0 	addiu	sp,sp,-48
8000cd20:	afbf002c 	sw	ra,44(sp)
8000cd24:	afb50028 	sw	s5,40(sp)
8000cd28:	afb40024 	sw	s4,36(sp)
8000cd2c:	afb30020 	sw	s3,32(sp)
8000cd30:	afb2001c 	sw	s2,28(sp)
8000cd34:	afb10018 	sw	s1,24(sp)
8000cd38:	afb00014 	sw	s0,20(sp)
	unsigned long dst,src;
	unsigned long dst_value, src_value;
	unsigned int length;
	unsigned long error;

	if(argc < 3) {
8000cd3c:	28840003 	slti	a0,a0,3
8000cd40:	10800006 	beqz	a0,8000cd5c <CmdCmp+0x40>
8000cd44:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
8000cd48:	3c048001 	lui	a0,0x8001
8000cd4c:	0c001cc1 	jal	80007304 <dprintf>
8000cd50:	24841fb4 	addiu	a0,a0,8116
		}
	}
	if(!error)
		printf("No error found\n");

}
8000cd54:	08003380 	j	8000ce00 <CmdCmp+0xe4>
8000cd58:	24020001 	li	v0,1

	if(argc < 3) {
		printf("Parameters not enough!\n");
		return 1;
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000cd5c:	8ca40000 	lw	a0,0(a1)
8000cd60:	00002821 	move	a1,zero
8000cd64:	0c001a60 	jal	80006980 <strtoul>
8000cd68:	24060010 	li	a2,16
8000cd6c:	00409021 	move	s2,v0
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000cd70:	8e040004 	lw	a0,4(s0)
8000cd74:	00002821 	move	a1,zero
8000cd78:	0c001a60 	jal	80006980 <strtoul>
8000cd7c:	24060010 	li	a2,16
8000cd80:	00409821 	move	s3,v0
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
8000cd84:	8e040008 	lw	a0,8(s0)
8000cd88:	00002821 	move	a1,zero
8000cd8c:	0c001a60 	jal	80006980 <strtoul>
8000cd90:	24060010 	li	a2,16
	error = 0;
	for(i=0;i<length;i+=4) {
8000cd94:	10400017 	beqz	v0,8000cdf4 <CmdCmp+0xd8>
8000cd98:	00408821 	move	s1,v0
8000cd9c:	00001021 	move	v0,zero
8000cda0:	00002021 	move	a0,zero
8000cda4:	00008021 	move	s0,zero
		dst_value = *(volatile unsigned int *)(dst+i);
		src_value = *(volatile unsigned int *)(src+i);
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
8000cda8:	3c148001 	lui	s4,0x8001
8000cdac:	26941fcc 	addiu	s4,s4,8140
8000cdb0:	24150001 	li	s5,1
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
		dst_value = *(volatile unsigned int *)(dst+i);
8000cdb4:	00521821 	addu	v1,v0,s2
8000cdb8:	8c660000 	lw	a2,0(v1)
		src_value = *(volatile unsigned int *)(src+i);
8000cdbc:	00531021 	addu	v0,v0,s3
8000cdc0:	8c470000 	lw	a3,0(v0)
		if(dst_value != src_value) {		
8000cdc4:	10c70005 	beq	a2,a3,8000cddc <CmdCmp+0xc0>
8000cdc8:	00000000 	nop
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
8000cdcc:	02802021 	move	a0,s4
8000cdd0:	0c001cc1 	jal	80007304 <dprintf>
8000cdd4:	02002821 	move	a1,s0
8000cdd8:	02a02021 	move	a0,s5
	}
	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
	error = 0;
	for(i=0;i<length;i+=4) {
8000cddc:	26100004 	addiu	s0,s0,4
8000cde0:	0211182b 	sltu	v1,s0,s1
8000cde4:	1460fff3 	bnez	v1,8000cdb4 <CmdCmp+0x98>
8000cde8:	02001021 	move	v0,s0
		if(dst_value != src_value) {		
			printf("%dth data(%x %x) error\n",i, dst_value, src_value);
			error = 1;
		}
	}
	if(!error)
8000cdec:	14800005 	bnez	a0,8000ce04 <CmdCmp+0xe8>
8000cdf0:	8fbf002c 	lw	ra,44(sp)
		printf("No error found\n");
8000cdf4:	3c048001 	lui	a0,0x8001
8000cdf8:	0c001cc1 	jal	80007304 <dprintf>
8000cdfc:	24841fe4 	addiu	a0,a0,8164

}
8000ce00:	8fbf002c 	lw	ra,44(sp)
8000ce04:	8fb50028 	lw	s5,40(sp)
8000ce08:	8fb40024 	lw	s4,36(sp)
8000ce0c:	8fb30020 	lw	s3,32(sp)
8000ce10:	8fb2001c 	lw	s2,28(sp)
8000ce14:	8fb10018 	lw	s1,24(sp)
8000ce18:	8fb00014 	lw	s0,20(sp)
8000ce1c:	03e00008 	jr	ra
8000ce20:	27bd0030 	addiu	sp,sp,48

8000ce24 <CmdWriteByte>:
	
}
#endif
//---------------------------------------------------------------------------
int CmdWriteByte( int argc, char* argv[] )
{
8000ce24:	27bdffd8 	addiu	sp,sp,-40
8000ce28:	afbf0024 	sw	ra,36(sp)
8000ce2c:	afb30020 	sw	s3,32(sp)
8000ce30:	afb2001c 	sw	s2,28(sp)
8000ce34:	afb10018 	sw	s1,24(sp)
8000ce38:	afb00014 	sw	s0,20(sp)
8000ce3c:	00809821 	move	s3,a0
8000ce40:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000ce44:	8ca40000 	lw	a0,0(a1)
8000ce48:	00002821 	move	a1,zero
8000ce4c:	0c001a60 	jal	80006980 <strtoul>
8000ce50:	24060010 	li	a2,16


	for(i=0;i<argc-1;i++,src++)
8000ce54:	2673ffff 	addiu	s3,s3,-1
8000ce58:	1a60000f 	blez	s3,8000ce98 <CmdWriteByte+0x74>
8000ce5c:	00408021 	move	s0,v0
{
	
	unsigned long src;
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000ce60:	00008821 	move	s1,zero


	for(i=0;i<argc-1;i++,src++)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000ce64:	26310001 	addiu	s1,s1,1
8000ce68:	00111080 	sll	v0,s1,0x2
8000ce6c:	02421021 	addu	v0,s2,v0
8000ce70:	8c440000 	lw	a0,0(v0)
8000ce74:	00002821 	move	a1,zero
8000ce78:	0c001a60 	jal	80006980 <strtoul>
8000ce7c:	24060010 	li	a2,16
8000ce80:	304200ff 	andi	v0,v0,0xff
		*(volatile unsigned char *)(src) = value;
8000ce84:	a2020000 	sb	v0,0(s0)
	unsigned char value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		


	for(i=0;i<argc-1;i++,src++)
8000ce88:	323100ff 	andi	s1,s1,0xff
8000ce8c:	0233102a 	slt	v0,s1,s3
8000ce90:	1440fff4 	bnez	v0,8000ce64 <CmdWriteByte+0x40>
8000ce94:	26100001 	addiu	s0,s0,1
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned char *)(src) = value;
	}
	
}
8000ce98:	8fbf0024 	lw	ra,36(sp)
8000ce9c:	8fb30020 	lw	s3,32(sp)
8000cea0:	8fb2001c 	lw	s2,28(sp)
8000cea4:	8fb10018 	lw	s1,24(sp)
8000cea8:	8fb00014 	lw	s0,20(sp)
8000ceac:	03e00008 	jr	ra
8000ceb0:	27bd0028 	addiu	sp,sp,40

8000ceb4 <CmdWriteHword>:
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

int CmdWriteHword( int argc, char* argv[] )
{
8000ceb4:	27bdffd8 	addiu	sp,sp,-40
8000ceb8:	afbf0024 	sw	ra,36(sp)
8000cebc:	afb30020 	sw	s3,32(sp)
8000cec0:	afb2001c 	sw	s2,28(sp)
8000cec4:	afb10018 	sw	s1,24(sp)
8000cec8:	afb00014 	sw	s0,20(sp)
8000cecc:	00809821 	move	s3,a0
8000ced0:	00a09021 	move	s2,a1
	
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000ced4:	8ca40000 	lw	a0,0(a1)
8000ced8:	00002821 	move	a1,zero
8000cedc:	0c001a60 	jal	80006980 <strtoul>
8000cee0:	24060010 	li	a2,16
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
8000cee4:	2673ffff 	addiu	s3,s3,-1
8000cee8:	1a600010 	blez	s3,8000cf2c <CmdWriteHword+0x78>
8000ceec:	2410fffe 	li	s0,-2
	unsigned long src;
	unsigned short value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	
8000cef0:	00508024 	and	s0,v0,s0
8000cef4:	00008821 	move	s1,zero

	for(i=0;i<argc-1;i++,src+=2)
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000cef8:	26310001 	addiu	s1,s1,1
8000cefc:	00111080 	sll	v0,s1,0x2
8000cf00:	02421021 	addu	v0,s2,v0
8000cf04:	8c440000 	lw	a0,0(v0)
8000cf08:	00002821 	move	a1,zero
8000cf0c:	0c001a60 	jal	80006980 <strtoul>
8000cf10:	24060010 	li	a2,16
8000cf14:	3042ffff 	andi	v0,v0,0xffff
		*(volatile unsigned short *)(src) = value;
8000cf18:	a6020000 	sh	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	
	src &= 0xfffffffe;	

	for(i=0;i<argc-1;i++,src+=2)
8000cf1c:	3231ffff 	andi	s1,s1,0xffff
8000cf20:	0233102a 	slt	v0,s1,s3
8000cf24:	1440fff4 	bnez	v0,8000cef8 <CmdWriteHword+0x44>
8000cf28:	26100002 	addiu	s0,s0,2
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned short *)(src) = value;
	}
	
}
8000cf2c:	8fbf0024 	lw	ra,36(sp)
8000cf30:	8fb30020 	lw	s3,32(sp)
8000cf34:	8fb2001c 	lw	s2,28(sp)
8000cf38:	8fb10018 	lw	s1,24(sp)
8000cf3c:	8fb00014 	lw	s0,20(sp)
8000cf40:	03e00008 	jr	ra
8000cf44:	27bd0028 	addiu	sp,sp,40

8000cf48 <CmdWriteWord>:
	ddump((unsigned char *)src,len);
}

//---------------------------------------------------------------------------
int CmdWriteWord( int argc, char* argv[] )
{
8000cf48:	27bdffd8 	addiu	sp,sp,-40
8000cf4c:	afbf0024 	sw	ra,36(sp)
8000cf50:	afb30020 	sw	s3,32(sp)
8000cf54:	afb2001c 	sw	s2,28(sp)
8000cf58:	afb10018 	sw	s1,24(sp)
8000cf5c:	afb00014 	sw	s0,20(sp)
8000cf60:	00809821 	move	s3,a0
8000cf64:	00a08821 	move	s1,a1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000cf68:	8ca40000 	lw	a0,0(a1)
8000cf6c:	00002821 	move	a1,zero
8000cf70:	0c001a60 	jal	80006980 <strtoul>
8000cf74:	24060010 	li	a2,16
8000cf78:	00408021 	move	s0,v0
	while ( (src) & 0x03)
8000cf7c:	30420003 	andi	v0,v0,0x3
8000cf80:	10400006 	beqz	v0,8000cf9c <CmdWriteWord+0x54>
8000cf84:	00000000 	nop
		src++;
8000cf88:	26100001 	addiu	s0,s0,1
	
	unsigned long src;
	unsigned int value,i;
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
8000cf8c:	32020003 	andi	v0,s0,0x3
8000cf90:	1440fffe 	bnez	v0,8000cf8c <CmdWriteWord+0x44>
8000cf94:	26100001 	addiu	s0,s0,1
8000cf98:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0;i<argc-1;i++,src+=4)
8000cf9c:	2673ffff 	addiu	s3,s3,-1
8000cfa0:	1260000b 	beqz	s3,8000cfd0 <CmdWriteWord+0x88>
8000cfa4:	00009021 	move	s2,zero
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
8000cfa8:	26520001 	addiu	s2,s2,1
8000cfac:	8e240004 	lw	a0,4(s1)
8000cfb0:	00002821 	move	a1,zero
8000cfb4:	0c001a60 	jal	80006980 <strtoul>
8000cfb8:	24060010 	li	a2,16
		*(volatile unsigned int *)(src) = value;
8000cfbc:	ae020000 	sw	v0,0(s0)
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	while ( (src) & 0x03)
		src++;

	for(i=0;i<argc-1;i++,src+=4)
8000cfc0:	26100004 	addiu	s0,s0,4
8000cfc4:	0253102b 	sltu	v0,s2,s3
8000cfc8:	1440fff7 	bnez	v0,8000cfa8 <CmdWriteWord+0x60>
8000cfcc:	26310004 	addiu	s1,s1,4
	{
		value= strtoul((const char*)(argv[i+1]), (char **)NULL, 16);	
		*(volatile unsigned int *)(src) = value;
	}
	
}
8000cfd0:	8fbf0024 	lw	ra,36(sp)
8000cfd4:	8fb30020 	lw	s3,32(sp)
8000cfd8:	8fb2001c 	lw	s2,28(sp)
8000cfdc:	8fb10018 	lw	s1,24(sp)
8000cfe0:	8fb00014 	lw	s0,20(sp)
8000cfe4:	03e00008 	jr	ra
8000cfe8:	27bd0028 	addiu	sp,sp,40

8000cfec <CmdDumpWord>:
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
int CmdDumpWord( int argc, char* argv[] )
{
8000cfec:	27bdffd0 	addiu	sp,sp,-48
8000cff0:	afbf002c 	sw	ra,44(sp)
8000cff4:	afb30028 	sw	s3,40(sp)
8000cff8:	afb20024 	sw	s2,36(sp)
8000cffc:	afb10020 	sw	s1,32(sp)
8000d000:	afb0001c 	sw	s0,28(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
8000d004:	1c800006 	bgtz	a0,8000d020 <CmdDumpWord+0x34>
8000d008:	00a08821 	move	s1,a1
	{	dprintf("Wrong argument number!\r\n");
8000d00c:	3c048001 	lui	a0,0x8001
8000d010:	0c001cc1 	jal	80007304 <dprintf>
8000d014:	24841ff4 	addiu	a0,a0,8180
		return;
8000d018:	08003439 	j	8000d0e4 <CmdDumpWord+0xf8>
8000d01c:	8fbf002c 	lw	ra,44(sp)
	}
	
	if(argv[0])	
8000d020:	8ca40000 	lw	a0,0(a1)
8000d024:	10800009 	beqz	a0,8000d04c <CmdDumpWord+0x60>
8000d028:	00000000 	nop
	{	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d02c:	00002821 	move	a1,zero
8000d030:	0c001a60 	jal	80006980 <strtoul>
8000d034:	24060010 	li	a2,16
		if(src <0x80000000)
8000d038:	04400009 	bltz	v0,8000d060 <CmdDumpWord+0x74>
8000d03c:	00408021 	move	s0,v0
			src|=0x80000000;
8000d040:	3c028000 	lui	v0,0x8000
8000d044:	08003418 	j	8000d060 <CmdDumpWord+0x74>
8000d048:	02028025 	or	s0,s0,v0
	}
	else
	{	dprintf("Wrong argument number!\r\n");
8000d04c:	3c048001 	lui	a0,0x8001
8000d050:	0c001cc1 	jal	80007304 <dprintf>
8000d054:	24841ff4 	addiu	a0,a0,8180
		return;		
8000d058:	08003439 	j	8000d0e4 <CmdDumpWord+0xf8>
8000d05c:	8fbf002c 	lw	ra,44(sp)
	}
				
	if(!argv[1])
8000d060:	8e240004 	lw	a0,4(s1)
8000d064:	10800005 	beqz	a0,8000d07c <CmdDumpWord+0x90>
8000d068:	24120001 	li	s2,1
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
8000d06c:	00002821 	move	a1,zero
8000d070:	0c001a60 	jal	80006980 <strtoul>
8000d074:	2406000a 	li	a2,10
8000d078:	00409021 	move	s2,v0
	while ( (src) & 0x03)
8000d07c:	32020003 	andi	v0,s0,0x3
8000d080:	10400006 	beqz	v0,8000d09c <CmdDumpWord+0xb0>
8000d084:	00000000 	nop
		src++;
8000d088:	26100001 	addiu	s0,s0,1
				
	if(!argv[1])
		len = 1;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
8000d08c:	32020003 	andi	v0,s0,0x3
8000d090:	1440fffe 	bnez	v0,8000d08c <CmdDumpWord+0xa0>
8000d094:	26100001 	addiu	s0,s0,1
8000d098:	2610ffff 	addiu	s0,s0,-1
		src++;

	for(i=0; i< len ; i+=4,src+=16)
8000d09c:	12400010 	beqz	s2,8000d0e0 <CmdDumpWord+0xf4>
8000d0a0:	00008821 	move	s1,zero
	{	
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
8000d0a4:	3c138001 	lui	s3,0x8001
8000d0a8:	26732010 	addiu	s3,s3,8208
8000d0ac:	8e060000 	lw	a2,0(s0)
8000d0b0:	8e070004 	lw	a3,4(s0)
8000d0b4:	8e020008 	lw	v0,8(s0)
8000d0b8:	afa20010 	sw	v0,16(sp)
8000d0bc:	8e02000c 	lw	v0,12(s0)
8000d0c0:	afa20014 	sw	v0,20(sp)
8000d0c4:	02602021 	move	a0,s3
8000d0c8:	0c001cc1 	jal	80007304 <dprintf>
8000d0cc:	02002821 	move	a1,s0
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
	while ( (src) & 0x03)
		src++;

	for(i=0; i< len ; i+=4,src+=16)
8000d0d0:	26310004 	addiu	s1,s1,4
8000d0d4:	0232102b 	sltu	v0,s1,s2
8000d0d8:	1440fff4 	bnez	v0,8000d0ac <CmdDumpWord+0xc0>
8000d0dc:	26100010 	addiu	s0,s0,16
		dprintf("%08X:	%08X	%08X	%08X	%08X\n",
		src, *(unsigned long *)(src), *(unsigned long *)(src+4), 
		*(unsigned long *)(src+8), *(unsigned long *)(src+12));
	}

}
8000d0e0:	8fbf002c 	lw	ra,44(sp)
8000d0e4:	8fb30028 	lw	s3,40(sp)
8000d0e8:	8fb20024 	lw	s2,36(sp)
8000d0ec:	8fb10020 	lw	s1,32(sp)
8000d0f0:	8fb0001c 	lw	s0,28(sp)
8000d0f4:	03e00008 	jr	ra
8000d0f8:	27bd0030 	addiu	sp,sp,48

8000d0fc <CmdPHYregR>:

	return 0;
}

int CmdPHYregR(int argc, char* argv[])
{
8000d0fc:	27bdffd8 	addiu	sp,sp,-40
8000d100:	afbf0024 	sw	ra,36(sp)
8000d104:	afb10020 	sw	s1,32(sp)
8000d108:	afb0001c 	sw	s0,28(sp)
8000d10c:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d110:	8ca40000 	lw	a0,0(a1)
8000d114:	00002821 	move	a1,zero
8000d118:	0c001a60 	jal	80006980 <strtoul>
8000d11c:	24060010 	li	a2,16
8000d120:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d124:	8e040004 	lw	a0,4(s0)
8000d128:	00002821 	move	a1,zero
8000d12c:	0c001a60 	jal	80006980 <strtoul>
8000d130:	24060010 	li	a2,16
8000d134:	00408021 	move	s0,v0

    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
8000d138:	02202021 	move	a0,s1
8000d13c:	00402821 	move	a1,v0
8000d140:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d144:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
8000d148:	3c048001 	lui	a0,0x8001
8000d14c:	2484202c 	addiu	a0,a0,8236
8000d150:	02202821 	move	a1,s1
8000d154:	02003021 	move	a2,s0
8000d158:	0c001cc1 	jal	80007304 <dprintf>
8000d15c:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000d160:	00001021 	move	v0,zero
8000d164:	8fbf0024 	lw	ra,36(sp)
8000d168:	8fb10020 	lw	s1,32(sp)
8000d16c:	8fb0001c 	lw	s0,28(sp)
8000d170:	03e00008 	jr	ra
8000d174:	27bd0028 	addiu	sp,sp,40

8000d178 <TestCmd_MDIOR>:
}
#endif
//---------------------------------------------------------------------------
#if SWITCH_CMD
int TestCmd_MDIOR( int argc, char* argv[] )
{
8000d178:	27bdffd0 	addiu	sp,sp,-48
8000d17c:	afbf002c 	sw	ra,44(sp)
8000d180:	afb40028 	sw	s4,40(sp)
8000d184:	afb30024 	sw	s3,36(sp)
8000d188:	afb20020 	sw	s2,32(sp)
8000d18c:	afb1001c 	sw	s1,28(sp)
8000d190:	afb00018 	sw	s0,24(sp)
	if(argc < 1) {
8000d194:	1c800005 	bgtz	a0,8000d1ac <TestCmd_MDIOR+0x34>
8000d198:	3c048001 	lui	a0,0x8001
		printf("Parameters not enough!\n");
8000d19c:	0c001cc1 	jal	80007304 <dprintf>
8000d1a0:	24841fb4 	addiu	a0,a0,8116
		return 1;
8000d1a4:	08003482 	j	8000d208 <TestCmd_MDIOR+0x90>
8000d1a8:	24020001 	li	v0,1
	}

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
8000d1ac:	8ca40000 	lw	a0,0(a1)
8000d1b0:	00002821 	move	a1,zero
8000d1b4:	0c001a60 	jal	80006980 <strtoul>
8000d1b8:	2406000a 	li	a2,10
8000d1bc:	00408821 	move	s1,v0
8000d1c0:	00008021 	move	s0,zero
	int i,phyid;
	for(i=0;i<32;i++)
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
8000d1c4:	27b40010 	addiu	s4,sp,16
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
8000d1c8:	3c128001 	lui	s2,0x8001
8000d1cc:	26522050 	addiu	s2,s2,8272

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
8000d1d0:	24130020 	li	s3,32
	{
		phyid=i;
		//REG32(PABCDDAT_REG) =  0xffff<<8;
	rtl8651_getAsicEthernetPHYReg(phyid,reg,&data); 	
8000d1d4:	02002021 	move	a0,s0
8000d1d8:	02202821 	move	a1,s1
8000d1dc:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d1e0:	02803021 	move	a2,s4
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);
8000d1e4:	02402021 	move	a0,s2
8000d1e8:	02002821 	move	a1,s0
8000d1ec:	02203021 	move	a2,s1
8000d1f0:	0c001cc1 	jal	80007304 <dprintf>
8000d1f4:	8fa70010 	lw	a3,16(sp)

//	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
	unsigned int reg = strtoul((const char*)(argv[0]), (char **)NULL, 10);		
	unsigned int data;
	int i,phyid;
	for(i=0;i<32;i++)
8000d1f8:	26100001 	addiu	s0,s0,1
8000d1fc:	1613fff6 	bne	s0,s3,8000d1d8 <TestCmd_MDIOR+0x60>
8000d200:	02002021 	move	a0,s0
8000d204:	00001021 	move	v0,zero
		//REG32(PABCDDAT_REG) =  0<<8;	
	dprintf("PhyID=0x%02x Reg=%02d Data =0x%04x\r\n", phyid, reg,data);

	}
	return 0;
}
8000d208:	8fbf002c 	lw	ra,44(sp)
8000d20c:	8fb40028 	lw	s4,40(sp)
8000d210:	8fb30024 	lw	s3,36(sp)
8000d214:	8fb20020 	lw	s2,32(sp)
8000d218:	8fb1001c 	lw	s1,28(sp)
8000d21c:	8fb00018 	lw	s0,24(sp)
8000d220:	03e00008 	jr	ra
8000d224:	27bd0030 	addiu	sp,sp,48

8000d228 <CmdPHY_Script>:
#endif

//===============================================================================
//========================================================
int CmdPHY_Script(int argc, char* argv[])
{
8000d228:	27bdff18 	addiu	sp,sp,-232
8000d22c:	afbf00e4 	sw	ra,228(sp)
8000d230:	afbe00e0 	sw	s8,224(sp)
8000d234:	afb700dc 	sw	s7,220(sp)
8000d238:	afb600d8 	sw	s6,216(sp)
8000d23c:	afb500d4 	sw	s5,212(sp)
8000d240:	afb400d0 	sw	s4,208(sp)
8000d244:	afb300cc 	sw	s3,204(sp)
8000d248:	afb200c8 	sw	s2,200(sp)
8000d24c:	afb100c4 	sw	s1,196(sp)
8000d250:	afb000c0 	sw	s0,192(sp)
8000d254:	24130001 	li	s3,1
8000d258:	0000f021 	move	s8,zero
8000d25c:	2416000a 	li	s6,10
8000d260:	afa000a0 	sw	zero,160(sp)
	
    while(1)
    {


	if(rec==1)
8000d264:	24140001 	li	s4,1
	{	
		memset(buffer,0,LEN);
8000d268:	27b20010 	addiu	s2,sp,16
		GetLine(buffer,LEN,1);
		printf("\n");
8000d26c:	3c028001 	lui	v0,0x8001
8000d270:	24420f54 	addiu	v0,v0,3924
8000d274:	afa200ac 	sw	v0,172(sp)
		len=strlen(buffer);
		
		memcpy(ptr+pidx,buffer, len); 
8000d278:	3c158050 	lui	s5,0x8050


	StrUpr(argv[0]);
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
8000d27c:	3c028001 	lui	v0,0x8001
8000d280:	24422078 	addiu	v0,v0,8312
8000d284:	afa200b0 	sw	v0,176(sp)
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
8000d288:	3c028001 	lui	v0,0x8001
8000d28c:	244207f0 	addiu	v0,v0,2032
8000d290:	afa200b4 	sw	v0,180(sp)
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
8000d294:	3c028001 	lui	v0,0x8001
8000d298:	24422540 	addiu	v0,v0,9536
8000d29c:	afa200a4 	sw	v0,164(sp)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000d2a0:	3c028001 	lui	v0,0x8001
8000d2a4:	24422520 	addiu	v0,v0,9504
8000d2a8:	afa200a8 	sw	v0,168(sp)
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
		tmp=(tmp&mask)>>bit1;
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
8000d2ac:	3c028001 	lui	v0,0x8001
8000d2b0:	244202bc 	addiu	v0,v0,700
8000d2b4:	afa200bc 	sw	v0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
8000d2b8:	3c178001 	lui	s7,0x8001
8000d2bc:	26f72080 	addiu	s7,s7,8320
	
    while(1)
    {


	if(rec==1)
8000d2c0:	16740024 	bne	s3,s4,8000d354 <CmdPHY_Script+0x12c>
8000d2c4:	00002821 	move	a1,zero
	{	
		memset(buffer,0,LEN);
8000d2c8:	02402021 	move	a0,s2
8000d2cc:	0c0019d9 	jal	80006764 <memset>
8000d2d0:	24060080 	li	a2,128
		GetLine(buffer,LEN,1);
8000d2d4:	02402021 	move	a0,s2
8000d2d8:	24050080 	li	a1,128
8000d2dc:	0c001b2f 	jal	80006cbc <GetLine>
8000d2e0:	02803021 	move	a2,s4
		printf("\n");
8000d2e4:	0c001cc1 	jal	80007304 <dprintf>
8000d2e8:	8fa400ac 	lw	a0,172(sp)
		len=strlen(buffer);
8000d2ec:	0c0019cf 	jal	8000673c <strlen>
8000d2f0:	02402021 	move	a0,s2
8000d2f4:	00408021 	move	s0,v0
		
		memcpy(ptr+pidx,buffer, len); 
8000d2f8:	03d52021 	addu	a0,s8,s5
8000d2fc:	02402821 	move	a1,s2
8000d300:	0c0019e2 	jal	80006788 <memcpy>
8000d304:	00403021 	move	a2,v0
		ptr[pidx+len]=0x0a;
8000d308:	021ef021 	addu	s8,s0,s8
8000d30c:	02be1021 	addu	v0,s5,s8
8000d310:	2403000a 	li	v1,10
8000d314:	a0430000 	sb	v1,0(v0)
		pidx+=(len+1);
8000d318:	27de0001 	addiu	s8,s8,1
			ExtractACmdLine(ptr, buffer, 0);
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
8000d31c:	0c001ac5 	jal	80006b14 <GetArgc>
8000d320:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
8000d324:	0c001afd 	jal	80006bf4 <GetArgv>
8000d328:	02402021 	move	a0,s2
8000d32c:	00408821 	move	s1,v0


	StrUpr(argv[0]);
8000d330:	0c001ab4 	jal	80006ad0 <StrUpr>
8000d334:	8c440000 	lw	a0,0(v0)
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
8000d338:	8e240000 	lw	a0,0(s1)
8000d33c:	0c0019b1 	jal	800066c4 <strcmp>
8000d340:	8fa500b0 	lw	a1,176(sp)
8000d344:	1440008c 	bnez	v0,8000d578 <CmdPHY_Script+0x350>
8000d348:	00000000 	nop
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d34c:	080034e2 	j	8000d388 <CmdPHY_Script+0x160>
8000d350:	8e240004 	lw	a0,4(s1)
		ptr[pidx+len]=0x0a;
		pidx+=(len+1);
	}
	else
	{		
			ExtractACmdLine(ptr, buffer, 0);
8000d354:	02a02021 	move	a0,s5
8000d358:	02402821 	move	a1,s2
8000d35c:	0c0026cf 	jal	80009b3c <ExtractACmdLine>
8000d360:	00003021 	move	a2,zero
	}

	
	WDBG("\n");
	argc = GetArgc( (const char *)buffer );
8000d364:	0c001ac5 	jal	80006b14 <GetArgc>
8000d368:	02402021 	move	a0,s2
	argv = GetArgv( (const char *)buffer );
8000d36c:	0c001afd 	jal	80006bf4 <GetArgv>
8000d370:	02402021 	move	a0,s2
8000d374:	00408821 	move	s1,v0


	StrUpr(argv[0]);
8000d378:	0c001ab4 	jal	80006ad0 <StrUpr>
8000d37c:	8c440000 	lw	a0,0(v0)
8000d380:	080034ec 	j	8000d3b0 <CmdPHY_Script+0x188>
8000d384:	00000000 	nop
	WDBG("cmd=%s\n", argv[0] );
	
	if( (rec==1)  &&  !strcmp(argv[0],  "PHYID") )
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d388:	00002821 	move	a1,zero
8000d38c:	0c001a60 	jal	80006980 <strtoul>
8000d390:	24060010 	li	a2,16
8000d394:	0800355e 	j	8000d578 <CmdPHY_Script+0x350>
8000d398:	afa200a0 	sw	v0,160(sp)
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000d39c:	00002821 	move	a1,zero
8000d3a0:	0c001a60 	jal	80006980 <strtoul>
8000d3a4:	2406000a 	li	a2,10
8000d3a8:	08003541 	j	8000d504 <CmdPHY_Script+0x2dc>
8000d3ac:	0040b021 	move	s6,v0
		WDBG("rep=%x\n", cnt);		
	}
	if(  (rec==0)  && !strcmp(argv[0],  "W") )
8000d3b0:	16600054 	bnez	s3,8000d504 <CmdPHY_Script+0x2dc>
8000d3b4:	00000000 	nop
8000d3b8:	8e240000 	lw	a0,0(s1)
8000d3bc:	0c0019b1 	jal	800066c4 <strcmp>
8000d3c0:	8fa500a4 	lw	a1,164(sp)
8000d3c4:	14400073 	bnez	v0,8000d594 <CmdPHY_Script+0x36c>
8000d3c8:	00002821 	move	a1,zero
	{
		unsigned int reg,bit2,bit1,i,mask=0,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000d3cc:	8e240004 	lw	a0,4(s1)
8000d3d0:	0c001a60 	jal	80006980 <strtoul>
8000d3d4:	2406000a 	li	a2,10
8000d3d8:	afa20098 	sw	v0,152(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
8000d3dc:	8e240008 	lw	a0,8(s1)
8000d3e0:	00002821 	move	a1,zero
8000d3e4:	0c001a60 	jal	80006980 <strtoul>
8000d3e8:	2406000a 	li	a2,10
8000d3ec:	afa200b8 	sw	v0,184(sp)
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
8000d3f0:	8e24000c 	lw	a0,12(s1)
8000d3f4:	00002821 	move	a1,zero
8000d3f8:	0c001a60 	jal	80006980 <strtoul>
8000d3fc:	2406000a 	li	a2,10
8000d400:	00408021 	move	s0,v0
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);
8000d404:	8e240010 	lw	a0,16(s1)
8000d408:	00002821 	move	a1,zero
8000d40c:	0c001a60 	jal	80006980 <strtoul>
8000d410:	24060010 	li	a2,16
8000d414:	afa2009c 	sw	v0,156(sp)

		for(i=0; i<=(bit2-bit1); i++)
8000d418:	8fa200b8 	lw	v0,184(sp)
8000d41c:	00502823 	subu	a1,v0,s0
8000d420:	00001821 	move	v1,zero
8000d424:	00001021 	move	v0,zero
			mask= (mask<<1)|1;
8000d428:	00031840 	sll	v1,v1,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);
		val=strtoul((const char*)(argv[4]), (char **)NULL, 16);

		for(i=0; i<=(bit2-bit1); i++)
8000d42c:	24420001 	addiu	v0,v0,1
8000d430:	00a2202b 	sltu	a0,a1,v0
8000d434:	1080fffc 	beqz	a0,8000d428 <CmdPHY_Script+0x200>
8000d438:	34630001 	ori	v1,v1,0x1
			mask= (mask<<1)|1;
		mask=0xffffffff-(mask<<bit1);
8000d43c:	02038004 	sllv	s0,v1,s0
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
8000d440:	8fa400a0 	lw	a0,160(sp)
8000d444:	8fa50098 	lw	a1,152(sp)
8000d448:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d44c:	27a60090 	addiu	a2,sp,144
		WDBG("mask=%x\n", mask);
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	
8000d450:	00108027 	nor	s0,zero,s0
8000d454:	8fa20090 	lw	v0,144(sp)
8000d458:	02023024 	and	a2,s0,v0
8000d45c:	8fa400a0 	lw	a0,160(sp)
8000d460:	8fa50098 	lw	a1,152(sp)
8000d464:	8fa3009c 	lw	v1,156(sp)
8000d468:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d46c:	00c33025 	or	a2,a2,v1

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000d470:	08003566 	j	8000d598 <CmdPHY_Script+0x370>
8000d474:	8e240000 	lw	a0,0(s1)
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000d478:	00002821 	move	a1,zero
8000d47c:	0c001a60 	jal	80006980 <strtoul>
8000d480:	2406000a 	li	a2,10
8000d484:	afa2009c 	sw	v0,156(sp)
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
8000d488:	8e240008 	lw	a0,8(s1)
8000d48c:	00002821 	move	a1,zero
8000d490:	0c001a60 	jal	80006980 <strtoul>
8000d494:	2406000a 	li	a2,10
8000d498:	00408021 	move	s0,v0
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		
8000d49c:	8e24000c 	lw	a0,12(s1)
8000d4a0:	00002821 	move	a1,zero
8000d4a4:	0c001a60 	jal	80006980 <strtoul>
8000d4a8:	2406000a 	li	a2,10
8000d4ac:	afa20098 	sw	v0,152(sp)


		for(i=0; i<=(bit2-bit1); i++)
8000d4b0:	02022023 	subu	a0,s0,v0
8000d4b4:	00001021 	move	v0,zero
8000d4b8:	00008021 	move	s0,zero
			mask= (mask<<1)|1;
8000d4bc:	00108040 	sll	s0,s0,0x1
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
		bit2=strtoul((const char*)(argv[2]), (char **)NULL, 10);
		bit1=strtoul((const char*)(argv[3]), (char **)NULL, 10);		


		for(i=0; i<=(bit2-bit1); i++)
8000d4c0:	24420001 	addiu	v0,v0,1
8000d4c4:	0082182b 	sltu	v1,a0,v0
8000d4c8:	1060fffc 	beqz	v1,8000d4bc <CmdPHY_Script+0x294>
8000d4cc:	36100001 	ori	s0,s0,0x1
			mask= (mask<<1)|1;
		mask=mask<<bit1;
		WDBG("mask=%x\n", mask);
		
		rtl8651_getAsicEthernetPHYReg( phyid, reg, &tmp );	
8000d4d0:	8fa400a0 	lw	a0,160(sp)
8000d4d4:	8fa5009c 	lw	a1,156(sp)
8000d4d8:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d4dc:	27a60090 	addiu	a2,sp,144
		tmp=(tmp&mask)>>bit1;
8000d4e0:	8fa20098 	lw	v0,152(sp)
8000d4e4:	00502804 	sllv	a1,s0,v0
8000d4e8:	8fa20090 	lw	v0,144(sp)
8000d4ec:	00a22824 	and	a1,a1,v0
8000d4f0:	8fa30098 	lw	v1,152(sp)
8000d4f4:	00652806 	srlv	a1,a1,v1
8000d4f8:	afa50090 	sw	a1,144(sp)
		WDBG("val=%x\n",tmp);
		printf("0x%x\n", tmp);
8000d4fc:	0c001cc1 	jal	80007304 <dprintf>
8000d500:	8fa400bc 	lw	a0,188(sp)
	}	
	if( !strcmp(argv[0],  "PHY_END") )
8000d504:	8e240000 	lw	a0,0(s1)
8000d508:	0c0019b1 	jal	800066c4 <strcmp>
8000d50c:	02e02821 	move	a1,s7
8000d510:	1440ff6b 	bnez	v0,8000d2c0 <CmdPHY_Script+0x98>
8000d514:	00000000 	nop
	{	
		if(rec==1)
8000d518:	16740006 	bne	s3,s4,8000d534 <CmdPHY_Script+0x30c>
8000d51c:	02a02021 	move	a0,s5
		{

			ExtractACmdLine(ptr, buffer, 1);
8000d520:	02402821 	move	a1,s2
8000d524:	0c0026cf 	jal	80009b3c <ExtractACmdLine>
8000d528:	02803021 	move	a2,s4
8000d52c:	080034b0 	j	8000d2c0 <CmdPHY_Script+0x98>
8000d530:	00009821 	move	s3,zero
			rec=0;
		}
		else
		{
			ExtractACmdLine(ptr, buffer, 1);
8000d534:	02402821 	move	a1,s2
8000d538:	0c0026cf 	jal	80009b3c <ExtractACmdLine>
8000d53c:	02803021 	move	a2,s4
			cnt--;
8000d540:	26d6ffff 	addiu	s6,s6,-1
			if(cnt==0)
8000d544:	16c0ff5e 	bnez	s6,8000d2c0 <CmdPHY_Script+0x98>
8000d548:	8fbf00e4 	lw	ra,228(sp)
	}	

	
    }

}
8000d54c:	8fbe00e0 	lw	s8,224(sp)
8000d550:	8fb700dc 	lw	s7,220(sp)
8000d554:	8fb600d8 	lw	s6,216(sp)
8000d558:	8fb500d4 	lw	s5,212(sp)
8000d55c:	8fb400d0 	lw	s4,208(sp)
8000d560:	8fb300cc 	lw	s3,204(sp)
8000d564:	8fb200c8 	lw	s2,200(sp)
8000d568:	8fb100c4 	lw	s1,196(sp)
8000d56c:	8fb000c0 	lw	s0,192(sp)
8000d570:	03e00008 	jr	ra
8000d574:	27bd00e8 	addiu	sp,sp,232
	{
		phyid=strtoul((const char*)(argv[1]), (char **)NULL, 16);
		WDBG("id=%x\n", phyid);		
	}
	
	if(  (rec==1)  && !strcmp(argv[0],  "A") )
8000d578:	8e240000 	lw	a0,0(s1)
8000d57c:	0c0019b1 	jal	800066c4 <strcmp>
8000d580:	8fa500b4 	lw	a1,180(sp)
8000d584:	1440ff8a 	bnez	v0,8000d3b0 <CmdPHY_Script+0x188>
8000d588:	00000000 	nop
	{
		cnt=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000d58c:	080034e7 	j	8000d39c <CmdPHY_Script+0x174>
8000d590:	8e240004 	lw	a0,4(s1)
		val=(tmp&mask)|val;
		WDBG("W reg=%x\n",val);		
		rtl8651_setAsicEthernetPHYReg( phyid, reg,  val);	

	}
	if(  (rec==0)  && !strcmp(argv[0],  "R") )
8000d594:	8e240000 	lw	a0,0(s1)
8000d598:	0c0019b1 	jal	800066c4 <strcmp>
8000d59c:	8fa500a8 	lw	a1,168(sp)
8000d5a0:	1440ffd8 	bnez	v0,8000d504 <CmdPHY_Script+0x2dc>
8000d5a4:	00000000 	nop
	{
		unsigned int reg,bit2,bit1,mask=0,i,val,tmp;
		reg=strtoul((const char*)(argv[1]), (char **)NULL, 10);
8000d5a8:	0800351e 	j	8000d478 <CmdPHY_Script+0x250>
8000d5ac:	8e240004 	lw	a0,4(s1)

8000d5b0 <CmdPhyPageRegW>:
    dprintf("PHYID=0x%x, page=0x%x, regID=0x%x, data=0x%x\r\n", phyid, page, regnum, uid);
	return 0;
}

int CmdPhyPageRegW(int argc, char* argv[])
{
8000d5b0:	27bdffc8 	addiu	sp,sp,-56
8000d5b4:	afbf0034 	sw	ra,52(sp)
8000d5b8:	afb30030 	sw	s3,48(sp)
8000d5bc:	afb2002c 	sw	s2,44(sp)
8000d5c0:	afb10028 	sw	s1,40(sp)
8000d5c4:	afb00024 	sw	s0,36(sp)
8000d5c8:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned long data;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d5cc:	8ca40000 	lw	a0,0(a1)
8000d5d0:	00002821 	move	a1,zero
8000d5d4:	0c001a60 	jal	80006980 <strtoul>
8000d5d8:	24060010 	li	a2,16
8000d5dc:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d5e0:	8e240004 	lw	a0,4(s1)
8000d5e4:	00002821 	move	a1,zero
8000d5e8:	0c001a60 	jal	80006980 <strtoul>
8000d5ec:	24060010 	li	a2,16
8000d5f0:	00409821 	move	s3,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000d5f4:	8e240008 	lw	a0,8(s1)
8000d5f8:	00002821 	move	a1,zero
8000d5fc:	0c001a60 	jal	80006980 <strtoul>
8000d600:	24060010 	li	a2,16
8000d604:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[3]), (char **)NULL, 16);
8000d608:	8e24000c 	lw	a0,12(s1)
8000d60c:	00002821 	move	a1,zero
8000d610:	0c001a60 	jal	80006980 <strtoul>
8000d614:	24060010 	li	a2,16
8000d618:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
8000d61c:	24020008 	li	v0,8
	if(page > 0)
8000d620:	12600013 	beqz	s3,8000d670 <CmdPhyPageRegW+0xc0>
8000d624:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
8000d628:	02002021 	move	a0,s0
8000d62c:	2405001f 	li	a1,31
8000d630:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d634:	02603021 	move	a2,s3

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000d638:	02002021 	move	a0,s0
8000d63c:	02402821 	move	a1,s2
8000d640:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d644:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000d648:	02002021 	move	a0,s0
8000d64c:	02402821 	move	a1,s2
8000d650:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d654:	27a60018 	addiu	a2,sp,24

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
8000d658:	02002021 	move	a0,s0
8000d65c:	2405001f 	li	a1,31
8000d660:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d664:	00003021 	move	a2,zero

    dprintf("PHYID=0x%x, page=0x%x, regID=0x%x, read back data=0x%x\r\n", phyid, page, regnum, uid);
8000d668:	080035a5 	j	8000d694 <CmdPhyPageRegW+0xe4>
8000d66c:	8fa20018 	lw	v0,24(sp)

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000d670:	02002021 	move	a0,s0
8000d674:	02402821 	move	a1,s2
8000d678:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d67c:	02203021 	move	a2,s1
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000d680:	02002021 	move	a0,s0
8000d684:	02402821 	move	a1,s2
8000d688:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d68c:	27a60018 	addiu	a2,sp,24

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );

    dprintf("PHYID=0x%x, page=0x%x, regID=0x%x, read back data=0x%x\r\n", phyid, page, regnum, uid);
8000d690:	8fa20018 	lw	v0,24(sp)
8000d694:	afa20010 	sw	v0,16(sp)
8000d698:	3c048001 	lui	a0,0x8001
8000d69c:	24842088 	addiu	a0,a0,8328
8000d6a0:	02002821 	move	a1,s0
8000d6a4:	02603021 	move	a2,s3
8000d6a8:	0c001cc1 	jal	80007304 <dprintf>
8000d6ac:	02403821 	move	a3,s2
	return 0;
}
8000d6b0:	00001021 	move	v0,zero
8000d6b4:	8fbf0034 	lw	ra,52(sp)
8000d6b8:	8fb30030 	lw	s3,48(sp)
8000d6bc:	8fb2002c 	lw	s2,44(sp)
8000d6c0:	8fb10028 	lw	s1,40(sp)
8000d6c4:	8fb00024 	lw	s0,36(sp)
8000d6c8:	03e00008 	jr	ra
8000d6cc:	27bd0038 	addiu	sp,sp,56

8000d6d0 <CmdPhyPageRegR>:
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPhyPageRegR(int argc, char* argv[])
{
8000d6d0:	27bdffd0 	addiu	sp,sp,-48
8000d6d4:	afbf002c 	sw	ra,44(sp)
8000d6d8:	afb20028 	sw	s2,40(sp)
8000d6dc:	afb10024 	sw	s1,36(sp)
8000d6e0:	afb00020 	sw	s0,32(sp)
8000d6e4:	00a08821 	move	s1,a1
    unsigned long phyid, regnum, page;
    unsigned int uid;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d6e8:	8ca40000 	lw	a0,0(a1)
8000d6ec:	00002821 	move	a1,zero
8000d6f0:	0c001a60 	jal	80006980 <strtoul>
8000d6f4:	24060010 	li	a2,16
8000d6f8:	00408021 	move	s0,v0
    page = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d6fc:	8e240004 	lw	a0,4(s1)
8000d700:	00002821 	move	a1,zero
8000d704:	0c001a60 	jal	80006980 <strtoul>
8000d708:	24060010 	li	a2,16
8000d70c:	00409021 	move	s2,v0
    regnum = strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000d710:	8e240008 	lw	a0,8(s1)
8000d714:	00002821 	move	a1,zero
8000d718:	0c001a60 	jal	80006980 <strtoul>
8000d71c:	24060010 	li	a2,16
8000d720:	00408821 	move	s1,v0

	if (phyid == 0) phyid = 8;
8000d724:	24020008 	li	v0,8
	if(page > 0)
8000d728:	1240000f 	beqz	s2,8000d768 <CmdPhyPageRegR+0x98>
8000d72c:	0050800a 	movz	s0,v0,s0
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
8000d730:	02002021 	move	a0,s0
8000d734:	2405001f 	li	a1,31
8000d738:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d73c:	02403021 	move	a2,s2
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000d740:	02002021 	move	a0,s0
8000d744:	02202821 	move	a1,s1
8000d748:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d74c:	27a60018 	addiu	a2,sp,24

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
8000d750:	02002021 	move	a0,s0
8000d754:	2405001f 	li	a1,31
8000d758:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d75c:	00003021 	move	a2,zero
	
    dprintf("PHYID=0x%x, page=0x%x, regID=0x%x, data=0x%x\r\n", phyid, page, regnum, uid);
8000d760:	080035df 	j	8000d77c <CmdPhyPageRegR+0xac>
8000d764:	8fa20018 	lw	v0,24(sp)

	if (phyid == 0) phyid = 8;
	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, page  );
	
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &uid );
8000d768:	02002021 	move	a0,s0
8000d76c:	02202821 	move	a1,s1
8000d770:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d774:	27a60018 	addiu	a2,sp,24

	if(page > 0)
		rtl8651_setAsicEthernetPHYReg( phyid, 31, 0  );
	
    dprintf("PHYID=0x%x, page=0x%x, regID=0x%x, data=0x%x\r\n", phyid, page, regnum, uid);
8000d778:	8fa20018 	lw	v0,24(sp)
8000d77c:	afa20010 	sw	v0,16(sp)
8000d780:	3c048001 	lui	a0,0x8001
8000d784:	248420c4 	addiu	a0,a0,8388
8000d788:	02002821 	move	a1,s0
8000d78c:	02403021 	move	a2,s2
8000d790:	0c001cc1 	jal	80007304 <dprintf>
8000d794:	02203821 	move	a3,s1
	return 0;
}
8000d798:	00001021 	move	v0,zero
8000d79c:	8fbf002c 	lw	ra,44(sp)
8000d7a0:	8fb20028 	lw	s2,40(sp)
8000d7a4:	8fb10024 	lw	s1,36(sp)
8000d7a8:	8fb00020 	lw	s0,32(sp)
8000d7ac:	03e00008 	jr	ra
8000d7b0:	27bd0030 	addiu	sp,sp,48

8000d7b4 <CmdPHYregW>:
    dprintf("PHYID=0x%x, regID=0x%x, data=0x%x\r\n", phyid, regnum, uid);
	return 0;
}

int CmdPHYregW(int argc, char* argv[])
{
8000d7b4:	27bdffd8 	addiu	sp,sp,-40
8000d7b8:	afbf0024 	sw	ra,36(sp)
8000d7bc:	afb20020 	sw	s2,32(sp)
8000d7c0:	afb1001c 	sw	s1,28(sp)
8000d7c4:	afb00018 	sw	s0,24(sp)
8000d7c8:	00a08021 	move	s0,a1
    unsigned long phyid, regnum;
    unsigned long data;
    unsigned int uid,tmp;

    phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d7cc:	8ca40000 	lw	a0,0(a1)
8000d7d0:	00002821 	move	a1,zero
8000d7d4:	0c001a60 	jal	80006980 <strtoul>
8000d7d8:	24060010 	li	a2,16
8000d7dc:	00408821 	move	s1,v0
    regnum = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d7e0:	8e040004 	lw	a0,4(s0)
8000d7e4:	00002821 	move	a1,zero
8000d7e8:	0c001a60 	jal	80006980 <strtoul>
8000d7ec:	24060010 	li	a2,16
8000d7f0:	00409021 	move	s2,v0
    data= strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000d7f4:	8e040008 	lw	a0,8(s0)
8000d7f8:	00002821 	move	a1,zero
8000d7fc:	0c001a60 	jal	80006980 <strtoul>
8000d800:	24060010 	li	a2,16

    rtl8651_setAsicEthernetPHYReg( phyid, regnum, data );
8000d804:	02202021 	move	a0,s1
8000d808:	02402821 	move	a1,s2
8000d80c:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d810:	00403021 	move	a2,v0
    rtl8651_getAsicEthernetPHYReg( phyid, regnum, &tmp );
8000d814:	02202021 	move	a0,s1
8000d818:	02402821 	move	a1,s2
8000d81c:	0c0009de 	jal	80002778 <rtl8651_getAsicEthernetPHYReg>
8000d820:	27a60010 	addiu	a2,sp,16
    uid=tmp;
    dprintf("PHYID=0x%x ,regID=0x%x, read back data=0x%x\r\n", phyid, regnum, uid);
8000d824:	3c048001 	lui	a0,0x8001
8000d828:	248420f4 	addiu	a0,a0,8436
8000d82c:	02202821 	move	a1,s1
8000d830:	02403021 	move	a2,s2
8000d834:	0c001cc1 	jal	80007304 <dprintf>
8000d838:	8fa70010 	lw	a3,16(sp)
	return 0;
}
8000d83c:	00001021 	move	v0,zero
8000d840:	8fbf0024 	lw	ra,36(sp)
8000d844:	8fb20020 	lw	s2,32(sp)
8000d848:	8fb1001c 	lw	s1,28(sp)
8000d84c:	8fb00018 	lw	s0,24(sp)
8000d850:	03e00008 	jr	ra
8000d854:	27bd0028 	addiu	sp,sp,40

8000d858 <TestCmd_MDIOW>:
	}
	return 0;
}

int TestCmd_MDIOW( int argc, char* argv[] )
{
8000d858:	27bdffe0 	addiu	sp,sp,-32
8000d85c:	afbf001c 	sw	ra,28(sp)
8000d860:	afb20018 	sw	s2,24(sp)
8000d864:	afb10014 	sw	s1,20(sp)
8000d868:	afb00010 	sw	s0,16(sp)
	if(argc < 3) {
8000d86c:	28840003 	slti	a0,a0,3
8000d870:	10800006 	beqz	a0,8000d88c <TestCmd_MDIOW+0x34>
8000d874:	00a08021 	move	s0,a1
		printf("Parameters not enough!\n");
8000d878:	3c048001 	lui	a0,0x8001
8000d87c:	0c001cc1 	jal	80007304 <dprintf>
8000d880:	24841fb4 	addiu	a0,a0,8116
		return 1;
8000d884:	0800363d 	j	8000d8f4 <TestCmd_MDIOW+0x9c>
8000d888:	24020001 	li	v0,1
	}
	
	unsigned int phyid = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000d88c:	8ca40000 	lw	a0,0(a1)
8000d890:	00002821 	move	a1,zero
8000d894:	0c001a60 	jal	80006980 <strtoul>
8000d898:	24060010 	li	a2,16
8000d89c:	00408821 	move	s1,v0
	unsigned int reg = strtoul((const char*)(argv[1]), (char **)NULL, 10);		
8000d8a0:	8e040004 	lw	a0,4(s0)
8000d8a4:	00002821 	move	a1,zero
8000d8a8:	0c001a60 	jal	80006980 <strtoul>
8000d8ac:	2406000a 	li	a2,10
8000d8b0:	00409021 	move	s2,v0
	unsigned int data = strtoul((const char*)(argv[2]), (char **)NULL, 16);		
8000d8b4:	8e040008 	lw	a0,8(s0)
8000d8b8:	00002821 	move	a1,zero
8000d8bc:	0c001a60 	jal	80006980 <strtoul>
8000d8c0:	24060010 	li	a2,16
8000d8c4:	00408021 	move	s0,v0

	dprintf("Write PhyID=0x%x Reg=%02d data=0x%x\r\n",phyid, reg,data);
8000d8c8:	3c048001 	lui	a0,0x8001
8000d8cc:	24842124 	addiu	a0,a0,8484
8000d8d0:	02202821 	move	a1,s1
8000d8d4:	02403021 	move	a2,s2
8000d8d8:	0c001cc1 	jal	80007304 <dprintf>
8000d8dc:	00403821 	move	a3,v0
	rtl8651_setAsicEthernetPHYReg(phyid,reg,data); 
8000d8e0:	02202021 	move	a0,s1
8000d8e4:	02402821 	move	a1,s2
8000d8e8:	0c0009ec 	jal	800027b0 <rtl8651_setAsicEthernetPHYReg>
8000d8ec:	02003021 	move	a2,s0
8000d8f0:	00001021 	move	v0,zero

	return 0;
}
8000d8f4:	8fbf001c 	lw	ra,28(sp)
8000d8f8:	8fb20018 	lw	s2,24(sp)
8000d8fc:	8fb10014 	lw	s1,20(sp)
8000d900:	8fb00010 	lw	s0,16(sp)
8000d904:	03e00008 	jr	ra
8000d908:	27bd0020 	addiu	sp,sp,32

8000d90c <CmdTest>:

}
//============================================================================

int CmdTest(int argc, char* argv[])
{
8000d90c:	27bdffc8 	addiu	sp,sp,-56
8000d910:	afbf0034 	sw	ra,52(sp)
8000d914:	afb60030 	sw	s6,48(sp)
8000d918:	afb5002c 	sw	s5,44(sp)
8000d91c:	afb40028 	sw	s4,40(sp)
8000d920:	afb30024 	sw	s3,36(sp)
8000d924:	afb20020 	sw	s2,32(sp)
8000d928:	afb1001c 	sw	s1,28(sp)
8000d92c:	afb00018 	sw	s0,24(sp)


#if 1
	int i,j,s,size,loop,st=0,ed=0;

	if( argc < 1 ) 
8000d930:	1c800006 	bgtz	a0,8000d94c <CmdTest+0x40>
8000d934:	00a08021 	move	s0,a1
	{
		dprintf("Usage: test <len> <loop>\n");		
8000d938:	3c048001 	lui	a0,0x8001
8000d93c:	0c001cc1 	jal	80007304 <dprintf>
8000d940:	2484214c 	addiu	a0,a0,8524
		return;	
8000d944:	08003681 	j	8000da04 <CmdTest+0xf8>
8000d948:	8fbf0034 	lw	ra,52(sp)
	}
	size = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000d94c:	8ca40000 	lw	a0,0(a1)
8000d950:	00002821 	move	a1,zero
8000d954:	0c001a60 	jal	80006980 <strtoul>
8000d958:	24060010 	li	a2,16
8000d95c:	0040a821 	move	s5,v0
	loop = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000d960:	8e040004 	lw	a0,4(s0)
8000d964:	00002821 	move	a1,zero
8000d968:	0c001a60 	jal	80006980 <strtoul>
8000d96c:	24060010 	li	a2,16



	flush_cache();
8000d970:	0c00187c 	jal	800061f0 <flush_cache>
8000d974:	00409821 	move	s3,v0
8000d978:	40098002 	mfc0	t1,c0_config2
	//disable L2
	s=(1<<12);
	write_32bit_cp0_register_sel(16, s, 2);
	printf("Disable L2 cache\n");
#else
	s=read_32bit_cp0_register_sel(16,  2);
8000d97c:	01292825 	or	a1,t1,t1
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
8000d980:	3c048001 	lui	a0,0x8001
8000d984:	24842168 	addiu	a0,a0,8552
8000d988:	0c001cc1 	jal	80007304 <dprintf>
8000d98c:	7ca50300 	ext	a1,a1,0xc,0x1
#endif

	for(j=0; j<loop; j++)
8000d990:	1a60001b 	blez	s3,8000da00 <CmdTest+0xf4>
8000d994:	00008821 	move	s1,zero
	{
		st=jiffies;
8000d998:	3c128001 	lui	s2,0x8001
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000d99c:	3c148030 	lui	s4,0x8030
8000d9a0:	02b48021 	addu	s0,s5,s4
8000d9a4:	36950001 	ori	s5,s4,0x1
8000d9a8:	0215a82b 	sltu	s5,s0,s5
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
8000d9ac:	3c168001 	lui	s6,0x8001
8000d9b0:	26d6217c 	addiu	s6,s6,8572
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
	{
		st=jiffies;
8000d9b4:	8e464160 	lw	a2,16736(s2)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000d9b8:	16a00007 	bnez	s5,8000d9d8 <CmdTest+0xcc>
8000d9bc:	02801021 	move	v0,s4
		{
			REG32(i)=REG32(i);
8000d9c0:	8c430000 	lw	v1,0(v0)
8000d9c4:	ac430000 	sw	v1,0(v0)
		for(i=0x80300000;i<0x80300000+size; i+=4)    //seq
		{
			REG32(i)=REG32(i);
		}
*/
		for(i=0x80300000;i<0x80300000+size; i+=32)   //cacheline
8000d9c8:	24420020 	addiu	v0,v0,32
8000d9cc:	0050182b 	sltu	v1,v0,s0
8000d9d0:	1460fffb 	bnez	v1,8000d9c0 <CmdTest+0xb4>
8000d9d4:	00000000 	nop
		{
			REG32(i)=REG32(i);
		}

		
		ed=jiffies;
8000d9d8:	8e474160 	lw	a3,16736(s2)
		printf("loop=%d, st=%d, ed=%d, spend j=%d\n", j, st,ed,ed-st);		
8000d9dc:	00e61023 	subu	v0,a3,a2
8000d9e0:	afa20010 	sw	v0,16(sp)
8000d9e4:	02c02021 	move	a0,s6
8000d9e8:	0c001cc1 	jal	80007304 <dprintf>
8000d9ec:	02202821 	move	a1,s1
#else
	s=read_32bit_cp0_register_sel(16,  2);
	printf("L2 cache ByPass=%d\n", (s&(1<<12))>>12);
#endif

	for(j=0; j<loop; j++)
8000d9f0:	26310001 	addiu	s1,s1,1
8000d9f4:	0233102a 	slt	v0,s1,s3
8000d9f8:	1440ffee 	bnez	v0,8000d9b4 <CmdTest+0xa8>
8000d9fc:	00000000 	nop

	
#endif

	
}
8000da00:	8fbf0034 	lw	ra,52(sp)
8000da04:	8fb60030 	lw	s6,48(sp)
8000da08:	8fb5002c 	lw	s5,44(sp)
8000da0c:	8fb40028 	lw	s4,40(sp)
8000da10:	8fb30024 	lw	s3,36(sp)
8000da14:	8fb20020 	lw	s2,32(sp)
8000da18:	8fb1001c 	lw	s1,28(sp)
8000da1c:	8fb00018 	lw	s0,24(sp)
8000da20:	03e00008 	jr	ra
8000da24:	27bd0038 	addiu	sp,sp,56

8000da28 <CmdXModem>:
//==============================================================

//------------------------------------------------------------------------
#ifndef CONFIG_RTL8196E
int CmdXModem(int argc, char* argv[])
{
8000da28:	27bdffd8 	addiu	sp,sp,-40
8000da2c:	afbf0024 	sw	ra,36(sp)
8000da30:	afb30020 	sw	s3,32(sp)
8000da34:	afb2001c 	sw	s2,28(sp)
8000da38:	afb10018 	sw	s1,24(sp)
8000da3c:	afb00014 	sw	s0,20(sp)
8000da40:	00808021 	move	s0,a0
	unsigned char *load_buf = (char*)0x80300000;
	unsigned int jump=0;
	//unsigned char *dest_buf = (char*)0xbd000000;

	if( argc < 1 ) 
8000da44:	1c800006 	bgtz	a0,8000da60 <CmdXModem+0x38>
8000da48:	00a08821 	move	s1,a1
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
8000da4c:	3c048001 	lui	a0,0x8001
8000da50:	0c001cc1 	jal	80007304 <dprintf>
8000da54:	248421a0 	addiu	a0,a0,8608
		flush_cache(); 
		prom_printf("\nJump to.......\n");

		jumpF();
	}
}; 
8000da58:	080036c7 	j	8000db1c <CmdXModem+0xf4>
8000da5c:	8fbf0024 	lw	ra,36(sp)
	if( argc < 1 ) 
	{
		dprintf("Usage: xmodem <buf_addr> [jump]\n");		
		return;	
	}
	load_buf = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000da60:	8ca40000 	lw	a0,0(a1)
8000da64:	00002821 	move	a1,zero
8000da68:	0c001a60 	jal	80006980 <strtoul>
8000da6c:	24060010 	li	a2,16
8000da70:	00409021 	move	s2,v0
	
	if(argc>1)	
8000da74:	2a100002 	slti	s0,s0,2
8000da78:	16000006 	bnez	s0,8000da94 <CmdXModem+0x6c>
8000da7c:	00009821 	move	s3,zero
	jump = strtoul((const char*)(argv[1]), (char **)NULL, 16);	
8000da80:	8e240004 	lw	a0,4(s1)
8000da84:	00002821 	move	a1,zero
8000da88:	0c001a60 	jal	80006980 <strtoul>
8000da8c:	24060010 	li	a2,16
8000da90:	00409821 	move	s3,v0
	

	int len;
	len=xmodem_receive(load_buf);
8000da94:	0c002f51 	jal	8000bd44 <xmodem_receive>
8000da98:	02402021 	move	a0,s2
		if(len!=0)
8000da9c:	10400007 	beqz	v0,8000dabc <CmdXModem+0x94>
8000daa0:	00408021 	move	s0,v0
		{	printf("Rx len=%d \n", len);			
8000daa4:	3c048001 	lui	a0,0x8001
8000daa8:	248421c4 	addiu	a0,a0,8644
8000daac:	0c001cc1 	jal	80007304 <dprintf>
8000dab0:	00402821 	move	a1,v0
8000dab4:	080036c6 	j	8000db18 <CmdXModem+0xf0>
8000dab8:	02001021 	move	v0,s0
			return  len;			
		}
		else
			printf("Download failed!!\n");
8000dabc:	3c048001 	lui	a0,0x8001
8000dac0:	0c001cc1 	jal	80007304 <dprintf>
8000dac4:	248421d0 	addiu	a0,a0,8656


	if(jump)
8000dac8:	12600014 	beqz	s3,8000db1c <CmdXModem+0xf4>
8000dacc:	8fbf0024 	lw	ra,36(sp)
	{	
		void (*jumpF)(void);
		jumpF = (void *)(load_buf);
	
		REG32(GIMR_REG)=0; // mask all interrupt	    
8000dad0:	3c02b800 	lui	v0,0xb800
8000dad4:	34423000 	ori	v0,v0,0x3000
8000dad8:	ac400000 	sw	zero,0(v0)
8000dadc:	40016000 	mfc0	at,c0_status
8000dae0:	34210001 	ori	at,at,0x1
8000dae4:	38210001 	xori	at,at,0x1
8000dae8:	40816000 	mtc0	at,c0_status
8000daec:	000000c0 	ehb
	...
		cli();
	
		flush_cache(); 
8000dafc:	0c00187c 	jal	800061f0 <flush_cache>
8000db00:	00000000 	nop
		prom_printf("\nJump to.......\n");
8000db04:	3c048001 	lui	a0,0x8001
8000db08:	0c001d43 	jal	8000750c <prom_printf>
8000db0c:	248421e4 	addiu	a0,a0,8676

		jumpF();
8000db10:	0240f809 	jalr	s2
8000db14:	00000000 	nop
	}
}; 
8000db18:	8fbf0024 	lw	ra,36(sp)
8000db1c:	8fb30020 	lw	s3,32(sp)
8000db20:	8fb2001c 	lw	s2,28(sp)
8000db24:	8fb10018 	lw	s1,24(sp)
8000db28:	8fb00014 	lw	s0,20(sp)
8000db2c:	03e00008 	jr	ra
8000db30:	27bd0028 	addiu	sp,sp,40

8000db34 <MxSpdupThanLexra>:
//==============================================================



void MxSpdupThanLexra()
{
8000db34:	27bdffe8 	addiu	sp,sp,-24
8000db38:	afbf0014 	sw	ra,20(sp)

	//printf("MxSpdupThanLexra\n");

	#define GET_BITVAL(v,bitpos,pat) ((v& ((unsigned int)pat<<bitpos))>>bitpos)
	#define RANG5  0x1f
	unsigned char m2x_freq_sel=GET_BITVAL(REG32(SYS_HW_STRAP), 10, RANG5);
8000db3c:	3c02b800 	lui	v0,0xb800
8000db40:	34420008 	ori	v0,v0,0x8
8000db44:	8c420000 	lw	v0,0(v0)
	

	if(m2x_freq_sel>= 0x0f)           // M2x > lexra=200M   
8000db48:	7c422280 	ext	v0,v0,0xa,0x5
8000db4c:	2c42000f 	sltiu	v0,v0,15
8000db50:	14400026 	bnez	v0,8000dbec <MxSpdupThanLexra+0xb8>
8000db54:	8fbf0014 	lw	ra,20(sp)
		printf("Mx clk > Lexra clk\n");
8000db58:	3c048001 	lui	a0,0x8001
8000db5c:	0c001cc1 	jal	80007304 <dprintf>
8000db60:	248421f8 	addiu	a0,a0,8696
	else
		return ;

	//-------------------------
  	request_IRQ(8, &irq_timer, NULL); 
8000db64:	24040008 	li	a0,8
8000db68:	3c058001 	lui	a1,0x8001
8000db6c:	24a52f10 	addiu	a1,a1,12048
8000db70:	0c000274 	jal	800009d0 <request_IRQ>
8000db74:	00003021 	move	a2,zero


	extern long glexra_clock;
       timer_init(glexra_clock);	   //run 10msec
8000db78:	3c028001 	lui	v0,0x8001
8000db7c:	0c003260 	jal	8000c980 <timer_init>
8000db80:	8c442f00 	lw	a0,12032(v0)
	//--------------------------
	
	#define SYS_HS0_CTRL 0xb80000a0
	#define BIT(x)	(1 << x)	
	REG32(SYS_HS0_CTRL) |= BIT(0) | BIT(1) | BIT(2);   // LX0 > Mx clock
8000db84:	3c02b800 	lui	v0,0xb800
8000db88:	344300a0 	ori	v1,v0,0xa0
8000db8c:	8c640000 	lw	a0,0(v1)
8000db90:	34840007 	ori	a0,a0,0x7
8000db94:	ac640000 	sw	a0,0(v1)
	
	
		#if 1			
			//printf("llx0\n");
			REG32(SYS_BIST_CTRL) |= (1<<2) ;	  //lock bus arb2
8000db98:	34420014 	ori	v0,v0,0x14
8000db9c:	8c430000 	lw	v1,0(v0)
8000dba0:	34630004 	ori	v1,v1,0x4
8000dba4:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==0)  {}; //wait bit to 1, is mean lock ok	
8000dba8:	3c03b800 	lui	v1,0xb800
8000dbac:	34630020 	ori	v1,v1,0x20
8000dbb0:	8c620000 	lw	v0,0(v1)
8000dbb4:	30420001 	andi	v0,v0,0x1
8000dbb8:	1040fffd 	beqz	v0,8000dbb0 <MxSpdupThanLexra+0x7c>
8000dbbc:	3c02b800 	lui	v0,0xb800
	//	__asm__ volatile("nop");


		#if 1
			//printf("ulx0\n");	
			REG32(SYS_BIST_CTRL) &= ~(1<<2);	//unlock
8000dbc0:	34420014 	ori	v0,v0,0x14
8000dbc4:	8c440000 	lw	a0,0(v0)
8000dbc8:	2403fffb 	li	v1,-5
8000dbcc:	00831824 	and	v1,a0,v1
8000dbd0:	ac430000 	sw	v1,0(v0)
			while( (REG32(SYS_BIST_DONE)&(1<<0))==(1<<0)) {};  //wait bit to 0  unlock
8000dbd4:	3c03b800 	lui	v1,0xb800
8000dbd8:	34630020 	ori	v1,v1,0x20
8000dbdc:	8c620000 	lw	v0,0(v1)
8000dbe0:	30420001 	andi	v0,v0,0x1
8000dbe4:	1440fffd 	bnez	v0,8000dbdc <MxSpdupThanLexra+0xa8>
8000dbe8:	8fbf0014 	lw	ra,20(sp)
			//while( (REG32(SYS_BIST_DONE)&(1<<2))==(1<<2)) {};  //wait bit to 0  unlock				
		#endif

			//printf("done\n");

}
8000dbec:	03e00008 	jr	ra
8000dbf0:	27bd0018 	addiu	sp,sp,24

8000dbf4 <check_cpu_speed>:
#else
unsigned long loops_per_sec = 0x1db000 * HZ;	// @CPU 390MHz, DDR 195 MHz (this will be update in check_cpu_speed())
#endif

int check_cpu_speed(void)
{
8000dbf4:	27bdffd8 	addiu	sp,sp,-40
8000dbf8:	afbf0024 	sw	ra,36(sp)
8000dbfc:	afb20020 	sw	s2,32(sp)
8000dc00:	afb1001c 	sw	s1,28(sp)
8000dc04:	afb00018 	sw	s0,24(sp)

	unsigned volatile long ticks, loopbit;
	int lps_precision = LPS_PREC;
      
  // RTL8198
  	request_IRQ(14, &irq_timer, NULL); 
8000dc08:	2404000e 	li	a0,14
8000dc0c:	3c058001 	lui	a1,0x8001
8000dc10:	24a52f10 	addiu	a1,a1,12048
8000dc14:	0c000274 	jal	800009d0 <request_IRQ>
8000dc18:	00003021 	move	a2,zero

	extern long glexra_clock;
//	printf("timer init\n");
    timer_init(glexra_clock);	
8000dc1c:	3c028001 	lui	v0,0x8001
8000dc20:	0c003260 	jal	8000c980 <timer_init>
8000dc24:	8c442f00 	lw	a0,12032(v0)

//return 999;

	loops_per_jiffy = (1<<12);
8000dc28:	24031000 	li	v1,4096
8000dc2c:	3c028001 	lui	v0,0x8001
8000dc30:	ac432f28 	sw	v1,12072(v0)
	while (loops_per_jiffy <<= 1) {
8000dc34:	00408821 	move	s1,v0
8000dc38:	08003722 	j	8000dc88 <check_cpu_speed+0x94>
8000dc3c:	3c108001 	lui	s0,0x8001
		/* wait for "start of" clock tick */
		ticks = jiffies;
8000dc40:	8e024160 	lw	v0,16736(s0)
8000dc44:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies)
8000dc48:	8fa30010 	lw	v1,16(sp)
8000dc4c:	8e024160 	lw	v0,16736(s0)
8000dc50:	1062fffd 	beq	v1,v0,8000dc48 <check_cpu_speed+0x54>
8000dc54:	00000000 	nop
			/* nothing */;
		/* Go .. */
		ticks = jiffies;
8000dc58:	8e024160 	lw	v0,16736(s0)
8000dc5c:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
8000dc60:	8e242f28 	lw	a0,12072(s1)
8000dc64:	0c00324c 	jal	8000c930 <__delay>
8000dc68:	00000000 	nop
		ticks = jiffies - ticks;
8000dc6c:	8e034160 	lw	v1,16736(s0)
8000dc70:	8fa20010 	lw	v0,16(sp)
8000dc74:	00621023 	subu	v0,v1,v0
8000dc78:	afa20010 	sw	v0,16(sp)
		if (ticks)
8000dc7c:	8fa20010 	lw	v0,16(sp)
8000dc80:	14400007 	bnez	v0,8000dca0 <check_cpu_speed+0xac>
8000dc84:	3c028001 	lui	v0,0x8001
    timer_init(glexra_clock);	

//return 999;

	loops_per_jiffy = (1<<12);
	while (loops_per_jiffy <<= 1) {
8000dc88:	8e222f28 	lw	v0,12072(s1)
8000dc8c:	00021040 	sll	v0,v0,0x1
8000dc90:	ae222f28 	sw	v0,12072(s1)
8000dc94:	8e222f28 	lw	v0,12072(s1)
8000dc98:	1440ffe9 	bnez	v0,8000dc40 <check_cpu_speed+0x4c>
8000dc9c:	3c028001 	lui	v0,0x8001
		if (ticks)
			break;
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
8000dca0:	8c432f28 	lw	v1,12072(v0)
8000dca4:	00031842 	srl	v1,v1,0x1
8000dca8:	ac432f28 	sw	v1,12072(v0)
	loopbit = loops_per_jiffy;
8000dcac:	8c422f28 	lw	v0,12072(v0)
8000dcb0:	afa20014 	sw	v0,20(sp)
8000dcb4:	24120007 	li	s2,7
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
8000dcb8:	3c118001 	lui	s1,0x8001
		ticks = jiffies;
8000dcbc:	0800374b 	j	8000dd2c <check_cpu_speed+0x138>
8000dcc0:	3c108001 	lui	s0,0x8001
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
	{
		loops_per_jiffy |= loopbit;
8000dcc4:	8e222f28 	lw	v0,12072(s1)
8000dcc8:	8fa30014 	lw	v1,20(sp)
8000dccc:	00621025 	or	v0,v1,v0
8000dcd0:	ae222f28 	sw	v0,12072(s1)
		ticks = jiffies;
8000dcd4:	8e024160 	lw	v0,16736(s0)
8000dcd8:	afa20010 	sw	v0,16(sp)
		while (ticks == jiffies);
8000dcdc:	8fa30010 	lw	v1,16(sp)
8000dce0:	8e024160 	lw	v0,16736(s0)
8000dce4:	1062fffd 	beq	v1,v0,8000dcdc <check_cpu_speed+0xe8>
8000dce8:	00000000 	nop
		ticks = jiffies;
8000dcec:	8e024160 	lw	v0,16736(s0)
8000dcf0:	afa20010 	sw	v0,16(sp)
		__delay(loops_per_jiffy);
8000dcf4:	8e242f28 	lw	a0,12072(s1)
8000dcf8:	0c00324c 	jal	8000c930 <__delay>
8000dcfc:	00000000 	nop
		if (jiffies != ticks)	/* longer than 1 tick */
8000dd00:	8e034160 	lw	v1,16736(s0)
8000dd04:	8fa20010 	lw	v0,16(sp)
8000dd08:	10620006 	beq	v1,v0,8000dd24 <check_cpu_speed+0x130>
8000dd0c:	00000000 	nop
			loops_per_jiffy &= ~loopbit;
8000dd10:	8fa20014 	lw	v0,20(sp)
8000dd14:	8e232f28 	lw	v1,12072(s1)
8000dd18:	00021027 	nor	v0,zero,v0
8000dd1c:	00431024 	and	v0,v0,v1
8000dd20:	ae222f28 	sw	v0,12072(s1)
	}
/* Do a binary approximation to get loops_per_jiffy set to equal one clock
   (up to lps_precision bits) */
	loops_per_jiffy >>= 1;
	loopbit = loops_per_jiffy;
	while ( lps_precision-- && (loopbit >>= 1) ) 
8000dd24:	12400007 	beqz	s2,8000dd44 <check_cpu_speed+0x150>
8000dd28:	2652ffff 	addiu	s2,s2,-1
8000dd2c:	8fa20014 	lw	v0,20(sp)
8000dd30:	00021042 	srl	v0,v0,0x1
8000dd34:	afa20014 	sw	v0,20(sp)
8000dd38:	8fa20014 	lw	v0,20(sp)
8000dd3c:	1440ffe1 	bnez	v0,8000dcc4 <check_cpu_speed+0xd0>
8000dd40:	00000000 	nop
	
	//timer_stop();	//wei del, because not close timer
	//free_IRQ(8);
	//prom_printf("cpu run %d.%d MIPS\n", loops_per_jiffy/(500000/HZ),      (loops_per_jiffy/(5000/HZ)) % 100);
//	return ((loops_per_jiffy/(500000/HZ))+1);
	return ((loops_per_jiffy/(500000/HZ))+1)*2;	 //for 1074k 
8000dd44:	3c028001 	lui	v0,0x8001
8000dd48:	8c432f28 	lw	v1,12072(v0)
8000dd4c:	3c02d1b7 	lui	v0,0xd1b7
8000dd50:	34421759 	ori	v0,v0,0x1759
8000dd54:	00620019 	multu	v1,v0
8000dd58:	00001010 	mfhi	v0
8000dd5c:	00021302 	srl	v0,v0,0xc
8000dd60:	24420001 	addiu	v0,v0,1
	
}
8000dd64:	00021040 	sll	v0,v0,0x1
8000dd68:	8fbf0024 	lw	ra,36(sp)
8000dd6c:	8fb20020 	lw	s2,32(sp)
8000dd70:	8fb1001c 	lw	s1,28(sp)
8000dd74:	8fb00018 	lw	s0,24(sp)
8000dd78:	03e00008 	jr	ra
8000dd7c:	27bd0028 	addiu	sp,sp,40

8000dd80 <CmdTimerInit>:


//============================================================================

int CmdTimerInit(int argc, char* argv[])
{
8000dd80:	27bdffe8 	addiu	sp,sp,-24
8000dd84:	afbf0014 	sw	ra,20(sp)
		}
	}
#endif
	
#else
	int clk=check_cpu_speed();
8000dd88:	0c0036fd 	jal	8000dbf4 <check_cpu_speed>
8000dd8c:	00000000 	nop
	printf("CPU=%d MHz\n", clk);
8000dd90:	3c048001 	lui	a0,0x8001
8000dd94:	2484220c 	addiu	a0,a0,8716
8000dd98:	0c001cc1 	jal	80007304 <dprintf>
8000dd9c:	00402821 	move	a1,v0
#endif




}
8000dda0:	8fbf0014 	lw	ra,20(sp)
8000dda4:	03e00008 	jr	ra
8000dda8:	27bd0018 	addiu	sp,sp,24

8000ddac <CmdSFlw>:
		return 0;
}
//---------------------------------------------------------------------------
#ifdef CONFIG_SPI_FLASH
int CmdSFlw(int argc, char* argv[])
{
8000ddac:	27bdffd0 	addiu	sp,sp,-48
8000ddb0:	afbf002c 	sw	ra,44(sp)
8000ddb4:	afb20028 	sw	s2,40(sp)
8000ddb8:	afb10024 	sw	s1,36(sp)
8000ddbc:	afb00020 	sw	s0,32(sp)
8000ddc0:	00a08021 	move	s0,a1
	unsigned int  cnt2=0;//strtoul((const char*)(argv[3]), (char **)NULL, 16);	
	unsigned int  dst_flash_addr_offset=strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000ddc4:	8ca40000 	lw	a0,0(a1)
8000ddc8:	00002821 	move	a1,zero
8000ddcc:	0c001a60 	jal	80006980 <strtoul>
8000ddd0:	24060010 	li	a2,16
8000ddd4:	00408821 	move	s1,v0
	unsigned int  src_RAM_addr=strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000ddd8:	8e040004 	lw	a0,4(s0)
8000dddc:	00002821 	move	a1,zero
8000dde0:	0c001a60 	jal	80006980 <strtoul>
8000dde4:	24060010 	li	a2,16
8000dde8:	00409021 	move	s2,v0
	unsigned int  length=strtoul((const char*)(argv[2]), (char **)NULL, 16);
8000ddec:	8e040008 	lw	a0,8(s0)
8000ddf0:	00002821 	move	a1,zero
8000ddf4:	0c001a60 	jal	80006980 <strtoul>
8000ddf8:	24060010 	li	a2,16
8000ddfc:	00408021 	move	s0,v0
	unsigned int  end_of_RAM_addr=src_RAM_addr+length;	
	printf("Write 0x%x Bytes to SPI flash#%d, offset 0x%x<0x%x>, from RAM 0x%x to 0x%x\n" ,length,cnt2+1,dst_flash_addr_offset,dst_flash_addr_offset+0xbd000000,src_RAM_addr,end_of_RAM_addr);
8000de00:	3c02bd00 	lui	v0,0xbd00
8000de04:	02221021 	addu	v0,s1,v0
8000de08:	afa20010 	sw	v0,16(sp)
8000de0c:	afb20014 	sw	s2,20(sp)
8000de10:	02121021 	addu	v0,s0,s2
8000de14:	afa20018 	sw	v0,24(sp)
8000de18:	3c048001 	lui	a0,0x8001
8000de1c:	24842218 	addiu	a0,a0,8728
8000de20:	02002821 	move	a1,s0
8000de24:	24060001 	li	a2,1
8000de28:	0c001cc1 	jal	80007304 <dprintf>
8000de2c:	02203821 	move	a3,s1
	printf("(Y)es, (N)o->");
8000de30:	3c048001 	lui	a0,0x8001
8000de34:	0c001cc1 	jal	80007304 <dprintf>
8000de38:	24842264 	addiu	a0,a0,8804
	if (YesOrNo())
8000de3c:	0c0032d5 	jal	8000cb54 <YesOrNo>
8000de40:	00000000 	nop
8000de44:	1040000a 	beqz	v0,8000de70 <CmdSFlw+0xc4>
8000de48:	00000000 	nop
	{
		spi_pio_init();
8000de4c:	0c001214 	jal	80004850 <spi_pio_init>
8000de50:	00000000 	nop
		  #if defined(SUPPORT_SPI_MIO_8198_8196C) && defined(CONFIG_SPI_FLASH)
			spi_flw_image_mio_8198(cnt2, dst_flash_addr_offset, (unsigned char*)src_RAM_addr , length);	
8000de54:	00002021 	move	a0,zero
8000de58:	02202821 	move	a1,s1
8000de5c:	02403021 	move	a2,s2
8000de60:	0c0011e9 	jal	800047a4 <spi_flw_image_mio_8198>
8000de64:	02003821 	move	a3,s0
			spi_flw_image(cnt2, dst_flash_addr_offset, (unsigned char*)src_RAM_addr , length);	
		 #endif
	}//end if YES
	else
		printf("Abort!\n");
}
8000de68:	080037a0 	j	8000de80 <CmdSFlw+0xd4>
8000de6c:	8fbf002c 	lw	ra,44(sp)
		  #else			
			spi_flw_image(cnt2, dst_flash_addr_offset, (unsigned char*)src_RAM_addr , length);	
		 #endif
	}//end if YES
	else
		printf("Abort!\n");
8000de70:	3c048001 	lui	a0,0x8001
8000de74:	0c001cc1 	jal	80007304 <dprintf>
8000de78:	24842274 	addiu	a0,a0,8820
}
8000de7c:	8fbf002c 	lw	ra,44(sp)
8000de80:	8fb20028 	lw	s2,40(sp)
8000de84:	8fb10024 	lw	s1,36(sp)
8000de88:	8fb00020 	lw	s0,32(sp)
8000de8c:	03e00008 	jr	ra
8000de90:	27bd0030 	addiu	sp,sp,48

8000de94 <CmdFlr>:
}



int CmdFlr(int argc, char* argv[])
{
8000de94:	27bdffe0 	addiu	sp,sp,-32
8000de98:	afbf001c 	sw	ra,28(sp)
8000de9c:	afb20018 	sw	s2,24(sp)
8000dea0:	afb10014 	sw	s1,20(sp)
8000dea4:	afb00010 	sw	s0,16(sp)
8000dea8:	00a08021 	move	s0,a1
	unsigned long dst,src;
	unsigned int length;
	//unsigned char TARGET;
//#define  FLASH_READ_BYTE	4096

	dst = strtoul((const char*)(argv[0]), (char **)NULL, 16);
8000deac:	8ca40000 	lw	a0,0(a1)
8000deb0:	00002821 	move	a1,zero
8000deb4:	0c001a60 	jal	80006980 <strtoul>
8000deb8:	24060010 	li	a2,16
8000debc:	00408821 	move	s1,v0
	src = strtoul((const char*)(argv[1]), (char **)NULL, 16);
8000dec0:	8e040004 	lw	a0,4(s0)
8000dec4:	00002821 	move	a1,zero
8000dec8:	0c001a60 	jal	80006980 <strtoul>
8000decc:	24060010 	li	a2,16
8000ded0:	00409021 	move	s2,v0
	length= strtoul((const char*)(argv[2]), (char **)NULL, 16);		
8000ded4:	8e040008 	lw	a0,8(s0)
8000ded8:	00002821 	move	a1,zero
8000dedc:	0c001a60 	jal	80006980 <strtoul>
8000dee0:	24060010 	li	a2,16
8000dee4:	00408021 	move	s0,v0
/*Cyrus Tsai*/
/*file_length_to_server;*/
//length=file_length_to_client;
//length=length & (~0xffff)+0x10000;
//dst=image_address;
file_length_to_client=length;
8000dee8:	3c028001 	lui	v0,0x8001
8000deec:	ac5031a8 	sw	s0,12712(v0)
/*Cyrus Tsai*/

	printf("Flash read from %X to %X with %X bytes	?\n",src,dst,length);
8000def0:	3c048001 	lui	a0,0x8001
8000def4:	2484227c 	addiu	a0,a0,8828
8000def8:	02402821 	move	a1,s2
8000defc:	02203021 	move	a2,s1
8000df00:	0c001cc1 	jal	80007304 <dprintf>
8000df04:	02003821 	move	a3,s0
	printf("(Y)es , (N)o ? --> ");
8000df08:	3c048001 	lui	a0,0x8001
8000df0c:	0c001cc1 	jal	80007304 <dprintf>
8000df10:	248422a8 	addiu	a0,a0,8872

	if (YesOrNo())
8000df14:	0c0032d5 	jal	8000cb54 <YesOrNo>
8000df18:	00000000 	nop
8000df1c:	10400011 	beqz	v0,8000df64 <CmdFlr+0xd0>
8000df20:	3c048001 	lui	a0,0x8001
		//    if ( flashread(&TARGET, src+i,1) )
		//	printf("Flash Read Successed!, target %X\n",TARGET);
		//    else
		//	printf("Flash Read Failed!\n");
		//  }	
		    if (flashread(dst, src, length))
8000df24:	02202021 	move	a0,s1
8000df28:	02402821 	move	a1,s2
8000df2c:	0c0011c2 	jal	80004708 <flashread>
8000df30:	02003021 	move	a2,s0
8000df34:	10400006 	beqz	v0,8000df50 <CmdFlr+0xbc>
8000df38:	00000000 	nop
			printf("Flash Read Successed!\n");
8000df3c:	3c048001 	lui	a0,0x8001
8000df40:	0c001cc1 	jal	80007304 <dprintf>
8000df44:	248422bc 	addiu	a0,a0,8892
			printf("Flash Read Failed!\n");
	else
		printf("Abort!\n");
//#undef	FLASH_READ_BYTE		4096

}
8000df48:	080037dc 	j	8000df70 <CmdFlr+0xdc>
8000df4c:	8fbf001c 	lw	ra,28(sp)
		//	printf("Flash Read Failed!\n");
		//  }	
		    if (flashread(dst, src, length))
			printf("Flash Read Successed!\n");
		    else
			printf("Flash Read Failed!\n");
8000df50:	3c048001 	lui	a0,0x8001
8000df54:	0c001cc1 	jal	80007304 <dprintf>
8000df58:	248422d4 	addiu	a0,a0,8916
	else
		printf("Abort!\n");
//#undef	FLASH_READ_BYTE		4096

}
8000df5c:	080037dc 	j	8000df70 <CmdFlr+0xdc>
8000df60:	8fbf001c 	lw	ra,28(sp)
		    if (flashread(dst, src, length))
			printf("Flash Read Successed!\n");
		    else
			printf("Flash Read Failed!\n");
	else
		printf("Abort!\n");
8000df64:	0c001cc1 	jal	80007304 <dprintf>
8000df68:	24842274 	addiu	a0,a0,8820
//#undef	FLASH_READ_BYTE		4096

}
8000df6c:	8fbf001c 	lw	ra,28(sp)
8000df70:	8fb20018 	lw	s2,24(sp)
8000df74:	8fb10014 	lw	s1,20(sp)
8000df78:	8fb00010 	lw	s0,16(sp)
8000df7c:	03e00008 	jr	ra
8000df80:	27bd0020 	addiu	sp,sp,32

8000df84 <CmdFli>:
Flash Utility
--------------------------------------------------------------------------
*/
#if defined(CONFIG_SPI_FLASH)
int CmdFli(int argc, char* argv[])
{
8000df84:	27bdffe8 	addiu	sp,sp,-24
8000df88:	afbf0014 	sw	ra,20(sp)
	initFlash();
8000df8c:	0c00303f 	jal	8000c0fc <initFlash>
8000df90:	00000000 	nop
}
8000df94:	8fbf0014 	lw	ra,20(sp)
8000df98:	03e00008 	jr	ra
8000df9c:	27bd0018 	addiu	sp,sp,24

8000dfa0 <CmdDumpByte>:

}

//---------------------------------------------------------------------------
int CmdDumpByte( int argc, char* argv[] )
{
8000dfa0:	27bdffe0 	addiu	sp,sp,-32
8000dfa4:	afbf001c 	sw	ra,28(sp)
8000dfa8:	afb10018 	sw	s1,24(sp)
8000dfac:	afb00014 	sw	s0,20(sp)
	
	unsigned long src;
	unsigned int len,i;

	if(argc<1)
8000dfb0:	1c800006 	bgtz	a0,8000dfcc <CmdDumpByte+0x2c>
8000dfb4:	00a08021 	move	s0,a1
	{	dprintf("Wrong argument number!\r\n");
8000dfb8:	3c048001 	lui	a0,0x8001
8000dfbc:	0c001cc1 	jal	80007304 <dprintf>
8000dfc0:	24841ff4 	addiu	a0,a0,8180
		return;
8000dfc4:	08003802 	j	8000e008 <CmdDumpByte+0x68>
8000dfc8:	8fbf001c 	lw	ra,28(sp)
	}
	
	src = strtoul((const char*)(argv[0]), (char **)NULL, 16);		
8000dfcc:	8ca40000 	lw	a0,0(a1)
8000dfd0:	00002821 	move	a1,zero
8000dfd4:	0c001a60 	jal	80006980 <strtoul>
8000dfd8:	24060010 	li	a2,16
8000dfdc:	00408821 	move	s1,v0
	if(!argv[1])
8000dfe0:	8e040004 	lw	a0,4(s0)
8000dfe4:	10800005 	beqz	a0,8000dffc <CmdDumpByte+0x5c>
8000dfe8:	24050010 	li	a1,16
		len = 16;
	else
	len= strtoul((const char*)(argv[1]), (char **)NULL, 10);			
8000dfec:	00002821 	move	a1,zero
8000dff0:	0c001a60 	jal	80006980 <strtoul>
8000dff4:	2406000a 	li	a2,10
8000dff8:	00402821 	move	a1,v0


	ddump((unsigned char *)src,len);
8000dffc:	0c001cce 	jal	80007338 <ddump>
8000e000:	02202021 	move	a0,s1
}
8000e004:	8fbf001c 	lw	ra,28(sp)
8000e008:	8fb10018 	lw	s1,24(sp)
8000e00c:	8fb00014 	lw	s0,20(sp)
8000e010:	03e00008 	jr	ra
8000e014:	27bd0020 	addiu	sp,sp,32

8000e018 <CmdIp>:
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
{
8000e018:	27bdffc8 	addiu	sp,sp,-56
8000e01c:	afbf0034 	sw	ra,52(sp)
8000e020:	afb20030 	sw	s2,48(sp)
8000e024:	afb1002c 	sw	s1,44(sp)
8000e028:	afb00028 	sw	s0,40(sp)
	unsigned char  *ptr;
	unsigned int i;
	int  ip[4];
	
	if (argc==0)
8000e02c:	1480000d 	bnez	a0,8000e064 <CmdIp+0x4c>
8000e030:	27b10018 	addiu	s1,sp,24
	{	
		printf(" Target Address=%d.%d.%d.%d\n",
8000e034:	3c028001 	lui	v0,0x8001
8000e038:	904543f0 	lbu	a1,17392(v0)
8000e03c:	244243f0 	addiu	v0,v0,17392
8000e040:	90460001 	lbu	a2,1(v0)
8000e044:	90470002 	lbu	a3,2(v0)
8000e048:	90420003 	lbu	v0,3(v0)
8000e04c:	afa20010 	sw	v0,16(sp)
8000e050:	3c048001 	lui	a0,0x8001
8000e054:	0c001cc1 	jal	80007304 <dprintf>
8000e058:	248422e8 	addiu	a0,a0,8936
#ifdef HTTP_SERVER
		printf("   Http Address=%d.%d.%d.%d\n",
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[0], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[1], 
		arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[2], arptable_tftp[HTTPD_ARPENTRY].ipaddr.ip[3]);
#endif
		return;	 
8000e05c:	08003847 	j	8000e11c <CmdIp+0x104>
8000e060:	8fbf0034 	lw	ra,52(sp)
	}			
	
	ptr = argv[0];
8000e064:	8cb00000 	lw	s0,0(a1)
#if defined(CONFIG_BOOT_DEBUG_ENABLE)	
//---------------------------------------------------------------------------
/* This command can be used to configure host ip and target ip	*/

extern char eth0_mac[6];
int CmdIp(int argc, char* argv[])
8000e068:	27b20028 	addiu	s2,sp,40
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
8000e06c:	02002021 	move	a0,s0
8000e070:	00002821 	move	a1,zero
8000e074:	0c001a2c 	jal	800068b0 <strtol>
8000e078:	2406000a 	li	a2,10
8000e07c:	ae220000 	sw	v0,0(s1)
		ptr = strchr(ptr, '.');
8000e080:	02002021 	move	a0,s0
8000e084:	0c0019bb 	jal	800066ec <strchr>
8000e088:	2405002e 	li	a1,46
		ptr++;
8000e08c:	26310004 	addiu	s1,s1,4
		return;	 
	}			
	
	ptr = argv[0];

	for(i=0; i< 4; i++)
8000e090:	1632fff6 	bne	s1,s2,8000e06c <CmdIp+0x54>
8000e094:	24500001 	addiu	s0,v0,1
	{
		ip[i]=strtol((const char *)ptr,(char **)NULL, 10);		
		ptr = strchr(ptr, '.');
		ptr++;
	}
	arptable_tftp[TFTP_SERVER].ipaddr.ip[0]=ip[0];
8000e098:	8fa50018 	lw	a1,24(sp)
8000e09c:	3c028001 	lui	v0,0x8001
8000e0a0:	a04543f0 	sb	a1,17392(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[1]=ip[1];
8000e0a4:	8fa6001c 	lw	a2,28(sp)
8000e0a8:	244243f0 	addiu	v0,v0,17392
8000e0ac:	a0460001 	sb	a2,1(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[2]=ip[2];
8000e0b0:	8fa70020 	lw	a3,32(sp)
8000e0b4:	a0470002 	sb	a3,2(v0)
	arptable_tftp[TFTP_SERVER].ipaddr.ip[3]=ip[3];
8000e0b8:	8fa40024 	lw	a0,36(sp)
8000e0bc:	a0440003 	sb	a0,3(v0)
/*replace the MAC address middle 4 bytes.*/
	eth0_mac[1]=ip[0];
8000e0c0:	7c054c20 	seb	t1,a1
8000e0c4:	3c088001 	lui	t0,0x8001
8000e0c8:	250329e0 	addiu	v1,t0,10720
8000e0cc:	a0690001 	sb	t1,1(v1)
	eth0_mac[2]=ip[1];
8000e0d0:	7c065420 	seb	t2,a2
8000e0d4:	a06a0002 	sb	t2,2(v1)
	eth0_mac[3]=ip[2];
8000e0d8:	7c075c20 	seb	t3,a3
8000e0dc:	a06b0003 	sb	t3,3(v1)
	eth0_mac[4]=ip[3];
8000e0e0:	7c046420 	seb	t4,a0
8000e0e4:	a06c0004 	sb	t4,4(v1)
	arptable_tftp[TFTP_SERVER].node[5]=eth0_mac[5];
8000e0e8:	90630005 	lbu	v1,5(v1)
8000e0ec:	a0430009 	sb	v1,9(v0)
	arptable_tftp[TFTP_SERVER].node[4]=eth0_mac[4];
8000e0f0:	a04c0008 	sb	t4,8(v0)
	arptable_tftp[TFTP_SERVER].node[3]=eth0_mac[3];
8000e0f4:	a04b0007 	sb	t3,7(v0)
	arptable_tftp[TFTP_SERVER].node[2]=eth0_mac[2];
8000e0f8:	a04a0006 	sb	t2,6(v0)
	arptable_tftp[TFTP_SERVER].node[1]=eth0_mac[1];
8000e0fc:	a0490005 	sb	t1,5(v0)
	arptable_tftp[TFTP_SERVER].node[0]=eth0_mac[0];
8000e100:	910329e0 	lbu	v1,10720(t0)
8000e104:	a0430004 	sb	v1,4(v0)
	prom_printf("Now your Target IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
8000e108:	afa40010 	sw	a0,16(sp)
8000e10c:	3c048001 	lui	a0,0x8001
8000e110:	0c001d43 	jal	8000750c <prom_printf>
8000e114:	24842308 	addiu	a0,a0,8968
	arptable[ARP_SERVER].ipaddr.ip[2]=ip[2];
	arptable[ARP_SERVER].ipaddr.ip[3]=ip[3];
	prom_printf("Now your Host IP is %d.%d.%d.%d\n", ip[0],ip[1],ip[2],ip[3]);
#endif	
		
}	
8000e118:	8fbf0034 	lw	ra,52(sp)
8000e11c:	8fb20030 	lw	s2,48(sp)
8000e120:	8fb1002c 	lw	s1,44(sp)
8000e124:	8fb00028 	lw	s0,40(sp)
8000e128:	03e00008 	jr	ra
8000e12c:	27bd0038 	addiu	sp,sp,56

8000e130 <CmdCfn>:



extern unsigned long ETH0_ADD;
int CmdCfn(int argc, char* argv[])
{
8000e130:	27bdffe0 	addiu	sp,sp,-32
8000e134:	afbf001c 	sw	ra,28(sp)
8000e138:	afb00018 	sw	s0,24(sp)
	unsigned long		Address;
	void	(*jump)(void);
	if( argc > 0 )
8000e13c:	1880000c 	blez	a0,8000e170 <CmdCfn+0x40>
8000e140:	3c048001 	lui	a0,0x8001
	{
		if(!Hex2Val( argv[0], &Address ))
8000e144:	8ca40000 	lw	a0,0(a1)
8000e148:	0c001ada 	jal	80006b68 <Hex2Val>
8000e14c:	27a50010 	addiu	a1,sp,16
8000e150:	14400006 	bnez	v0,8000e16c <CmdCfn+0x3c>
8000e154:	00000000 	nop
		{
			printf(" Invalid Address(HEX) value.\n");
8000e158:	3c048001 	lui	a0,0x8001
8000e15c:	0c001cc1 	jal	80007304 <dprintf>
8000e160:	2484232c 	addiu	a0,a0,9004
#endif
#endif
	//flush_cache();
	jump();	
	
}
8000e164:	08003872 	j	8000e1c8 <CmdCfn+0x98>
8000e168:	00001021 	move	v0,zero
			printf(" Invalid Address(HEX) value.\n");
			return FALSE ;
		}
	}

	dprintf("---Jump to address=%X\n",Address);
8000e16c:	3c048001 	lui	a0,0x8001
8000e170:	2484234c 	addiu	a0,a0,9036
8000e174:	0c001cc1 	jal	80007304 <dprintf>
8000e178:	8fa50010 	lw	a1,16(sp)
	jump = (void *)(Address);
8000e17c:	8fb00010 	lw	s0,16(sp)
8000e180:	3c03b800 	lui	v1,0xb800
8000e184:	00001021 	move	v0,zero
8000e188:	ac623000 	sw	v0,12288(v1)
8000e18c:	40016000 	mfc0	at,c0_status
8000e190:	34210001 	ori	at,at,0x1
8000e194:	38210001 	xori	at,at,0x1
8000e198:	40816000 	mtc0	at,c0_status
8000e19c:	000000c0 	ehb
	...
	outl(0,GIMR0); // mask all interrupt
	cli(); 
	flush_cache(); 
8000e1ac:	0c00187c 	jal	800061f0 <flush_cache>
8000e1b0:	00000000 	nop
	prom_printf("\nreboot.......\n");
8000e1b4:	3c048001 	lui	a0,0x8001
8000e1b8:	0c001d43 	jal	8000750c <prom_printf>
8000e1bc:	24840074 	addiu	a0,a0,116
     	}
#endif
#endif
#endif
	//flush_cache();
	jump();	
8000e1c0:	0200f809 	jalr	s0
8000e1c4:	00000000 	nop
	
}
8000e1c8:	8fbf001c 	lw	ra,28(sp)
8000e1cc:	8fb00018 	lw	s0,24(sp)
8000e1d0:	03e00008 	jr	ra
8000e1d4:	27bd0020 	addiu	sp,sp,32
	...
8000e1e0:	80001134 	lb	zero,4404(zero)
8000e1e4:	80001020 	lb	zero,4128(zero)
8000e1e8:	80001038 	lb	zero,4152(zero)
8000e1ec:	800010b0 	lb	zero,4272(zero)
8000e1f0:	80001104 	lb	zero,4356(zero)
8000e1f4:	80001018 	lb	zero,4120(zero)
8000e1f8:	800010c8 	lb	zero,4296(zero)

8000e1fc <BootStateEvent>:
8000e1fc:	800011ec 80000d7c 8000153c 80001788     .......|...<....
8000e20c:	80001144 80001144 80001144 80001144     ...D...D...D...D
8000e21c:	800011ec 80000d7c 8000153c 80000d60     .......|...<...`
8000e22c:	80001dd0 80001410 80000d60 80000d60     ...........`...`
8000e23c:	800011ec 80000d7c 80000d60 80001788     .......|...`....
8000e24c:	80001dd0 80001410 80000d60 80000d60     ...........`...`
	...
8000e270:	c0a80001 00000000 00000000 00000000     ................

8000e280 <fidHashTable>:
8000e280:	000ff0ff                                ....

8000e284 <phy_ado_data>:
8000e284:	0000001b 000083de 0000001c 0000af83     ................
8000e294:	0000001c 0000eaaf 0000001c 000083ed     ................
8000e2a4:	0000001c 0000af85 0000001c 000085af     ................
8000e2b4:	0000001c 00008588 0000001c 0000af0c     ................
8000e2c4:	0000001c 00000cf6 0000001c 00000102     ................
8000e2d4:	0000001c 000083f5 0000001c 0000af00     ................
8000e2e4:	0000001c 00008ff8 0000001c 0000f9cd     ................
8000e2f4:	0000001c 0000f9fa 0000001c 0000ef69     ...............i
8000e304:	0000001c 0000fafb 0000001c 0000e080     ................
8000e314:	0000001c 000013ac 0000001c 00002303     ..............#.
8000e324:	0000001c 0000af85 0000001c 000021d1     ..............!.
8000e334:	0000001c 000000bf 0000001c 00008597     ................
8000e344:	0000001c 00000241 0000001c 000005d1     .......A........
8000e354:	0000001c 00000fbf 0000001c 0000859a     ................
8000e364:	0000001c 00000241 0000001c 000005bf     .......A........
8000e374:	0000001c 0000859d 0000001c 00000245     ...............E
8000e384:	0000001c 0000bbbf 0000001c 000085a0     ................
8000e394:	0000001c 00000245 0000001c 0000b3bf     .......E........
8000e3a4:	0000001c 000085a3 0000001c 00000245     ...............E
8000e3b4:	0000001c 0000b3bf 0000001c 000085a6     ................
8000e3c4:	0000001c 00000245 0000001c 0000b3ee     .......E........
8000e3d4:	0000001c 000087f4 0000001c 0000001f     ................
8000e3e4:	0000001c 000044e0 0000001c 000087f4     ......D.........
8000e3f4:	0000001c 0000bfa8 0000001c 0000c4ef     ................
8000e404:	0000001c 0000591a 0000001c 000054e6     ......Y.......T.
8000e414:	0000001c 000087f5 0000001c 0000e787     ................
8000e424:	0000001c 0000f6e1 0000001c 000087f4     ................
8000e434:	0000001c 0000d000 0000001c 0000bf85     ................
8000e444:	0000001c 00008b4c 0000001c 00000003     .......L........
8000e454:	0000001c 00001a49 0000001c 0000e487     .......I........
8000e464:	0000001c 0000f7e5 0000001c 000087f8     ................
8000e474:	0000001c 0000ee87 0000001c 0000f907     ................
8000e484:	0000001c 0000ee87 0000001c 0000faff     ................
8000e494:	0000001c 0000ee87 0000001c 0000fb00     ................
8000e4a4:	0000001c 0000ee87 0000001c 0000fc10     ................
8000e4b4:	0000001c 0000ee87 0000001c 0000fd00     ................
8000e4c4:	0000001c 00000285 0000001c 00002bef     ..............+.
8000e4d4:	0000001c 000067ad 0000001c 00005f03     ......g......._.
8000e4e4:	0000001c 00007fff 0000001c 0000ffe2     ................
8000e4f4:	0000001c 000087f9 0000001c 0000e387     ................
8000e504:	0000001c 0000fa09 0000001c 0000ef56     ...............V
8000e514:	0000001c 0000ef67 0000001c 00000bc6     .......g........
8000e524:	0000001c 00000244 0000001c 0000f4ad     .......D........
8000e534:	0000001c 00005015 0000001c 0000cce4     ......P.........
8000e544:	0000001c 000087f9 0000001c 0000e587     ................
8000e554:	0000001c 0000fae0 0000001c 000087f7     ................
8000e564:	0000001c 0000e187 0000001c 0000f8ef     ................
8000e574:	0000001c 00009402 0000001c 00004143     ..............AC
8000e584:	0000001c 0000e587 0000001c 0000fee1     ................
8000e594:	0000001c 000087fd 0000001c 00003904     ..............9.
8000e5a4:	0000001c 00009e38 0000001c 0000e187     .......8........
8000e5b4:	0000001c 0000fd11 0000001c 0000e587     ................
8000e5c4:	0000001c 0000fde0 0000001c 000087f7     ................
8000e5d4:	0000001c 0000e187 0000001c 0000f8ef     ................
8000e5e4:	0000001c 00009402 0000001c 00004143     ..............AC
8000e5f4:	0000001c 0000ad37 0000001c 000008e5     .......7........
8000e604:	0000001c 000087fc 0000001c 0000e087     ................
8000e614:	0000001c 0000fbae 0000001c 000006e5     ................
8000e624:	0000001c 000087fb 0000001c 0000e087     ................
8000e634:	0000001c 0000fc1a 0000001c 0000100d     ................
8000e644:	0000001c 000011d0 0000001c 00000008     ................
8000e654:	0000001c 0000e087 0000001c 0000f7e1     ................
8000e664:	0000001c 000087f8 0000001c 0000ef94     ................
8000e674:	0000001c 00000802 0000001c 00004105     ..............A.
8000e684:	0000001c 0000ae8e 0000001c 0000e187     ................
8000e694:	0000001c 0000fed0 0000001c 00000008     ................
8000e6a4:	0000001c 0000e087 0000001c 0000f7e1     ................
8000e6b4:	0000001c 000087f8 0000001c 0000ef94     ................
8000e6c4:	0000001c 00000802 0000001c 00004105     ..............A.
8000e6d4:	0000001c 0000e187 0000001c 0000f439     ...............9
8000e6e4:	0000001c 0000039e 0000001c 00000ae1     ................
8000e6f4:	0000001c 000087f4 0000001c 000011e5     ................
8000e704:	0000001c 000087f4 0000001c 0000af84     ................
8000e714:	0000001c 000033d1 0000001c 000000bf     ......3.........
8000e724:	0000001c 0000859a 0000001c 00000241     ...............A
8000e734:	0000001c 000005bf 0000001c 000085a6     ................
8000e744:	0000001c 00000245 0000001c 0000bbbf     .......E........
8000e754:	0000001c 0000859d 0000001c 00000245     ...............E
8000e764:	0000001c 0000b3bf 0000001c 000085a0     ................
8000e774:	0000001c 00000245 0000001c 0000bbbf     .......E........
8000e784:	0000001c 000085a3 0000001c 00000245     ...............E
8000e794:	0000001c 0000bbff 0000001c 0000feef     ................
8000e7a4:	0000001c 000096fe 0000001c 0000fdc5     ................
8000e7b4:	0000001c 0000fdfc 0000001c 000004f8     ................
8000e7c4:	0000001c 0000f9fa 0000001c 0000ef69     ...............i
8000e7d4:	0000001c 0000fa1f 0000001c 0000441f     ..............D.
8000e7e4:	0000001c 000077e2 0000001c 000087f5     ......w.........
8000e7f4:	0000001c 0000e387 0000001c 0000f6ef     ................
8000e804:	0000001c 000095e2 0000001c 000087f3     ................
8000e814:	0000001c 00001f66 0000001c 0000160c     .......f........
8000e824:	0000001c 000061b2 0000001c 0000fcda     ......a.........
8000e834:	0000001c 000019db 0000001c 0000890c     ................
8000e844:	0000001c 0000570d 0000001c 0000581a     ......W.......X.
8000e854:	0000001c 000045ef 0000001c 000054ef     ......E.......T.
8000e864:	0000001c 0000323a 0000001c 00007f9e     ......2:........
8000e874:	0000001c 0000063b 0000001c 0000809e     .......;........
8000e884:	0000001c 000008ae 0000001c 00000a17     ................
8000e894:	0000001c 00005c00 0000001c 0000ffae     ......\.........
8000e8a4:	0000001c 00000487 0000001c 00006cff     ..............l.
8000e8b4:	0000001c 000000b6 0000001c 0000dc4f     ...............O
8000e8c4:	0000001c 0000007f 0000001c 00000d48     ...............H
8000e8d4:	0000001c 00001a74 0000001c 0000e087     .......t........
8000e8e4:	0000001c 0000f338 0000001c 0000089e     .......8........
8000e8f4:	0000001c 0000050d 0000001c 00007180     ..............q.
8000e904:	0000001c 0000aef9 0000001c 0000feef     ................
8000e914:	0000001c 000096fe 0000001c 0000fdfc     ................
8000e924:	0000001c 000004af 0000001c 00008585     ................
8000e934:	0000001c 0000af85 0000001c 00008830     ...............0
8000e944:	0000001c 0000bcfc 0000001c 000074bc     ..............t.
8000e954:	0000001c 0000fcb8 0000001c 0000bcfc     ................
8000e964:	0000001c 0000fcbc 0000001c 0000fc40     ...............@
8000e974:	0000001c 0000a810 0000001c 000096a8     ................
8000e984:	0000001c 000010aa 0000001c 0000bcd2     ................
8000e994:	0000001c 0000ccbc 0000001c 0000d2ee     ................
8000e9a4:	0000001c 0000bcd2 0000001c 0000ffbc     ................
8000e9b4:	0000001c 0000d200 0000001b 0000b818     ................
8000e9c4:	0000001c 00000bf1 0000001b 0000b81a     ................
8000e9d4:	0000001c 0000008d 0000001b 0000b81c     ................
8000e9e4:	0000001c 0000fffd 0000001b 0000b81e     ................
8000e9f4:	0000001c 0000fffd 0000001b 0000b832     ...............2
8000ea04:	0000001c 00000003 0000001f 00000000     ................
8000ea14:	0000001b 000087f2 0000001c 0000000f     ................

8000ea24 <phy_98c_ado>:
8000ea24:	0000001b 000083de 0000001c 0000af83     ................
8000ea34:	0000001c 0000eaaf 0000001c 000083ed     ................
8000ea44:	0000001c 0000af83 0000001c 0000f0af     ................
8000ea54:	0000001c 000083f3 0000001c 0000af0c     ................
8000ea64:	0000001c 00000caf 0000001c 000083ed     ................
8000ea74:	0000001c 0000af83 0000001c 0000f0af     ................
8000ea84:	0000001c 000083f3 0000001b 0000b818     ................
8000ea94:	0000001c 00000bf1 0000001b 0000b81a     ................
8000eaa4:	0000001c 0000fffd 0000001b 0000b81c     ................
8000eab4:	0000001c 0000fffd 0000001b 0000b81e     ................
8000eac4:	0000001c 0000fffd 0000001b 0000b832     ...............2
8000ead4:	0000001c 00000001 00000000 800045b0     ..............E.
8000eae4:	800045b0 800045d4 8000466c 800045f4     ..E...E...Fl..E.
8000eaf4:	8000466c 8000466c 8000466c 80004614     ..Fl..Fl..Fl..F.
	...

8000eb10 <C.4.1500>:
8000eb10:	00fa010e 01220136 014a015e 01720235     .....".6.J.^.r.5
8000eb20:	019a01ae 01c201d6 01ea01fe 02120226     ...............&
8000eb30:	01860244 02530262 02710280 028f029e     ...D.S.b.q......
8000eb40:	02ad02bc 02d002e4 02f30302 03110320     ............... 

8000eb50 <tiddles.2023>:
8000eb50:	2d5c7c2f 00000000 00000000 00000000     -\|/............

8000eb60 <cpu_clksel_table>:
8000eb60:	000001c2 000001f4 00000226 00000258     ...........&...X
8000eb70:	0000028a 000002bc 000002ee 00000320     ............... 
8000eb80:	00000352 00000384 000003b6 000003e8     ...R............
8000eb90:	0000041a 0000044c 0000047e 000004b0     .......L...~....

8000eba0 <m2x_clksel_table>:
8000eba0:	000000fa 0000010e 00000122 00000136     ..........."...6
8000ebb0:	0000014a 0000015e 00000172 00000235     ...J...^...r...5
8000ebc0:	0000019a 000001ae 000001c2 000001d6     ................
8000ebd0:	000001ea 000001fe 00000212 00000226     ...............&
8000ebe0:	00000186 00000244 00000253 00000262     .......D...S...b
8000ebf0:	00000271 00000280 0000028f 0000029e     ...q............
8000ec00:	000002ad 000002bc 000002d0 000002e4     ................
8000ec10:	000002f3 00000302 00000311 00000320     ............... 
8000ec20:	8000bdc8 8000be1c 8000be58 8000bf9c     ...........X....
8000ec30:	8000bfac 00000000 00000000 00000000     ................
	...
